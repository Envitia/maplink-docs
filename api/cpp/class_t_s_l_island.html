<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLIsland Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.1</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_island.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_t_s_l_island-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLIsland Class Reference<div class="ingroups"><a class="el" href="group__group__spatialeditorsdk.html">MapLink Spatial Editor API</a> &raquo; <a class="el" href="group__group__landlinkapi.html">LandLink API</a> &raquo; <a class="el" href="group__group__landlinkapi__helpers.html">Helpers</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An island is a contiguous set of features.</p>
<p>Islands are created by calling the static method <a class="el" href="#a9bfc9b975619e8df98b96c4f3a4e71ce">createIslands()</a> and passing it a data layer. This method looks for contiguous features; for each such set it will create an island and add it to the set of islands.</p>
<p>NOTE : When creating islands, an assumption is made that the features are touching, rather than overlapping. This is the case for data such as OS MasterMap - as TSLTMC as features such as cliffs, slopes and landform polygons are ignored. This latter is important when capturing island boundaries with holes.</p>
<p>Islands can be merged by calling the static method <a class="el" href="#ac4e6af13160a51d66c39b1a77fb0056d">mergeIslands()</a>, passing it two island sets. This method first works out groups of overlapping islands. For each group, it performs a merging process (which respects version information). The merged result passes through a final island extraction process in case departed features have resulted in the merged island splitting. Once this has been done for all groups, the result is a set of non-overlapping islands.</p>
<p>Users can construct islands in one of two ways: (1) by passing a (tmf) file and extent or (2) by passing a data layer. In the first case, it is assumed that the (tmf) file represents an existing island i.e. it has been produced as a result of an earlier call to <a class="el" href="#a9bfc9b975619e8df98b96c4f3a4e71ce">createIslands()</a>. The extent is expected to be the extent of the island. In the second case, the data layer is assumed to represent an existing island. The island will assume ownership of the data layer. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa4bcd5a882127e5eeab30a57be2261e4" id="r_aa4bcd5a882127e5eeab30a57be2261e4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4bcd5a882127e5eeab30a57be2261e4">TSLIsland</a> (const char *dataFile, const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;<a class="el" href="#a010e1f3b74e47bcc1377b97d3ad5228b">extent</a>, const char *<a class="el" href="#adfff4b4fca13a90f9cafd9dea0460943">id</a>=0)</td></tr>
<tr class="separator:aa4bcd5a882127e5eeab30a57be2261e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a355b685390a76a1e7ede1471d0af009f" id="r_a355b685390a76a1e7ede1471d0af009f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a355b685390a76a1e7ede1471d0af009f">TSLIsland</a> (<a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *data, const char *<a class="el" href="#adfff4b4fca13a90f9cafd9dea0460943">id</a>=0)</td></tr>
<tr class="separator:a355b685390a76a1e7ede1471d0af009f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1615f4f86903e56cfa63aa4463800753" id="r_a1615f4f86903e56cfa63aa4463800753"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1615f4f86903e56cfa63aa4463800753">TSLIsland</a> (const <a class="el" href="class_t_s_l_island.html">TSLIsland</a> &amp;other)</td></tr>
<tr class="separator:a1615f4f86903e56cfa63aa4463800753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a603630eee5a4f7eecf00051a6558f86d" id="r_a603630eee5a4f7eecf00051a6558f86d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_island.html">TSLIsland</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a603630eee5a4f7eecf00051a6558f86d">operator=</a> (const <a class="el" href="class_t_s_l_island.html">TSLIsland</a> &amp;rhs)</td></tr>
<tr class="separator:a603630eee5a4f7eecf00051a6558f86d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c67bf7b7dee10624e21bc991502fa1" id="r_a84c67bf7b7dee10624e21bc991502fa1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_polygon.html">TSLPolygon</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a84c67bf7b7dee10624e21bc991502fa1">boundary</a> (bool includingInners=false) const</td></tr>
<tr class="separator:a84c67bf7b7dee10624e21bc991502fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501d34cd29a19847b97edea8233bbc09" id="r_a501d34cd29a19847b97edea8233bbc09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a501d34cd29a19847b97edea8233bbc09">contains</a> (const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;position) const</td></tr>
<tr class="separator:a501d34cd29a19847b97edea8233bbc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa384693e814b93cab95c2a7e09ebe02" id="r_aaa384693e814b93cab95c2a7e09ebe02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa384693e814b93cab95c2a7e09ebe02">destroy</a> ()</td></tr>
<tr class="separator:aaa384693e814b93cab95c2a7e09ebe02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a010e1f3b74e47bcc1377b97d3ad5228b" id="r_a010e1f3b74e47bcc1377b97d3ad5228b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a010e1f3b74e47bcc1377b97d3ad5228b">extent</a> () const</td></tr>
<tr class="separator:a010e1f3b74e47bcc1377b97d3ad5228b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b67f5b084ecddbfeee1997eacd2da7" id="r_ae2b67f5b084ecddbfeee1997eacd2da7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2b67f5b084ecddbfeee1997eacd2da7">features</a> () const</td></tr>
<tr class="separator:ae2b67f5b084ecddbfeee1997eacd2da7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfff4b4fca13a90f9cafd9dea0460943" id="r_adfff4b4fca13a90f9cafd9dea0460943"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfff4b4fca13a90f9cafd9dea0460943">id</a> () const</td></tr>
<tr class="separator:adfff4b4fca13a90f9cafd9dea0460943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69760f728d811e98813710899b855a1" id="r_af69760f728d811e98813710899b855a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af69760f728d811e98813710899b855a1">id</a> (const char *islandID)</td></tr>
<tr class="separator:af69760f728d811e98813710899b855a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6703d0fbf8c48031747390ab49703e4" id="r_ae6703d0fbf8c48031747390ab49703e4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6703d0fbf8c48031747390ab49703e4">operator new</a> (size_t)</td></tr>
<tr class="separator:ae6703d0fbf8c48031747390ab49703e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2c4be79b304fa23649c1f87e8d412da" id="r_ae2c4be79b304fa23649c1f87e8d412da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae2c4be79b304fa23649c1f87e8d412da">operator delete</a> (void *)</td></tr>
<tr class="separator:ae2c4be79b304fa23649c1f87e8d412da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e56bb787bc0549c267dc4ee3324590" id="r_a61e56bb787bc0549c267dc4ee3324590"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61e56bb787bc0549c267dc4ee3324590">operator new</a> (size_t, char *, int)</td></tr>
<tr class="separator:a61e56bb787bc0549c267dc4ee3324590"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9bc80069d5dcc5c72824d25533c2269a" id="r_a9bc80069d5dcc5c72824d25533c2269a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bc80069d5dcc5c72824d25533c2269a">configure</a> (TSLTMC pointCoincidence=0, TSLTMC tmcPerVertexStrip=6500)</td></tr>
<tr class="separator:a9bc80069d5dcc5c72824d25533c2269a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bfc9b975619e8df98b96c4f3a4e71ce" id="r_a9bfc9b975619e8df98b96c4f3a4e71ce"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bfc9b975619e8df98b96c4f3a4e71ce">createIslands</a> (const <a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *data, <a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;islands)</td></tr>
<tr class="separator:a9bfc9b975619e8df98b96c4f3a4e71ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dffe42a0c4565f1cdf1e0388c3019d" id="r_a60dffe42a0c4565f1cdf1e0388c3019d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a60dffe42a0c4565f1cdf1e0388c3019d">createIslands</a> (<a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *data, <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> *mapLayer, <a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> &amp;mapRefHandler, <a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;islands)</td></tr>
<tr class="separator:a60dffe42a0c4565f1cdf1e0388c3019d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e6af13160a51d66c39b1a77fb0056d" id="r_ac4e6af13160a51d66c39b1a77fb0056d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4e6af13160a51d66c39b1a77fb0056d">mergeIslands</a> (const <a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;islands, <a class="el" href="class_t_s_l_island_merge_set.html">TSLIslandMergeSet</a> &amp;mergedIslands)</td></tr>
<tr class="separator:ac4e6af13160a51d66c39b1a77fb0056d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc587706f5570de254d02e4223411cc" id="r_acfc587706f5570de254d02e4223411cc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfc587706f5570de254d02e4223411cc">mergeIslands</a> (const <a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;islands, <a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *layer, const char *mapName, <a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> &amp;mapRefHandler, <a class="el" href="class_t_s_l_island_merge_set.html">TSLIslandMergeSet</a> &amp;mergedIslands, bool replaceDepartedFeatures=true)</td></tr>
<tr class="separator:acfc587706f5570de254d02e4223411cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b622b827a3cb79b35a2282f5aad2c9" id="r_ad5b622b827a3cb79b35a2282f5aad2c9"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5b622b827a3cb79b35a2282f5aad2c9">mergeIslands</a> (const <a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;islands, const char *mapName, <a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> &amp;mapRefHandler, <a class="el" href="class_t_s_l_island_merge_set.html">TSLIslandMergeSet</a> &amp;mergedIslands, bool replaceDepartedFeatures=true)</td></tr>
<tr class="separator:ad5b622b827a3cb79b35a2282f5aad2c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbda83e5c2164f7cf6150d6660c4e54" id="r_aafbda83e5c2164f7cf6150d6660c4e54"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aafbda83e5c2164f7cf6150d6660c4e54">sortDepartedFeatures</a> (<a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> *mapLayer, <a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> &amp;mapRefHandler, <a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;islands)</td></tr>
<tr class="separator:aafbda83e5c2164f7cf6150d6660c4e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee4b9e9dfdbc862ef5b1778d06ca2a42" id="r_aee4b9e9dfdbc862ef5b1778d06ca2a42"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee4b9e9dfdbc862ef5b1778d06ca2a42">createIslands</a> (<a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *data, const char *mapName, <a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> &amp;mapRefHandler, <a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;islands)</td></tr>
<tr class="separator:aee4b9e9dfdbc862ef5b1778d06ca2a42"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa4bcd5a882127e5eeab30a57be2261e4" name="aa4bcd5a882127e5eeab30a57be2261e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4bcd5a882127e5eeab30a57be2261e4">&#9670;&#160;</a></span>TSLIsland() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLIsland::TSLIsland </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dataFile</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>id</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an island based on its (tmf) file and extent. The (tmf) file is assumed to contain the island features only. It is not automatically loaded into the data layer. This will only happen if the data layer is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataFile</td><td>The (tmf) file containing the island features. </td></tr>
    <tr><td class="paramname">extent</td><td>The extent of the features. </td></tr>
    <tr><td class="paramname">id</td><td>The id of the island. If this is NULL, then a default id will be generated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a355b685390a76a1e7ede1471d0af009f" name="a355b685390a76a1e7ede1471d0af009f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a355b685390a76a1e7ede1471d0af009f">&#9670;&#160;</a></span>TSLIsland() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLIsland::TSLIsland </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>id</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs an island given a data layer. The data layer is assumed to contain the island features only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data layer containing the island features. </td></tr>
    <tr><td class="paramname">id</td><td>The id of the island. If this is NULL, then a default id will be generated.</td></tr>
  </table>
  </dd>
</dl>
<p>The island takes ownership of the data layer. </p>

</div>
</div>
<a id="a1615f4f86903e56cfa63aa4463800753" name="a1615f4f86903e56cfa63aa4463800753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1615f4f86903e56cfa63aa4463800753">&#9670;&#160;</a></span>TSLIsland() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLIsland::TSLIsland </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_island.html">TSLIsland</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a84c67bf7b7dee10624e21bc991502fa1" name="a84c67bf7b7dee10624e21bc991502fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c67bf7b7dee10624e21bc991502fa1">&#9670;&#160;</a></span>boundary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_polygon.html">TSLPolygon</a> * TSLIsland::boundary </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>includingInners</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the polygon that represents the boundary of the island. If the polygon has not yet been constructed, then, if necessary, the data is loaded into the data layer and the boundary is constructed based on the layer contents.</p>
<p>When the boundary includes inners, it is important that the island polygons do not overlap. Typical problem cases are OSMM cliffs, slopes and landform polygons. This is not an issue if inners are not required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">includingInners</td><td>True if the created boundary should check for inner boundaries as well. Default false. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bc80069d5dcc5c72824d25533c2269a" name="a9bc80069d5dcc5c72824d25533c2269a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bc80069d5dcc5c72824d25533c2269a">&#9670;&#160;</a></span>configure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TSLIsland::configure </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>pointCoincidence</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>tmcPerVertexStrip</em></span><span class="paramdefsep"> = </span><span class="paramdefval">6500</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internally, the island creation uses some highly optimised spatial algorithms. This method allows an application to tune some parameters of these algorithms.</p>
<p>The default values that are used if this method is not called are suitable for OS MasterMap with 1000 TMC per metre scaling.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pointCoincidence</td><td>This is the distance in TMC whereby points are considered the same. Default 0.</td></tr>
    <tr><td class="paramname">tmcPerVertexStrip</td><td>Vertices are organised in horizontal strips for fast searching. This is the number of TMC for each vertex strip. The maximum number of vertex strips is 10000. Default value is 6500. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a501d34cd29a19847b97edea8233bbc09" name="a501d34cd29a19847b97edea8233bbc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501d34cd29a19847b97edea8233bbc09">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLIsland::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>position</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns True if the boundary contains the given position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">position</td><td>The position to query against. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bfc9b975619e8df98b96c4f3a4e71ce" name="a9bfc9b975619e8df98b96c4f3a4e71ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bfc9b975619e8df98b96c4f3a4e71ce">&#9670;&#160;</a></span>createIslands() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLIsland::createIslands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>islands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static method that creates a set of islands from the supplied data layer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data layer from which we wish to extract islands. </td></tr>
    <tr><td class="paramname">islands</td><td>An island set which will be populated with the islands that are created from the layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if no islands were created or if some other error occurred, otherwise returns true.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>Each island is given a unique ID. This is unique only for the duration of the application that calls this method.</li>
<li>All entities within the supplied data layer are removed from the layer.</li>
<li>If the input data contains no polygons, then no islands will be created. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="aee4b9e9dfdbc862ef5b1778d06ca2a42" name="aee4b9e9dfdbc862ef5b1778d06ca2a42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee4b9e9dfdbc862ef5b1778d06ca2a42">&#9670;&#160;</a></span>createIslands() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLIsland::createIslands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>mapName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapRefHandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>islands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deprecated Functions </p>

</div>
</div>
<a id="a60dffe42a0c4565f1cdf1e0388c3019d" name="a60dffe42a0c4565f1cdf1e0388c3019d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dffe42a0c4565f1cdf1e0388c3019d">&#9670;&#160;</a></span>createIslands() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLIsland::createIslands </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> *</td>          <td class="paramname"><span class="paramname"><em>mapLayer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapRefHandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>islands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static method that creates a set of islands from the supplied data layer for the given (seamless layer) map. The difference between this method and the other <a class="el" href="#a9bfc9b975619e8df98b96c4f3a4e71ce">createIslands()</a> method is that this method will attempt to preserve 'departed' features and also reconstruct their geometries (from the existing map).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data layer from which we wish to extract islands. </td></tr>
    <tr><td class="paramname">mapLayer</td><td>The MapDataLayer which is associated with the islands. </td></tr>
    <tr><td class="paramname">mapRefHandler</td><td>The entity-reference handler for the map. </td></tr>
    <tr><td class="paramname">islands</td><td>An island set which will be populated with the islands that are created from the layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><p class="startdd">Returns false under the following conditions:</p>
<ol type="1">
<li>If no map layer is specified.</li>
<li>If the map cannot be found.</li>
<li>If the map has no associated seamless layer configuration.</li>
<li>If no islands were created or if some other error occurred.</li>
</ol>
<p class="enddd">Otherwise returns true. </p>
</dd></dl>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>Each island is given a unique ID. This is unique only for the duration of the application that calls this method.</li>
<li>All entities within the supplied data layer are removed from the layer.</li>
<li>The associated map must contain one or more seamless layers.</li>
<li>If the input data contains no polygons, then no islands will be created. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="aaa384693e814b93cab95c2a7e09ebe02" name="aaa384693e814b93cab95c2a7e09ebe02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa384693e814b93cab95c2a7e09ebe02">&#9670;&#160;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLIsland::destroy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the object. </p>

</div>
</div>
<a id="a010e1f3b74e47bcc1377b97d3ad5228b" name="a010e1f3b74e47bcc1377b97d3ad5228b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a010e1f3b74e47bcc1377b97d3ad5228b">&#9670;&#160;</a></span>extent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp; TSLIsland::extent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the extent of the island. If the extent has not yet been calculated, then, if necessary, the data is loaded into the data layer and the layer queried for the extent. </p>

</div>
</div>
<a id="ae2b67f5b084ecddbfeee1997eacd2da7" name="ae2b67f5b084ecddbfeee1997eacd2da7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2b67f5b084ecddbfeee1997eacd2da7">&#9670;&#160;</a></span>features()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> * TSLIsland::features </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the island features as a data layer. If the data layer has not yet been constructed, then it is constructed now and the data loaded. </p>

</div>
</div>
<a id="adfff4b4fca13a90f9cafd9dea0460943" name="adfff4b4fca13a90f9cafd9dea0460943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfff4b4fca13a90f9cafd9dea0460943">&#9670;&#160;</a></span>id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * TSLIsland::id </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the unique ID of the layer. </p>

</div>
</div>
<a id="af69760f728d811e98813710899b855a1" name="af69760f728d811e98813710899b855a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af69760f728d811e98813710899b855a1">&#9670;&#160;</a></span>id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLIsland::id </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>islandID</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the unique ID of the island.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">islandID</td><td>A string representing the unique ID of the island. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5b622b827a3cb79b35a2282f5aad2c9" name="ad5b622b827a3cb79b35a2282f5aad2c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b622b827a3cb79b35a2282f5aad2c9">&#9670;&#160;</a></span>mergeIslands() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLIsland::mergeIslands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>islands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>mapName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapRefHandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_island_merge_set.html">TSLIslandMergeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mergedIslands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>replaceDepartedFeatures</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static method that merges a set of islands. The difference between this method and the other <a class="el" href="#ac4e6af13160a51d66c39b1a77fb0056d">mergeIslands()</a> method is that this method will automatically update existing features with respect to version changes and it will also attempt to preserve 'departed' features.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">islands</td><td>The input island set. </td></tr>
    <tr><td class="paramname">mapName</td><td>The full path of the map which is associated with the islands. </td></tr>
    <tr><td class="paramname">mapRefHandler</td><td>The entity-reference handler for the map. </td></tr>
    <tr><td class="paramname">mergedIslands</td><td>The resulting set of merged islands. </td></tr>
    <tr><td class="paramname">replaceDepartedFeatures</td><td>If true, departed features will have their geometry replaced with that of the original feature from the map. Default is true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the merge was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ac4e6af13160a51d66c39b1a77fb0056d" name="ac4e6af13160a51d66c39b1a77fb0056d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e6af13160a51d66c39b1a77fb0056d">&#9670;&#160;</a></span>mergeIslands() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLIsland::mergeIslands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>islands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_island_merge_set.html">TSLIslandMergeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mergedIslands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static method that merges a set of islands. This is a purely geometrical merge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">islands</td><td>The input island set. </td></tr>
    <tr><td class="paramname">mergedIslands</td><td>The resulting set of merged islands.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the merge was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="acfc587706f5570de254d02e4223411cc" name="acfc587706f5570de254d02e4223411cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc587706f5570de254d02e4223411cc">&#9670;&#160;</a></span>mergeIslands() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLIsland::mergeIslands </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>islands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *</td>          <td class="paramname"><span class="paramname"><em>layer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>mapName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapRefHandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_island_merge_set.html">TSLIslandMergeSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mergedIslands</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>replaceDepartedFeatures</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static method that merges a data layer with a set of islands. The difference between this method and the other <a class="el" href="#ac4e6af13160a51d66c39b1a77fb0056d">mergeIslands()</a> method is that this method will automatically update existing features with respect to version changes and it will also attempt to preserve 'departed' features.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">islands</td><td>The input island set. </td></tr>
    <tr><td class="paramname">layer</td><td>The data layer. </td></tr>
    <tr><td class="paramname">mapName</td><td>The full path of the map which is associated with the islands. </td></tr>
    <tr><td class="paramname">mapRefHandler</td><td>The entity-reference handler for the map. </td></tr>
    <tr><td class="paramname">mergedIslands</td><td>The resulting set of merged islands. </td></tr>
    <tr><td class="paramname">replaceDepartedFeatures</td><td>If true, departed features will have their geometry replaced with that of the original feature from the map. Default is true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the merge was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ae2c4be79b304fa23649c1f87e8d412da" name="ae2c4be79b304fa23649c1f87e8d412da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2c4be79b304fa23649c1f87e8d412da">&#9670;&#160;</a></span>operator delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLIsland::operator delete </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6703d0fbf8c48031747390ab49703e4" name="ae6703d0fbf8c48031747390ab49703e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6703d0fbf8c48031747390ab49703e4">&#9670;&#160;</a></span>operator new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLIsland::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocation override for API redirection. </p>

</div>
</div>
<a id="a61e56bb787bc0549c267dc4ee3324590" name="a61e56bb787bc0549c267dc4ee3324590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e56bb787bc0549c267dc4ee3324590">&#9670;&#160;</a></span>operator new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLIsland::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em></em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em></em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When included in an MFC application in debug mode, the debug new expects this to be here. Override it and return the same as the normal one. The library must include it when compiled in release mode, since the user's application may be in debug mode. </p>

</div>
</div>
<a id="a603630eee5a4f7eecf00051a6558f86d" name="a603630eee5a4f7eecf00051a6558f86d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a603630eee5a4f7eecf00051a6558f86d">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_island.html">TSLIsland</a> &amp; TSLIsland::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_island.html">TSLIsland</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator. </p>

</div>
</div>
<a id="aafbda83e5c2164f7cf6150d6660c4e54" name="aafbda83e5c2164f7cf6150d6660c4e54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbda83e5c2164f7cf6150d6660c4e54">&#9670;&#160;</a></span>sortDepartedFeatures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLIsland::sortDepartedFeatures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> *</td>          <td class="paramname"><span class="paramname"><em>mapLayer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mapRefHandler</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_island_set.html">TSLIslandSet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>islands</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Static method that rearranges departed features present in the source islands as points into the correct island based on the location of the original feature in the map.</p>
<p>This method is intended for use after a call to createIslands(TSLStandardd
DataLayer, TSLIslandSet) as this method does not correctly place these departed features in the resulting island set. This method can also be used to correctly place departed features in islands created by the other <a class="el" href="#a9bfc9b975619e8df98b96c4f3a4e71ce">createIslands()</a> method that are inside the island rather than having contiguous edges and so would otherwise be placed into a separate island.</p>
<p>No features will be deleted by this operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapLayer</td><td>The map layer that is associated with the islands. </td></tr>
    <tr><td class="paramname">mapRefHandler</td><td>The entity reference handler for the map. </td></tr>
    <tr><td class="paramname">islands</td><td>An island set containing the features to be reorganised.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, or false on failure. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_island.html">TSLIsland</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.1 | Documentation created Thu Feb 6 2025 11:09:34 | Generated with <a href="http://www.doxygen.org/index.html">Doxygen 1.13.2</a> | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
