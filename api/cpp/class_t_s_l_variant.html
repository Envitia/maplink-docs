<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLVariant Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.2</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_variant.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="class_t_s_l_variant-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLVariant Class Reference<div class="ingroups"><a class="el" href="group__apigroup__maplink__pro__developers__toolkit.html">MapLink Pro Developer Toolkit</a> &raquo; <a class="el" href="group__apigroup__common.html">Common</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class encapsulates a discriminated union for use with the TSL... classes. It can hold instances or arrays of the following set of base types:</p>
<ul>
<li>TSLVariantTypeBool (bool),</li>
<li>TSLVariantTypeChar (8bit char),</li>
<li>TSLVariantTypeShort (16bit short),</li>
<li>TSLVariantTypeLong (32bit long),</li>
<li>TSLVariantTypeFloat (32bit float),</li>
<li>TSLVariantTypeDouble (64bit double),</li>
<li>TSLVariantTypeStr (string),</li>
<li>TSLVariantTypeNull (null string - different from a 'nil' variant which can apply to any type).</li>
<li>TSLVariantTypeEntityID (TSLEntityID)</li>
<li>TSLVariantTypeULong (32bit unsigned long)</li>
<li>TSLVariantTypeBinary (TSLVariant::Binary)</li>
<li>TSLVariantTypeDateTime (TSLTimeType)</li>
<li>TSLVariantTypeCode (TSLVariant::Code)</li>
<li>TSLVariantTypeMeasurement (TSLVariant::Measurement)</li>
<li>TSLVariantTypeReference (string)</li>
<li>TSLVariantTypeURI (string)</li>
<li>TSLVariantTypePtr (void * pointer, 32bit when compiled 32bit, 64bit when compiled 64bit)</li>
<li>TSLVariantTypeVariant (A collection of other TSLVariants)</li>
</ul>
<p>These types are defined by the enumeration <a class="el" href="group__apigroup__common.html#ga446166666f65a13f3de2cf6a35228e02">TSLVariantType</a>.</p>
<h1><a class="anchor" id="autotoc_md34"></a>
NOTE:</h1>
<ol type="1">
<li>TSLVariantTypeChar stores an array of characters, TSLVariantTypeStr stores an array of strings. Since all arrays have a maximum size of 255, TSLVariantTypeChar is limited to 255-character strings. Use an array of strings to store arbitrary-length strings (the array may have one entry, to store a single string).</li>
<li>For single strings, getVal( const char * val ) is the easiest for querying. The easiest way to deal setting string data, or arrays of string data, is to use the setStringVal / getStringVal / getStringLen. methods rather than the overloaded getVal / setVal methods.</li>
<li>A null string ("") is treated as a non-array (<a class="el" href="#aca614b049f70effbabc44b7c9e6a4497">isArray()</a> returns false) of type TSLVariantTypeNull - getVal( const char * val ) handles this correctly.</li>
<li>All arrays are limited to 255 entries maximum.</li>
<li>For compatibility with 64bit non-Windows Operating Systems such as Linux/Solaris/DEC-Alpha which have 8-byte longs, longs are treated as ints internally to this class.</li>
<li>Variants may be 'nil' - which can be tested or set using the 'isNil' method. If this is true then the variant value should not be queried.</li>
<li>Variants may be external references - such as a database key or hyperlink. If so, then the 'isExternalReference' flag is set</li>
<li>TSLVariantTypePtr are not persistent, i.e. they are not eligible for streaming. </li>
</ol>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aedc0ef89b7145df6bca33bad12c43070" id="r_aedc0ef89b7145df6bca33bad12c43070"><td class="memItemLeft" align="right" valign="top">typedef unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedc0ef89b7145df6bca33bad12c43070">Byte_</a></td></tr>
<tr class="separator:aedc0ef89b7145df6bca33bad12c43070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8afb54fa6e3e20f7a80a7644a8fa129f" id="r_a8afb54fa6e3e20f7a80a7644a8fa129f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8afb54fa6e3e20f7a80a7644a8fa129f">TSLVariant</a> ()</td></tr>
<tr class="separator:a8afb54fa6e3e20f7a80a7644a8fa129f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91de95a59a4df04e38aea2675eef79c8" id="r_a91de95a59a4df04e38aea2675eef79c8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91de95a59a4df04e38aea2675eef79c8">TSLVariant</a> (const <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> &amp;rhs)</td></tr>
<tr class="separator:a91de95a59a4df04e38aea2675eef79c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61bddbfce7a0eaec3e3e34a5d63e3867" id="r_a61bddbfce7a0eaec3e3e34a5d63e3867"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61bddbfce7a0eaec3e3e34a5d63e3867">~TSLVariant</a> ()</td></tr>
<tr class="separator:a61bddbfce7a0eaec3e3e34a5d63e3867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae498676b2d0d0253904de5d5806ba37d" id="r_ae498676b2d0d0253904de5d5806ba37d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_variant.html">TSLVariant</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae498676b2d0d0253904de5d5806ba37d">operator=</a> (const <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> &amp;rhs)</td></tr>
<tr class="separator:ae498676b2d0d0253904de5d5806ba37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d55e57f4dfbe8b00f2d752efc913a5a" id="r_a0d55e57f4dfbe8b00f2d752efc913a5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d55e57f4dfbe8b00f2d752efc913a5a">operator==</a> (const <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> &amp;other) const</td></tr>
<tr class="separator:a0d55e57f4dfbe8b00f2d752efc913a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb342329fb0d476d8b3d3c391ab5622d" id="r_abb342329fb0d476d8b3d3c391ab5622d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb342329fb0d476d8b3d3c391ab5622d">clear</a> ()</td></tr>
<tr class="separator:abb342329fb0d476d8b3d3c391ab5622d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8b33c6d1049ba8473f8f62110dcb8d" id="r_a6c8b33c6d1049ba8473f8f62110dcb8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c8b33c6d1049ba8473f8f62110dcb8d">compareValues</a> (const <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> &amp;other) const</td></tr>
<tr class="separator:a6c8b33c6d1049ba8473f8f62110dcb8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac232d877511eb3946b1d030f81ebefaa" id="r_ac232d877511eb3946b1d030f81ebefaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac232d877511eb3946b1d030f81ebefaa">copyVal</a> (const <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> *val)</td></tr>
<tr class="separator:ac232d877511eb3946b1d030f81ebefaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1884763e3ce1acea1e006f38b36c748" id="r_ae1884763e3ce1acea1e006f38b36c748"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1884763e3ce1acea1e006f38b36c748">getStringLen</a> (int *len) const</td></tr>
<tr class="separator:ae1884763e3ce1acea1e006f38b36c748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65889b3e476f60249cb142701fad5ebd" id="r_a65889b3e476f60249cb142701fad5ebd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65889b3e476f60249cb142701fad5ebd">getStringVal</a> (char *val, int len) const</td></tr>
<tr class="separator:a65889b3e476f60249cb142701fad5ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ee76f6033efc7f6aba2374193a1cb6" id="r_a53ee76f6033efc7f6aba2374193a1cb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53ee76f6033efc7f6aba2374193a1cb6">getTimeVal</a> (TSLTimeType *val) const</td></tr>
<tr class="separator:a53ee76f6033efc7f6aba2374193a1cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab9a6c9480e98f48ddd018a7bf83b75" id="r_acab9a6c9480e98f48ddd018a7bf83b75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apigroup__common.html#ga446166666f65a13f3de2cf6a35228e02">TSLVariantType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acab9a6c9480e98f48ddd018a7bf83b75">getType</a> () const</td></tr>
<tr class="separator:acab9a6c9480e98f48ddd018a7bf83b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ba01e763a1a49fcab87119541fc3e4c" id="r_a4ba01e763a1a49fcab87119541fc3e4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ba01e763a1a49fcab87119541fc3e4c">getVal</a> (bool *val) const</td></tr>
<tr class="separator:a4ba01e763a1a49fcab87119541fc3e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a180f349032b8dc491a6789342dd4619a" id="r_a180f349032b8dc491a6789342dd4619a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a180f349032b8dc491a6789342dd4619a">getVal</a> (char *val) const</td></tr>
<tr class="separator:a180f349032b8dc491a6789342dd4619a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484c8507085882e37a664c84df97b6ac" id="r_a484c8507085882e37a664c84df97b6ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a484c8507085882e37a664c84df97b6ac">getVal</a> (char *val[]) const</td></tr>
<tr class="separator:a484c8507085882e37a664c84df97b6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a59b4dff3ee81dcfb7bec63eb75a60" id="r_a03a59b4dff3ee81dcfb7bec63eb75a60"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03a59b4dff3ee81dcfb7bec63eb75a60">getVal</a> (short *val) const</td></tr>
<tr class="separator:a03a59b4dff3ee81dcfb7bec63eb75a60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3feedda08870208b3a22aeb7286dfad4" id="r_a3feedda08870208b3a22aeb7286dfad4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3feedda08870208b3a22aeb7286dfad4">getVal</a> (int *val) const</td></tr>
<tr class="separator:a3feedda08870208b3a22aeb7286dfad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80bbac8d3ef916fd0e60af4cf04bdf0" id="r_ab80bbac8d3ef916fd0e60af4cf04bdf0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab80bbac8d3ef916fd0e60af4cf04bdf0">getVal</a> (float *val) const</td></tr>
<tr class="separator:ab80bbac8d3ef916fd0e60af4cf04bdf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982498500e59d20f6db2260559c3f704" id="r_a982498500e59d20f6db2260559c3f704"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a982498500e59d20f6db2260559c3f704">getVal</a> (double *val) const</td></tr>
<tr class="separator:a982498500e59d20f6db2260559c3f704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9155b561bff9f301928bd1d79ea5305" id="r_ac9155b561bff9f301928bd1d79ea5305"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9155b561bff9f301928bd1d79ea5305">getVal</a> (const char **val) const</td></tr>
<tr class="separator:ac9155b561bff9f301928bd1d79ea5305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12556b8882b803e9c4a7f3805c75ff9d" id="r_a12556b8882b803e9c4a7f3805c75ff9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12556b8882b803e9c4a7f3805c75ff9d">getVal</a> (TSLEntityID *val) const</td></tr>
<tr class="separator:a12556b8882b803e9c4a7f3805c75ff9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d9996d43b413182a806fd94f4e282b" id="r_ad2d9996d43b413182a806fd94f4e282b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2d9996d43b413182a806fd94f4e282b">getVal</a> (unsigned int *val) const</td></tr>
<tr class="separator:ad2d9996d43b413182a806fd94f4e282b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5268f6e68415ee7b84bc3bc3f6d8f575" id="r_a5268f6e68415ee7b84bc3bc3f6d8f575"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5268f6e68415ee7b84bc3bc3f6d8f575">getVal</a> (unsigned char **blobs, int *blobLengths, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> *mimeTypes, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> *urls, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> *roles) const</td></tr>
<tr class="separator:a5268f6e68415ee7b84bc3bc3f6d8f575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e80049e5aa725bc81924164fc880b2b" id="r_a1e80049e5aa725bc81924164fc880b2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e80049e5aa725bc81924164fc880b2b">getVal</a> (<a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> *codes, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> *codeSpaces) const</td></tr>
<tr class="separator:a1e80049e5aa725bc81924164fc880b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74969783b4b41e42bd9e1a67ad1123a2" id="r_a74969783b4b41e42bd9e1a67ad1123a2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74969783b4b41e42bd9e1a67ad1123a2">getVal</a> (double *measurements, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> *uoms) const</td></tr>
<tr class="separator:a74969783b4b41e42bd9e1a67ad1123a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2e5ccbc4939fb220ff3ca5c38539bd2" id="r_af2e5ccbc4939fb220ff3ca5c38539bd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2e5ccbc4939fb220ff3ca5c38539bd2">getVal</a> (void **ptr) const</td></tr>
<tr class="separator:af2e5ccbc4939fb220ff3ca5c38539bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2ee587abd26de9b6fa1b85cc6519e5" id="r_a7a2ee587abd26de9b6fa1b85cc6519e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a2ee587abd26de9b6fa1b85cc6519e5">getVal</a> (<a class="el" href="class_t_s_l_variant.html">TSLVariant</a> *ptr) const</td></tr>
<tr class="separator:a7a2ee587abd26de9b6fa1b85cc6519e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad646118778d8ae0ba7dbcfa0ec492d8f" id="r_ad646118778d8ae0ba7dbcfa0ec492d8f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad646118778d8ae0ba7dbcfa0ec492d8f">getVal</a> (bool &amp;val, int index) const</td></tr>
<tr class="separator:ad646118778d8ae0ba7dbcfa0ec492d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26937aeead89cef71fba76608f0c5173" id="r_a26937aeead89cef71fba76608f0c5173"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26937aeead89cef71fba76608f0c5173">getVal</a> (short &amp;val, int index) const</td></tr>
<tr class="separator:a26937aeead89cef71fba76608f0c5173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba69d31efc81f881be2e95f79c67e349" id="r_aba69d31efc81f881be2e95f79c67e349"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba69d31efc81f881be2e95f79c67e349">getVal</a> (int &amp;val, int index) const</td></tr>
<tr class="separator:aba69d31efc81f881be2e95f79c67e349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43bbc40fe3cb0fc89f88662af9ccb3f7" id="r_a43bbc40fe3cb0fc89f88662af9ccb3f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43bbc40fe3cb0fc89f88662af9ccb3f7">getVal</a> (float &amp;val, int index) const</td></tr>
<tr class="separator:a43bbc40fe3cb0fc89f88662af9ccb3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4746eb8179ccf54fa0c7753e4318b48" id="r_aa4746eb8179ccf54fa0c7753e4318b48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa4746eb8179ccf54fa0c7753e4318b48">getVal</a> (double &amp;val, int index) const</td></tr>
<tr class="separator:aa4746eb8179ccf54fa0c7753e4318b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a853008660bc3cba8b2dd9dfccd6ea6bf" id="r_a853008660bc3cba8b2dd9dfccd6ea6bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a853008660bc3cba8b2dd9dfccd6ea6bf">getVal</a> (TSLEntityID &amp;val, int index) const</td></tr>
<tr class="separator:a853008660bc3cba8b2dd9dfccd6ea6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b63f44efc55d8dbb6a10f24a4e9bc4" id="r_a49b63f44efc55d8dbb6a10f24a4e9bc4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49b63f44efc55d8dbb6a10f24a4e9bc4">getValueAsString</a> (char *str, int len, const char *format=0) const</td></tr>
<tr class="separator:a49b63f44efc55d8dbb6a10f24a4e9bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224a48cbfbb1119d68e501db67ae3da3" id="r_a224a48cbfbb1119d68e501db67ae3da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a224a48cbfbb1119d68e501db67ae3da3">id</a> (const char *str)</td></tr>
<tr class="separator:a224a48cbfbb1119d68e501db67ae3da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36d18c2c1bbde32775397dd09e4c7a7c" id="r_a36d18c2c1bbde32775397dd09e4c7a7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36d18c2c1bbde32775397dd09e4c7a7c">getID</a> (char str[3]) const</td></tr>
<tr class="separator:a36d18c2c1bbde32775397dd09e4c7a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2511f52d19d3d8546d2a7dc42a1c8371" id="r_a2511f52d19d3d8546d2a7dc42a1c8371"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2511f52d19d3d8546d2a7dc42a1c8371">init</a> ()</td></tr>
<tr class="separator:a2511f52d19d3d8546d2a7dc42a1c8371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca614b049f70effbabc44b7c9e6a4497" id="r_aca614b049f70effbabc44b7c9e6a4497"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca614b049f70effbabc44b7c9e6a4497">isArray</a> () const</td></tr>
<tr class="separator:aca614b049f70effbabc44b7c9e6a4497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6c718d74b7ccb86b21cab0c219c39b" id="r_acd6c718d74b7ccb86b21cab0c219c39b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd6c718d74b7ccb86b21cab0c219c39b">isExternalReference</a> () const</td></tr>
<tr class="separator:acd6c718d74b7ccb86b21cab0c219c39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c3503aad1ae17cab6473973fb9d72d8" id="r_a7c3503aad1ae17cab6473973fb9d72d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c3503aad1ae17cab6473973fb9d72d8">isExternalReference</a> (bool isExternal)</td></tr>
<tr class="separator:a7c3503aad1ae17cab6473973fb9d72d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21322a1f8bc74c62ca4b2351d6ecc97a" id="r_a21322a1f8bc74c62ca4b2351d6ecc97a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21322a1f8bc74c62ca4b2351d6ecc97a">isNil</a> () const</td></tr>
<tr class="separator:a21322a1f8bc74c62ca4b2351d6ecc97a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6052a43b338a343001c4322147b935b6" id="r_a6052a43b338a343001c4322147b935b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6052a43b338a343001c4322147b935b6">isNil</a> (bool nil)</td></tr>
<tr class="separator:a6052a43b338a343001c4322147b935b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a155fb3a2ce105468f16bc65956e03dfe" id="r_a155fb3a2ce105468f16bc65956e03dfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a155fb3a2ce105468f16bc65956e03dfe">setReferenceVal</a> (const char *const val[], unsigned char N=1)</td></tr>
<tr class="separator:a155fb3a2ce105468f16bc65956e03dfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1af15607119cd900aebbf3f4ef27bc1" id="r_aa1af15607119cd900aebbf3f4ef27bc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa1af15607119cd900aebbf3f4ef27bc1">setStringVal</a> (const char *val, bool promote=false)</td></tr>
<tr class="separator:aa1af15607119cd900aebbf3f4ef27bc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866add001c6c0c08ea213769cc91c73d" id="r_a866add001c6c0c08ea213769cc91c73d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a866add001c6c0c08ea213769cc91c73d">setTimeVal</a> (const TSLTimeType *val, unsigned char N=1)</td></tr>
<tr class="separator:a866add001c6c0c08ea213769cc91c73d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af37d20d05996e913236d7a71edb2f6bc" id="r_af37d20d05996e913236d7a71edb2f6bc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af37d20d05996e913236d7a71edb2f6bc">setURIVal</a> (const char *const val[], unsigned char N=1)</td></tr>
<tr class="separator:af37d20d05996e913236d7a71edb2f6bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a899347d4eb8a32e80864c1a4a5126727" id="r_a899347d4eb8a32e80864c1a4a5126727"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a899347d4eb8a32e80864c1a4a5126727">setVal</a> (const bool *val, unsigned char N=1)</td></tr>
<tr class="separator:a899347d4eb8a32e80864c1a4a5126727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed337300405ad408e1e9cc9d4e64bd1" id="r_a7ed337300405ad408e1e9cc9d4e64bd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ed337300405ad408e1e9cc9d4e64bd1">setVal</a> (const char *val, unsigned char N=1)</td></tr>
<tr class="separator:a7ed337300405ad408e1e9cc9d4e64bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab620359a04354dff828b45530c77c17d" id="r_ab620359a04354dff828b45530c77c17d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab620359a04354dff828b45530c77c17d">setVal</a> (const char *const val[], unsigned char N=1)</td></tr>
<tr class="separator:ab620359a04354dff828b45530c77c17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f1055f83d2ab8a9d774f1d26882d8f" id="r_ac8f1055f83d2ab8a9d774f1d26882d8f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8f1055f83d2ab8a9d774f1d26882d8f">setVal</a> (const short *val, unsigned char N=1)</td></tr>
<tr class="separator:ac8f1055f83d2ab8a9d774f1d26882d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6b95aa70bcd82792f89318595a1594" id="r_a6c6b95aa70bcd82792f89318595a1594"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c6b95aa70bcd82792f89318595a1594">setVal</a> (const int *val, unsigned char N=1)</td></tr>
<tr class="separator:a6c6b95aa70bcd82792f89318595a1594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3098771890458ac3b52212e4a302e47" id="r_ab3098771890458ac3b52212e4a302e47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3098771890458ac3b52212e4a302e47">setVal</a> (const float *val, unsigned char N=1)</td></tr>
<tr class="separator:ab3098771890458ac3b52212e4a302e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bd98d40bcd527001e5e317e32ca68b" id="r_a87bd98d40bcd527001e5e317e32ca68b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87bd98d40bcd527001e5e317e32ca68b">setVal</a> (const double *val, unsigned char N=1)</td></tr>
<tr class="separator:a87bd98d40bcd527001e5e317e32ca68b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36a1058279687b316fe113569d4f2ae7" id="r_a36a1058279687b316fe113569d4f2ae7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36a1058279687b316fe113569d4f2ae7">setVal</a> (const TSLEntityID *val, unsigned char N=1)</td></tr>
<tr class="separator:a36a1058279687b316fe113569d4f2ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2baf5eb2eec93f262fae86475fd6d79" id="r_ab2baf5eb2eec93f262fae86475fd6d79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2baf5eb2eec93f262fae86475fd6d79">setVal</a> (const unsigned int *val, unsigned char N=1)</td></tr>
<tr class="separator:ab2baf5eb2eec93f262fae86475fd6d79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb1d4f245233d5513b53a8a2119e6e9" id="r_a1eb1d4f245233d5513b53a8a2119e6e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1eb1d4f245233d5513b53a8a2119e6e9">setVal</a> (const unsigned char *const *blobs, int *blobLengths, const char *const *mimeTypes, const char *const *urls, const char *const *roles, unsigned char N=1)</td></tr>
<tr class="separator:a1eb1d4f245233d5513b53a8a2119e6e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390bb5c6ef8fad7a0ea4b16ccca4cc69" id="r_a390bb5c6ef8fad7a0ea4b16ccca4cc69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a390bb5c6ef8fad7a0ea4b16ccca4cc69">setVal</a> (const char **codes, const char **codeSpaces, unsigned char N=1)</td></tr>
<tr class="separator:a390bb5c6ef8fad7a0ea4b16ccca4cc69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437be1839ccfd239ecd7adea2cb1f1d0" id="r_a437be1839ccfd239ecd7adea2cb1f1d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a437be1839ccfd239ecd7adea2cb1f1d0">setVal</a> (double *measurements, const char **uoms, unsigned char N=1)</td></tr>
<tr class="separator:a437be1839ccfd239ecd7adea2cb1f1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f7c8bc346f532145421955c50b0a0c2" id="r_a7f7c8bc346f532145421955c50b0a0c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f7c8bc346f532145421955c50b0a0c2">setVal</a> (void *ptr)</td></tr>
<tr class="separator:a7f7c8bc346f532145421955c50b0a0c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86c900115842778cbdc849f984fce096" id="r_a86c900115842778cbdc849f984fce096"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a86c900115842778cbdc849f984fce096">setVal</a> (const <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> *ptr, unsigned char N)</td></tr>
<tr class="separator:a86c900115842778cbdc849f984fce096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bd5aaa10646ff59dcd2d94fedbda9b" id="r_a08bd5aaa10646ff59dcd2d94fedbda9b"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08bd5aaa10646ff59dcd2d94fedbda9b">size</a> () const</td></tr>
<tr class="separator:a08bd5aaa10646ff59dcd2d94fedbda9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aedc0ef89b7145df6bca33bad12c43070" name="aedc0ef89b7145df6bca33bad12c43070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc0ef89b7145df6bca33bad12c43070">&#9670;&#160;</a></span>Byte_</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned char <a class="el" href="#aedc0ef89b7145df6bca33bad12c43070">TSLVariant::Byte_</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8afb54fa6e3e20f7a80a7644a8fa129f" name="a8afb54fa6e3e20f7a80a7644a8fa129f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8afb54fa6e3e20f7a80a7644a8fa129f">&#9670;&#160;</a></span>TSLVariant() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TSLVariant::TSLVariant </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<a id="a91de95a59a4df04e38aea2675eef79c8" name="a91de95a59a4df04e38aea2675eef79c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91de95a59a4df04e38aea2675eef79c8">&#9670;&#160;</a></span>TSLVariant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TSLVariant::TSLVariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a id="a61bddbfce7a0eaec3e3e34a5d63e3867" name="a61bddbfce7a0eaec3e3e34a5d63e3867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61bddbfce7a0eaec3e3e34a5d63e3867">&#9670;&#160;</a></span>~TSLVariant()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TSLVariant::~TSLVariant </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor - this will delete any memory it owns (this is always the case where memory is allocated as a result of streaming in). </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abb342329fb0d476d8b3d3c391ab5622d" name="abb342329fb0d476d8b3d3c391ab5622d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb342329fb0d476d8b3d3c391ab5622d">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the object to empty. </p>

</div>
</div>
<a id="a6c8b33c6d1049ba8473f8f62110dcb8d" name="a6c8b33c6d1049ba8473f8f62110dcb8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8b33c6d1049ba8473f8f62110dcb8d">&#9670;&#160;</a></span>compareValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::compareValues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison function. Returns true if the value of the other object is the same as this object. The 'id' fields are ignored. </p>

</div>
</div>
<a id="ac232d877511eb3946b1d030f81ebefaa" name="ac232d877511eb3946b1d030f81ebefaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac232d877511eb3946b1d030f81ebefaa">&#9670;&#160;</a></span>copyVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::copyVal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> *</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> and its type (based on the type of the value).</p>
<p>This copies the value from the specified <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>, without modifying the ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set - only the value is taken over, not the ID. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36d18c2c1bbde32775397dd09e4c7a7c" name="a36d18c2c1bbde32775397dd09e4c7a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36d18c2c1bbde32775397dd09e4c7a7c">&#9670;&#160;</a></span>getID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::getID </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>str</em></span>[3]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method returns the description id (which is a 2 <a class="el" href="#aedc0ef89b7145df6bca33bad12c43070">Byte_</a> element) of the attribute.</p>
<p>The user is responsible for passing a large enough buffer. A minimum of 3 bytes is required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The returned id descriptor, which is NULL terminated. str must point to an array of 3 bytes minimum. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae1884763e3ce1acea1e006f38b36c748" name="ae1884763e3ce1acea1e006f38b36c748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1884763e3ce1acea1e006f38b36c748">&#9670;&#160;</a></span>getStringLen()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getStringLen </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>len</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get length required to hold the value if a string value is held.</p>
<p>If the variant is of type CHAR or NULL or a single STR, returns the size of the string, including null terminator, held by the object, otherwise fails. This is the buffer to allocate and the size to give to getStringVal if the string is not to be truncated.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">len</td><td>Returns the number of characters needed to store the string held in the variant, plus a terminating null. If the string is type NULL the value 1 will be returned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the variant is type CHAR or NULL or STR with size 1, false otherwise. </dd></dl>

</div>
</div>
<a id="a65889b3e476f60249cb142701fad5ebd" name="a65889b3e476f60249cb142701fad5ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65889b3e476f60249cb142701fad5ebd">&#9670;&#160;</a></span>getStringVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getStringVal </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>len</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the value if a string value is held. To obtain the value as a string even if the variant holds a non-string type, use getValueAsString.</p>
<p>The string is truncated if necessary according to the maximum length specified (this is the length of the buffer passed, including space for the null terminator). A suitable value can be obtained by calling getStringLen if the buffer is to be dynamically allocated to avoid truncation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The address of an array of characters, which must be at least as large as the value passed to len. This will receive the string, including a terminating null. If the variant is of type NULL, a single null terminator will be copied.</td></tr>
    <tr><td class="paramname">len</td><td>length of the buffer passed to val. The string written to val will not exceed this length, including null terminator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the variant is type CHAR, NULL, STR, URI or REFERENCE with size 1, false otherwise. </dd></dl>

</div>
</div>
<a id="a53ee76f6033efc7f6aba2374193a1cb6" name="a53ee76f6033efc7f6aba2374193a1cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ee76f6033efc7f6aba2374193a1cb6">&#9670;&#160;</a></span>getTimeVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getTimeVal </td>
          <td>(</td>
          <td class="paramtype">TSLTimeType *</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The address of an array of values to be received from the variant. The array must be at least as large as the size of the variant. If the variant has size 1, it is legal to pass the address of a single variable to receive the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="acab9a6c9480e98f48ddd018a7bf83b75" name="acab9a6c9480e98f48ddd018a7bf83b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab9a6c9480e98f48ddd018a7bf83b75">&#9670;&#160;</a></span>getType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apigroup__common.html#ga446166666f65a13f3de2cf6a35228e02">TSLVariantType</a> TSLVariant::getType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>. </p>

</div>
</div>
<a id="ad646118778d8ae0ba7dbcfa0ec492d8f" name="ad646118778d8ae0ba7dbcfa0ec492d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad646118778d8ae0ba7dbcfa0ec492d8f">&#9670;&#160;</a></span>getVal() <span class="overload">[1/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value returned will be stored in this variable.</td></tr>
    <tr><td class="paramname">index</td><td>The index of the value to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a4ba01e763a1a49fcab87119541fc3e4c" name="a4ba01e763a1a49fcab87119541fc3e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba01e763a1a49fcab87119541fc3e4c">&#9670;&#160;</a></span>getVal() <span class="overload">[2/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The address of an array of values to be received from the variant. The array must be at least as large as the size of the variant. If the variant has size 1, it is legal to pass the address of a single variable to receive the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a180f349032b8dc491a6789342dd4619a" name="a180f349032b8dc491a6789342dd4619a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a180f349032b8dc491a6789342dd4619a">&#9670;&#160;</a></span>getVal() <span class="overload">[3/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<p>NOTE: This overload obtains a string value if the string is less than 255 characters long, and fails if a longer string is held. To cope with arbitrary length strings, use getStringVal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The address of an array of values to be received from the variant. The array must be at least as large as the size of the variant. If the variant has size 1, it is legal to pass the address of a single variable to receive the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a484c8507085882e37a664c84df97b6ac" name="a484c8507085882e37a664c84df97b6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484c8507085882e37a664c84df97b6ac">&#9670;&#160;</a></span>getVal() <span class="overload">[4/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>[]</td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument). This overload is for arrays of strings or when a long string was stored.</p>
<p>NOTE: If accessing a single string it is more convenient to use getStringVal.</p>
<p>NOTE: Pass an array of pointers to this method. The pointers need not be initialised. On return, the pointers will point to strings allocated by the method. THE CALLER MUST DELETE THESE STRINGS AFTER USE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The address of an array of values to be received from the variant. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The array must be at least as large as the size of the variant. UNLIKE the other overloads, if the variant has size 1, it is NOT legal to pass the address of a single variable to receive the value.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="ac9155b561bff9f301928bd1d79ea5305" name="ac9155b561bff9f301928bd1d79ea5305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9155b561bff9f301928bd1d79ea5305">&#9670;&#160;</a></span>getVal() <span class="overload">[5/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<p>Note, the memory returned here is owned by the variant, should not be deleted and may be deleted upon modification of the variant.</p>
<p>For type TSLVariantTypeChar, this returns a single pointer to a null terminated string. For type TSLVariantTypeNull, this returns a single pointer to a zero-length, null terminated string. For type TSLVariantTypeStr, this returns <a class="el" href="#a08bd5aaa10646ff59dcd2d94fedbda9b">size()</a> pointers to null terminated strings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The address of an array of values to be received from the variant. The array must be at least as large as the size of the variant. If the variant has size 1, it is legal to pass the address of a single variable to receive the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="aa4746eb8179ccf54fa0c7753e4318b48" name="aa4746eb8179ccf54fa0c7753e4318b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4746eb8179ccf54fa0c7753e4318b48">&#9670;&#160;</a></span>getVal() <span class="overload">[6/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value returned will be stored in this variable.</td></tr>
    <tr><td class="paramname">index</td><td>The index of the value to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a74969783b4b41e42bd9e1a67ad1123a2" name="a74969783b4b41e42bd9e1a67ad1123a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74969783b4b41e42bd9e1a67ad1123a2">&#9670;&#160;</a></span>getVal() <span class="overload">[7/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>measurements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> *</td>          <td class="paramname"><span class="paramname"><em>uoms</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves an array of Measurement objects which are being stored by the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">measurements</td><td>An array of doubles which will be populated with the measurement values held by the variant.</td></tr>
    <tr><td class="paramname">uoms</td><td>An array of TSLSimpleStrings which will be populated with the uom values held by the variant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a982498500e59d20f6db2260559c3f704" name="a982498500e59d20f6db2260559c3f704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982498500e59d20f6db2260559c3f704">&#9670;&#160;</a></span>getVal() <span class="overload">[8/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The address of an array of values to be received from the variant. The array must be at least as large as the size of the variant. If the variant has size 1, it is legal to pass the address of a single variable to receive the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a43bbc40fe3cb0fc89f88662af9ccb3f7" name="a43bbc40fe3cb0fc89f88662af9ccb3f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43bbc40fe3cb0fc89f88662af9ccb3f7">&#9670;&#160;</a></span>getVal() <span class="overload">[9/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">float &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value returned will be stored in this variable.</td></tr>
    <tr><td class="paramname">index</td><td>The index of the value to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="ab80bbac8d3ef916fd0e60af4cf04bdf0" name="ab80bbac8d3ef916fd0e60af4cf04bdf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80bbac8d3ef916fd0e60af4cf04bdf0">&#9670;&#160;</a></span>getVal() <span class="overload">[10/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">float *</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The address of an array of values to be received from the variant. The array must be at least as large as the size of the variant. If the variant has size 1, it is legal to pass the address of a single variable to receive the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="aba69d31efc81f881be2e95f79c67e349" name="aba69d31efc81f881be2e95f79c67e349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba69d31efc81f881be2e95f79c67e349">&#9670;&#160;</a></span>getVal() <span class="overload">[11/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value returned will be stored in this variable.</td></tr>
    <tr><td class="paramname">index</td><td>The index of the value to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a3feedda08870208b3a22aeb7286dfad4" name="a3feedda08870208b3a22aeb7286dfad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3feedda08870208b3a22aeb7286dfad4">&#9670;&#160;</a></span>getVal() <span class="overload">[12/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The address of an array of values to be received from the variant. The array must be at least as large as the size of the variant. If the variant has size 1, it is legal to pass the address of a single variable to receive the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a26937aeead89cef71fba76608f0c5173" name="a26937aeead89cef71fba76608f0c5173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26937aeead89cef71fba76608f0c5173">&#9670;&#160;</a></span>getVal() <span class="overload">[13/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">short &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value returned will be stored in this variable.</td></tr>
    <tr><td class="paramname">index</td><td>The index of the value to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a03a59b4dff3ee81dcfb7bec63eb75a60" name="a03a59b4dff3ee81dcfb7bec63eb75a60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a59b4dff3ee81dcfb7bec63eb75a60">&#9670;&#160;</a></span>getVal() <span class="overload">[14/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">short *</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The address of an array of values to be received from the variant. The array must be at least as large as the size of the variant. If the variant has size 1, it is legal to pass the address of a single variable to receive the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a853008660bc3cba8b2dd9dfccd6ea6bf" name="a853008660bc3cba8b2dd9dfccd6ea6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a853008660bc3cba8b2dd9dfccd6ea6bf">&#9670;&#160;</a></span>getVal() <span class="overload">[15/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">TSLEntityID &amp;</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value returned will be stored in this variable.</td></tr>
    <tr><td class="paramname">index</td><td>The index of the value to return.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a12556b8882b803e9c4a7f3805c75ff9d" name="a12556b8882b803e9c4a7f3805c75ff9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12556b8882b803e9c4a7f3805c75ff9d">&#9670;&#160;</a></span>getVal() <span class="overload">[16/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">TSLEntityID *</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The address of an array of values to be received from the variant. The array must be at least as large as the size of the variant. If the variant has size 1, it is legal to pass the address of a single variable to receive the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a1e80049e5aa725bc81924164fc880b2b" name="a1e80049e5aa725bc81924164fc880b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e80049e5aa725bc81924164fc880b2b">&#9670;&#160;</a></span>getVal() <span class="overload">[17/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> *</td>          <td class="paramname"><span class="paramname"><em>codes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> *</td>          <td class="paramname"><span class="paramname"><em>codeSpaces</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves an array of Code objects which are being stored by the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codes</td><td>An array of TSLSimpleStrings which will be populated with the code values held by the variant.</td></tr>
    <tr><td class="paramname">codeSpaces</td><td>An array of TSLSimpleStrings which will be populated with the code space values held by the variant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a7a2ee587abd26de9b6fa1b85cc6519e5" name="a7a2ee587abd26de9b6fa1b85cc6519e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2ee587abd26de9b6fa1b85cc6519e5">&#9670;&#160;</a></span>getVal() <span class="overload">[18/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_variant.html">TSLVariant</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The address of an array of values to be received from the variant. The array must be at least as large as the size of the variant. If the variant has size 1, it is legal to pass the address of a single variable to receive the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a5268f6e68415ee7b84bc3bc3f6d8f575" name="a5268f6e68415ee7b84bc3bc3f6d8f575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5268f6e68415ee7b84bc3bc3f6d8f575">&#9670;&#160;</a></span>getVal() <span class="overload">[19/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">unsigned char **</td>          <td class="paramname"><span class="paramname"><em>blobs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>blobLengths</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> *</td>          <td class="paramname"><span class="paramname"><em>mimeTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> *</td>          <td class="paramname"><span class="paramname"><em>urls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> *</td>          <td class="paramname"><span class="paramname"><em>roles</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves an array of Binary objects which are being stored by the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blobs</td><td>An array of arrays of unsigned chars which are big enough to store the corresponding blob held by the variant. To retrieve the length of the blob call the getBlobLen method, specifying the necessary index for the given point in the array.</td></tr>
    <tr><td class="paramname">blobLengths</td><td>An array of lengths which specify the length of the buffer passed to each blob. The value written to blob will not exceed this length.</td></tr>
    <tr><td class="paramname">mimeTypes</td><td>An array of TSLSimpleStrings which will be populated with the mime Types being held by the variant.</td></tr>
    <tr><td class="paramname">urls</td><td>An array of TSLSimpleStrings which will be populated with the URLs being held by the variant.</td></tr>
    <tr><td class="paramname">roles</td><td>An array of TSLSimpleStrings which will be populated with the roles being held by the variant.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="ad2d9996d43b413182a806fd94f4e282b" name="ad2d9996d43b413182a806fd94f4e282b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d9996d43b413182a806fd94f4e282b">&#9670;&#160;</a></span>getVal() <span class="overload">[20/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">unsigned int *</td>          <td class="paramname"><span class="paramname"><em>val</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> (based on the type of the supplied argument).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The address of an array of values to be received from the variant. The array must be at least as large as the size of the variant. If the variant has size 1, it is legal to pass the address of a single variable to receive the value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="af2e5ccbc4939fb220ff3ca5c38539bd2" name="af2e5ccbc4939fb220ff3ca5c38539bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2e5ccbc4939fb220ff3ca5c38539bd2">&#9670;&#160;</a></span>getVal() <span class="overload">[21/21]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::getVal </td>
          <td>(</td>
          <td class="paramtype">void **</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Retrieves a pointer which is being stored by the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>.</p>
<p>Notes:</p>
<ol type="1">
<li>Pointers are not streamed.</li>
<li>What the pointer actually points to is dependent on the context of use. This is primarily used by the Editor SDK.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A pointer to a 'void *'. The actual pointer value will be assigned.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the value type is the same type as the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>; false otherwise. </dd></dl>

</div>
</div>
<a id="a49b63f44efc55d8dbb6a10f24a4e9bc4" name="a49b63f44efc55d8dbb6a10f24a4e9bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b63f44efc55d8dbb6a10f24a4e9bc4">&#9670;&#160;</a></span>getValueAsString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int TSLVariant::getValueAsString </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>len</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>format</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts the contents of the variant to a string using simple formatting.</p>
<p>If you know that the variant always contains a string then use getStringVal / getStringLen instead.</p>
<p>If called with a null str parameter, calculates the size of buffer required to hold the returned value without truncation, including a null terminator. In this case the len parameter is ignored. If called with a nun-null str parameter, the value is formatted into the given buffer. In this case the len parameter specifies the size of the buffer str. The output is truncated if necessary so that the buffer size is not exceeded and it always contains a terminator.</p>
<p>For arrays, all the values are returned, separated by a comma and a space.</p>
<p>The length returned may sometimes be a slight over-estimate of the required length.</p>
<p>Note: This function does not support variants of type BLOB, CODE, MEASUREMENT and VARIANT.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>pass the address of a string to be populated, or pass zero to find the required length.</td></tr>
    <tr><td class="paramname">len</td><td>If str is nonzero, specifies the size of the buffer, limiting the output.</td></tr>
    <tr><td class="paramname">format</td><td>If this is non-zero, specifies the 'printf' style format used. If not specified, uses True/False for booleans, "%d" for integers, "%g" for floats and "%s" for strings. Array entries are separated by ','.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the required length of buffer if str is zero, or the total buffer bytes used if str is non-zero, always including the null terminator. </dd></dl>

</div>
</div>
<a id="a224a48cbfbb1119d68e501db67ae3da3" name="a224a48cbfbb1119d68e501db67ae3da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224a48cbfbb1119d68e501db67ae3da3">&#9670;&#160;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * TSLVariant::id </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>str</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method sets the description id (which is a 2 <a class="el" href="#aedc0ef89b7145df6bca33bad12c43070">Byte_</a> element) of the attribute.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The id descriptor. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2511f52d19d3d8546d2a7dc42a1c8371" name="a2511f52d19d3d8546d2a7dc42a1c8371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2511f52d19d3d8546d2a7dc42a1c8371">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::init </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialises the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> to empty. </p>

</div>
</div>
<a id="aca614b049f70effbabc44b7c9e6a4497" name="aca614b049f70effbabc44b7c9e6a4497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca614b049f70effbabc44b7c9e6a4497">&#9670;&#160;</a></span>isArray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::isArray </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query method.</p>
<p>Returns true if the variant is an array.</p>
<p>Always returns true if a string is held, unless the string is empty in which case it returns false. </p>

</div>
</div>
<a id="acd6c718d74b7ccb86b21cab0c219c39b" name="acd6c718d74b7ccb86b21cab0c219c39b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6c718d74b7ccb86b21cab0c219c39b">&#9670;&#160;</a></span>isExternalReference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::isExternalReference </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets whether this <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> is an external reference This works with all types of variant, although typically used with map Attachments in which case a string is stored. </p>

</div>
</div>
<a id="a7c3503aad1ae17cab6473973fb9d72d8" name="a7c3503aad1ae17cab6473973fb9d72d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c3503aad1ae17cab6473973fb9d72d8">&#9670;&#160;</a></span>isExternalReference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::isExternalReference </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>isExternal</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets whether this <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> is an external reference. This works with all types of variant, although typically used with map Attachments in which case a string is stored. </p>

</div>
</div>
<a id="a21322a1f8bc74c62ca4b2351d6ecc97a" name="a21322a1f8bc74c62ca4b2351d6ecc97a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21322a1f8bc74c62ca4b2351d6ecc97a">&#9670;&#160;</a></span>isNil() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::isNil </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Gets whether this <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> is nil. This works with all types of variant. If true, the current value should not be used </p>

</div>
</div>
<a id="a6052a43b338a343001c4322147b935b6" name="a6052a43b338a343001c4322147b935b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6052a43b338a343001c4322147b935b6">&#9670;&#160;</a></span>isNil() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::isNil </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>nil</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets whether this <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> is nil. This works with all types of variant and does not affect the value current held. </p>

</div>
</div>
<a id="ae498676b2d0d0253904de5d5806ba37d" name="ae498676b2d0d0253904de5d5806ba37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae498676b2d0d0253904de5d5806ba37d">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_variant.html">TSLVariant</a> &amp; TSLVariant::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator. </p>

</div>
</div>
<a id="a0d55e57f4dfbe8b00f2d752efc913a5a" name="a0d55e57f4dfbe8b00f2d752efc913a5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d55e57f4dfbe8b00f2d752efc913a5a">&#9670;&#160;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLVariant::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator. Returns true if both the id and the value of the other object are the same as this object. </p>

</div>
</div>
<a id="a155fb3a2ce105468f16bc65956e03dfe" name="a155fb3a2ce105468f16bc65956e03dfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a155fb3a2ce105468f16bc65956e03dfe">&#9670;&#160;</a></span>setReferenceVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setReferenceVal </td>
          <td>(</td>
          <td class="paramtype">const char *const</td>          <td class="paramname"><span class="paramname"><em>val</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload stores an array of strings. If N is 1 then a single string is stored.</p>
<p>If the value is actually a pointer to an array of elements, the optional parameter must be set to the size of the array.</p>
<p>To retrieve this value at a later stage, use getStringLen and getStringVal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to a (single) variable is treated as a 1-element array. </p>

</div>
</div>
<a id="aa1af15607119cd900aebbf3f4ef27bc1" name="aa1af15607119cd900aebbf3f4ef27bc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1af15607119cd900aebbf3f4ef27bc1">&#9670;&#160;</a></span>setStringVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setStringVal </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>promote</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a string, sets the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> and its type. If the string is empty then the variant will be type NULL. If the string is not empty and is shorter than 255 characters then it will be saved as type CHAR. Otherwise the string will be saved as type STR.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>String to be saved</td></tr>
    <tr><td class="paramname">promote</td><td>If true store the value as a TSLVariantTypeString even if it may be classed as a TSLVariantTypeChar. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a866add001c6c0c08ea213769cc91c73d" name="a866add001c6c0c08ea213769cc91c73d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866add001c6c0c08ea213769cc91c73d">&#9670;&#160;</a></span>setTimeVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setTimeVal </td>
          <td>(</td>
          <td class="paramtype">const TSLTimeType *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> and its type (based on the type of the value).</p>
<p>If the value is actually a pointer to an array of elements, the optional parameter must be set to the size of the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to a (single) variable is treated as a 1-element array. </p>

</div>
</div>
<a id="af37d20d05996e913236d7a71edb2f6bc" name="af37d20d05996e913236d7a71edb2f6bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af37d20d05996e913236d7a71edb2f6bc">&#9670;&#160;</a></span>setURIVal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setURIVal </td>
          <td>(</td>
          <td class="paramtype">const char *const</td>          <td class="paramname"><span class="paramname"><em>val</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload stores an array of strings. If N is 1 then a single string is stored.</p>
<p>If the value is actually a pointer to an array of elements, the optional parameter must be set to the size of the array.</p>
<p>To retrieve this value at a later stage, use getStringLen and getStringVal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to a (single) variable is treated as a 1-element array. </p>

</div>
</div>
<a id="a899347d4eb8a32e80864c1a4a5126727" name="a899347d4eb8a32e80864c1a4a5126727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a899347d4eb8a32e80864c1a4a5126727">&#9670;&#160;</a></span>setVal() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">const bool *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> and its type (based on the type of the value).</p>
<p>If the value is actually a pointer to an array of elements, the optional parameter must be set to the size of the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to a (single) variable is treated as a 1-element array. </p>

</div>
</div>
<a id="a390bb5c6ef8fad7a0ea4b16ccca4cc69" name="a390bb5c6ef8fad7a0ea4b16ccca4cc69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a390bb5c6ef8fad7a0ea4b16ccca4cc69">&#9670;&#160;</a></span>setVal() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>codes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>codeSpaces</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store an array of Code objects in the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">codes</td><td>An array of codes to store.</td></tr>
    <tr><td class="paramname">codeSpaces</td><td>An optional array of code spaces to store.</td></tr>
    <tr><td class="paramname">N</td><td>The number of values in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab620359a04354dff828b45530c77c17d" name="ab620359a04354dff828b45530c77c17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab620359a04354dff828b45530c77c17d">&#9670;&#160;</a></span>setVal() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">const char *const</td>          <td class="paramname"><span class="paramname"><em>val</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload stores an array of strings as type STR. If N is 1 then a single string is stored. The type is always STR regardless of the number or length of the strings.</p>
<p>If the value is actually a pointer to an array of elements, the optional parameter must be set to the size of the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to a (single) variable is treated as a 1-element array. </p>

</div>
</div>
<a id="a7ed337300405ad408e1e9cc9d4e64bd1" name="a7ed337300405ad408e1e9cc9d4e64bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed337300405ad408e1e9cc9d4e64bd1">&#9670;&#160;</a></span>setVal() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This overload internally calls setStringVal. This treats the val parameter as a single null-terminated string. The string is then stored as a NULL type if it was empty, as CHAR type if it has 1 to 254 characters, or as STR type if 255 characters or longer. A null terminator is stored.</p>
<p>Note: The parameter N is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value. </td></tr>
    <tr><td class="paramname">N</td><td>Ignored in this overload. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87bd98d40bcd527001e5e317e32ca68b" name="a87bd98d40bcd527001e5e317e32ca68b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bd98d40bcd527001e5e317e32ca68b">&#9670;&#160;</a></span>setVal() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">const double *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> and its type (based on the type of the value).</p>
<p>If the value is actually a pointer to an array of elements, the optional parameter must be set to the size of the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to a (single) variable is treated as a 1-element array. </p>

</div>
</div>
<a id="ab3098771890458ac3b52212e4a302e47" name="ab3098771890458ac3b52212e4a302e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3098771890458ac3b52212e4a302e47">&#9670;&#160;</a></span>setVal() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">const float *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> and its type (based on the type of the value).</p>
<p>If the value is actually a pointer to an array of elements, the optional parameter must be set to the size of the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to a (single) variable is treated as a 1-element array. </p>

</div>
</div>
<a id="a6c6b95aa70bcd82792f89318595a1594" name="a6c6b95aa70bcd82792f89318595a1594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c6b95aa70bcd82792f89318595a1594">&#9670;&#160;</a></span>setVal() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> and its type (based on the type of the value).</p>
<p>If the value is actually a pointer to an array of elements, the optional parameter must be set to the size of the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to a (single) variable is treated as a 1-element array. </p>

</div>
</div>
<a id="ac8f1055f83d2ab8a9d774f1d26882d8f" name="ac8f1055f83d2ab8a9d774f1d26882d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f1055f83d2ab8a9d774f1d26882d8f">&#9670;&#160;</a></span>setVal() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">const short *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> and its type (based on the type of the value).</p>
<p>If the value is actually a pointer to an array of elements, the optional parameter must be set to the size of the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to a (single) variable is treated as a 1-element array. </p>

</div>
</div>
<a id="a36a1058279687b316fe113569d4f2ae7" name="a36a1058279687b316fe113569d4f2ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36a1058279687b316fe113569d4f2ae7">&#9670;&#160;</a></span>setVal() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">const TSLEntityID *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> and its type (based on the type of the value).</p>
<p>This copies the value from the specified <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>, without modifying the ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set - only the value is taken over, not the ID. </td></tr>
    <tr><td class="paramname">N</td><td>Ignored in this overload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86c900115842778cbdc849f984fce096" name="a86c900115842778cbdc849f984fce096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86c900115842778cbdc849f984fce096">&#9670;&#160;</a></span>setVal() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> and its type (based on the type of the value).</p>
<p>If the value is actually a pointer to an array of elements, the optional parameter must be set to the size of the array.</p>
<p>Note: There are two methods that take a <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>. They have different functionality. This version 'stores' a <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> or an array of <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>'s within this <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>. The other version has been deprecated and replaced with the method copyVal.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The value. </td></tr>
    <tr><td class="paramname">N</td><td>The size of the array.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer to a (single) variable is treated as a 1-element array. </p>

</div>
</div>
<a id="a1eb1d4f245233d5513b53a8a2119e6e9" name="a1eb1d4f245233d5513b53a8a2119e6e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb1d4f245233d5513b53a8a2119e6e9">&#9670;&#160;</a></span>setVal() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *const *</td>          <td class="paramname"><span class="paramname"><em>blobs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>blobLengths</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *</td>          <td class="paramname"><span class="paramname"><em>mimeTypes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *</td>          <td class="paramname"><span class="paramname"><em>urls</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *</td>          <td class="paramname"><span class="paramname"><em>roles</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store an array of Binary objects in the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">blobs</td><td>An array of blobs to store.</td></tr>
    <tr><td class="paramname">blobLengths</td><td>An array of lengths which specify the length of each blob which is being stored.</td></tr>
    <tr><td class="paramname">mimeTypes</td><td>An optional array of mime types to store.</td></tr>
    <tr><td class="paramname">urls</td><td>An optional array of urls to store.</td></tr>
    <tr><td class="paramname">roles</td><td>An optional array of roles to store.</td></tr>
    <tr><td class="paramname">N</td><td>The number of values in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab2baf5eb2eec93f262fae86475fd6d79" name="ab2baf5eb2eec93f262fae86475fd6d79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2baf5eb2eec93f262fae86475fd6d79">&#9670;&#160;</a></span>setVal() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">const unsigned int *</td>          <td class="paramname"><span class="paramname"><em>val</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> and its type (based on the type of the value).</p>
<p>This copies the value from the specified <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>, without modifying the ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">val</td><td>The value to set - only the value is taken over, not the ID. </td></tr>
    <tr><td class="paramname">N</td><td>Ignored in this overload </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a437be1839ccfd239ecd7adea2cb1f1d0" name="a437be1839ccfd239ecd7adea2cb1f1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437be1839ccfd239ecd7adea2cb1f1d0">&#9670;&#160;</a></span>setVal() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>measurements</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>uoms</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>N</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store an array of Measurement objects in the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">measurements</td><td>An array of measurements to store.</td></tr>
    <tr><td class="paramname">uoms</td><td>An optional array of uoms to store.</td></tr>
    <tr><td class="paramname">N</td><td>The number of values in the array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7f7c8bc346f532145421955c50b0a0c2" name="a7f7c8bc346f532145421955c50b0a0c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f7c8bc346f532145421955c50b0a0c2">&#9670;&#160;</a></span>setVal() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TSLVariant::setVal </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the value of the <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> and its type (based on the type of the value).</p>
<p>Notes:</p>
<ol type="1">
<li>Pointers are not streamed.</li>
<li>What the pointer actually points to is dependent on the context of use. This is primarily used by the Editor SDK.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>A 'void *' ptr to set. The <a class="el" href="class_t_s_l_variant.html">TSLVariant</a> does not take ownership. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08bd5aaa10646ff59dcd2d94fedbda9b" name="a08bd5aaa10646ff59dcd2d94fedbda9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08bd5aaa10646ff59dcd2d94fedbda9b">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char TSLVariant::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of array elements that the (pointer) value is referencing. Non-pointer values always return 0. The value returned is confusing if a single string is stored: it may return 1 if the string is longer than 254 characters or if it was stored using the array overload. Use getStringLen to obtain string sizes. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_variant.html">TSLVariant</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.2 | Documentation created Wed Jul 23 2025 17:27:50 | Generated with <a href="http://www.doxygen.org/index.html">Doxygen 1.13.2</a> | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
