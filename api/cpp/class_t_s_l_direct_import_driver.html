<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLDirectImportDriver Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.2</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_direct_import_driver.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_t_s_l_direct_import_driver-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLDirectImportDriver Class Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span><div class="ingroups"><a class="el" href="group__apigroup__maplink__pro__developers__toolkit.html">MapLink Pro Developer Toolkit</a> &raquo; <a class="el" href="group__group__directimport.html">Direct Import API</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A data source driver for the Direct Import SDK</p>
<p>On startup, plugins will be loaded from:</p><ul>
<li>Windows: MapLink Installation/bin(64)/plugins/directimport</li>
<li>Non-windows: MapLink Installation/lib(64)/plugins/directimport</li>
</ul>
<p>A driver plugin library must include a class which inherits from <a class="el" href="class_t_s_l_direct_import_driver.html">TSLDirectImportDriver</a>, and must implement <a class="el" href="#a676a187f5c314d78d502fd2470e7ee46">TSLDirectImportDriver::DriverCreationFunc</a>. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_direct_import_driver_1_1_cancel_callback.html">CancelCallback</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_direct_import_driver_1_1_configuration.html">Configuration</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html">LayerInformation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a67ee4d639052264b899c8814741ab56c" id="r_a67ee4d639052264b899c8814741ab56c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67ee4d639052264b899c8814741ab56c">DataType</a> { <a class="el" href="#a67ee4d639052264b899c8814741ab56ca9a1ceda2298ae67f011e70b1d2683597">DataTypeNone</a> = 0x00
, <a class="el" href="#a67ee4d639052264b899c8814741ab56cad9e1a8a7155f1c4221c9eb927237bd03">DataTypeVector</a> = 0x01
, <a class="el" href="#a67ee4d639052264b899c8814741ab56caa97caeccb351c0bd5a2620cfb5ea2b59">DataTypeRaster</a> = 0x02
, <a class="el" href="#a67ee4d639052264b899c8814741ab56caa88408e9b065ee4e5648478b5cf080fe">DataTypeTerrain</a> = 0x04
 }</td></tr>
<tr class="separator:a67ee4d639052264b899c8814741ab56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47a9ebdce73ec596c6d2c359e855bb0" id="r_ad47a9ebdce73ec596c6d2c359e855bb0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad47a9ebdce73ec596c6d2c359e855bb0">OverviewType</a> { <a class="el" href="#ad47a9ebdce73ec596c6d2c359e855bb0abc70d1044fca850258858747b6f8efc0">OverviewTypeNone</a> = 0x00
, <a class="el" href="#ad47a9ebdce73ec596c6d2c359e855bb0abfcceeed3f1bbcab0969bea371b5ecda">OverviewTypeNative</a> = 0x01
, <a class="el" href="#ad47a9ebdce73ec596c6d2c359e855bb0a2a8210a1df2eb45802672ca1990f5d2a">OverviewTypeGenerated</a> = 0x02
, <a class="el" href="#ad47a9ebdce73ec596c6d2c359e855bb0aac924a5f9ba983e976367be569de2ed7">OverviewTypeAny</a> = 0xFF
 }</td></tr>
<tr class="separator:ad47a9ebdce73ec596c6d2c359e855bb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676a187f5c314d78d502fd2470e7ee46" id="r_a676a187f5c314d78d502fd2470e7ee46"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="class_t_s_l_direct_import_driver.html">TSLDirectImportDriver</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a676a187f5c314d78d502fd2470e7ee46">DriverCreationFunc</a>) ()</td></tr>
<tr class="separator:a676a187f5c314d78d502fd2470e7ee46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a389b6d030a610281b4e3e78e0ee90700" id="r_a389b6d030a610281b4e3e78e0ee90700"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_direct_import_driver_1_1_configuration.html">TSLDirectImportDriver::Configuration</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a389b6d030a610281b4e3e78e0ee90700">configuration</a> ()</td></tr>
<tr class="separator:a389b6d030a610281b4e3e78e0ee90700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ef4ddfa2668862bbccfb137be1bda6d" id="r_a7ef4ddfa2668862bbccfb137be1bda6d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ef4ddfa2668862bbccfb137be1bda6d">supportsThreadedProcessing</a> ()</td></tr>
<tr class="separator:a7ef4ddfa2668862bbccfb137be1bda6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e955a3a461ffcde4e593c3d0a08653f" id="r_a7e955a3a461ffcde4e593c3d0a08653f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_t_s_l_direct_import_driver.html">TSLDirectImportDriver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e955a3a461ffcde4e593c3d0a08653f">clone</a> ()</td></tr>
<tr class="separator:a7e955a3a461ffcde4e593c3d0a08653f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0884d33e344f158d1e8dd8b0b3e0d15" id="r_ad0884d33e344f158d1e8dd8b0b3e0d15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0884d33e344f158d1e8dd8b0b3e0d15">inc</a> ()</td></tr>
<tr class="memdesc:ad0884d33e344f158d1e8dd8b0b3e0d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Increment the driver's reference count.  <br /></td></tr>
<tr class="separator:ad0884d33e344f158d1e8dd8b0b3e0d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68677524145d0d2b35dfb8af3e63df64" id="r_a68677524145d0d2b35dfb8af3e63df64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a68677524145d0d2b35dfb8af3e63df64">dec</a> ()</td></tr>
<tr class="separator:a68677524145d0d2b35dfb8af3e63df64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcad4b92d2a41c61f34a23c3150ef8d6" id="r_adcad4b92d2a41c61f34a23c3150ef8d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcad4b92d2a41c61f34a23c3150ef8d6">lock</a> ()</td></tr>
<tr class="separator:adcad4b92d2a41c61f34a23c3150ef8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a4a2bc6f7c6c1923a273026bdc3c7a" id="r_ad4a4a2bc6f7c6c1923a273026bdc3c7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4a4a2bc6f7c6c1923a273026bdc3c7a">unlock</a> ()</td></tr>
<tr class="memdesc:ad4a4a2bc6f7c6c1923a273026bdc3c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlock the drivers mutex.  <br /></td></tr>
<tr class="separator:ad4a4a2bc6f7c6c1923a273026bdc3c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c8fb0a143d2ee251a301c4ed721b12" id="r_ab1c8fb0a143d2ee251a301c4ed721b12"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a67ee4d639052264b899c8814741ab56c">TSLDirectImportDriver::DataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1c8fb0a143d2ee251a301c4ed721b12">getSupportedDataTypes</a> ()=0</td></tr>
<tr class="separator:ab1c8fb0a143d2ee251a301c4ed721b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac350f106c86b8f4c0dda77b37374e80d" id="r_ac350f106c86b8f4c0dda77b37374e80d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac350f106c86b8f4c0dda77b37374e80d">supportsData</a> (const char *data)=0</td></tr>
<tr class="separator:ac350f106c86b8f4c0dda77b37374e80d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1085675daca8c5e88d0b5f721f7ae098" id="r_a1085675daca8c5e88d0b5f721f7ae098"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1085675daca8c5e88d0b5f721f7ae098">supportedExtensions</a> () const</td></tr>
<tr class="separator:a1085675daca8c5e88d0b5f721f7ae098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40e2b9abf3ccc861589841e8f7439c9" id="r_ad40e2b9abf3ccc861589841e8f7439c9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad40e2b9abf3ccc861589841e8f7439c9">supportsOverviews</a> () const</td></tr>
<tr class="separator:ad40e2b9abf3ccc861589841e8f7439c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731820e501b8d08ea70acd4737f93d0e" id="r_a731820e501b8d08ea70acd4737f93d0e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a731820e501b8d08ea70acd4737f93d0e">usesTMFVector</a> () const</td></tr>
<tr class="separator:a731820e501b8d08ea70acd4737f93d0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0228f13ad356e4f526569db9dcbc022a" id="r_a0228f13ad356e4f526569db9dcbc022a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0228f13ad356e4f526569db9dcbc022a">usesEntityRendering</a> () const</td></tr>
<tr class="separator:a0228f13ad356e4f526569db9dcbc022a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a686bdb6a41a99e98c893147062d3cc32" id="r_a686bdb6a41a99e98c893147062d3cc32"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a686bdb6a41a99e98c893147062d3cc32">analyseData</a> (const char *data)=0</td></tr>
<tr class="separator:a686bdb6a41a99e98c893147062d3cc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e613d12d04b0e5a127e1b6e367c5a77" id="r_a6e613d12d04b0e5a127e1b6e367c5a77"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="#a67ee4d639052264b899c8814741ab56c">TSLDirectImportDriver::DataType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e613d12d04b0e5a127e1b6e367c5a77">getTypeOfData</a> ()=0</td></tr>
<tr class="separator:a6e613d12d04b0e5a127e1b6e367c5a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89ceddb460f263bc464ef1e4429afaa9" id="r_a89ceddb460f263bc464ef1e4429afaa9"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a89ceddb460f263bc464ef1e4429afaa9">numLayers</a> ()=0</td></tr>
<tr class="separator:a89ceddb460f263bc464ef1e4429afaa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a181547e3154e7b14ad722d44dd9fb774" id="r_a181547e3154e7b14ad722d44dd9fb774"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html">TSLDirectImportDriver::LayerInformation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a181547e3154e7b14ad722d44dd9fb774">layerInformation</a> (unsigned int index)=0</td></tr>
<tr class="separator:a181547e3154e7b14ad722d44dd9fb774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c82ed39a86b0ebc7baea4fe1c645ca0" id="r_a9c82ed39a86b0ebc7baea4fe1c645ca0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c82ed39a86b0ebc7baea4fe1c645ca0">createOverviewLayer</a> (unsigned int baseLayerIndex, unsigned int overviewFactor, unsigned int insertAtIndex)</td></tr>
<tr class="separator:a9c82ed39a86b0ebc7baea4fe1c645ca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac680715829cc0ab1058acbd2936ac75a" id="r_ac680715829cc0ab1058acbd2936ac75a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac680715829cc0ab1058acbd2936ac75a">updateLayerExtent</a> (unsigned int index, <a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html">TSLDirectImportDriver::LayerInformation</a> *layerInfo, const <a class="el" href="class_t_s_l_m_u_extent.html">TSLMUExtent</a> &amp;extent)</td></tr>
<tr class="separator:ac680715829cc0ab1058acbd2936ac75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862ead7ccf9b6b0b51a9b4119d08e510" id="r_a862ead7ccf9b6b0b51a9b4119d08e510"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a862ead7ccf9b6b0b51a9b4119d08e510">updateLayerCoordinateSystem</a> (unsigned int index, <a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html">TSLDirectImportDriver::LayerInformation</a> *layerInfo, const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *coordinateSystem)</td></tr>
<tr class="separator:a862ead7ccf9b6b0b51a9b4119d08e510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d07c8a468c4716853607e6cb37d2d8" id="r_aa6d07c8a468c4716853607e6cb37d2d8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6d07c8a468c4716853607e6cb37d2d8">updateLayerScale</a> (unsigned int index, <a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html">TSLDirectImportDriver::LayerInformation</a> *layerInfo, double scale)</td></tr>
<tr class="separator:aa6d07c8a468c4716853607e6cb37d2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae710143adbd3925e86e00b8b482bf967" id="r_ae710143adbd3925e86e00b8b482bf967"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae710143adbd3925e86e00b8b482bf967">getFeatures</a> (<a class="el" href="class_t_s_l_feature_list.html">TSLFeatureList</a> &amp;featureList, unsigned int startLayer, unsigned int endLayer)=0</td></tr>
<tr class="separator:ae710143adbd3925e86e00b8b482bf967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321010e8677ee2adac0a919ff87fa7e4" id="r_a321010e8677ee2adac0a919ff87fa7e4"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a321010e8677ee2adac0a919ff87fa7e4">getRasterChannelStatistics</a> (unsigned int layerIndex, unsigned int channelIndex, <a class="el" href="struct_t_s_l_direct_import_raster_settings_1_1_channel_statistics.html">TSLDirectImportRasterSettings::ChannelStatistics</a> &amp;statistics)</td></tr>
<tr class="separator:a321010e8677ee2adac0a919ff87fa7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928f043a0e3e9a1838180a8d3d2f0219" id="r_a928f043a0e3e9a1838180a8d3d2f0219"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a928f043a0e3e9a1838180a8d3d2f0219">setFeatureConfig</a> (const <a class="el" href="class_t_s_l_feature_class_config.html">TSLFeatureClassConfig</a> *featureConfig)</td></tr>
<tr class="separator:a928f043a0e3e9a1838180a8d3d2f0219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcb4a4ece148c766b123c094ba48428" id="r_abbcb4a4ece148c766b123c094ba48428"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="class_t_s_l_attribute_values.html">TSLAttributeValues</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abbcb4a4ece148c766b123c094ba48428">getAttributeValues</a> (const char *featureName, const char *attributeName, unsigned int startLayer, unsigned int endLayer)=0</td></tr>
<tr class="separator:abbcb4a4ece148c766b123c094ba48428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ce969c13ee052fa4c2848ca0a2cd042" id="r_a0ce969c13ee052fa4c2848ca0a2cd042"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ce969c13ee052fa4c2848ca0a2cd042">preprocess</a> ()</td></tr>
<tr class="separator:a0ce969c13ee052fa4c2848ca0a2cd042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2873ef3f99a7a09dfc11c2ec85f54deb" id="r_a2873ef3f99a7a09dfc11c2ec85f54deb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_t_s_l_m_u_geometry_set.html">TSLMUGeometrySet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2873ef3f99a7a09dfc11c2ec85f54deb">getVector</a> (const <a class="el" href="class_t_s_l_m_u_extent.html">TSLMUExtent</a> &amp;boundingBox, unsigned int startLayer, unsigned int endLayer)</td></tr>
<tr class="separator:a2873ef3f99a7a09dfc11c2ec85f54deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b67c31697b28d4025cebc899bf1c797" id="r_a2b67c31697b28d4025cebc899bf1c797"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_t_s_l_entity_set.html">TSLEntitySet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b67c31697b28d4025cebc899bf1c797">getVectorTMF</a> (const <a class="el" href="class_t_s_l_m_u_extent.html">TSLMUExtent</a> &amp;boundingBox, unsigned int startLayer, unsigned int endLayer)</td></tr>
<tr class="separator:a2b67c31697b28d4025cebc899bf1c797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5563bbd11fe081ced4931dfc4f3e7d8e" id="r_a5563bbd11fe081ced4931dfc4f3e7d8e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_t_s_l_direct_import_raster.html">TSLDirectImportRaster</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5563bbd11fe081ced4931dfc4f3e7d8e">getRaster</a> (const <a class="el" href="class_t_s_l_m_u_extent.html">TSLMUExtent</a> &amp;boundingBox, unsigned int layerIndex)</td></tr>
<tr class="separator:a5563bbd11fe081ced4931dfc4f3e7d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0617f14675d7f9eb3bc410d72694a6d5" id="r_a0617f14675d7f9eb3bc410d72694a6d5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0617f14675d7f9eb3bc410d72694a6d5">setConfig</a> (const <a class="el" href="class_t_s_l_direct_import_driver_1_1_configuration.html">TSLDirectImportDriver::Configuration</a> &amp;config)</td></tr>
<tr class="memdesc:a0617f14675d7f9eb3bc410d72694a6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set The configuration object for this driver instance.  <br /></td></tr>
<tr class="separator:a0617f14675d7f9eb3bc410d72694a6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b9ca4e5dd6b5f66925d6205212d7092" id="r_a7b9ca4e5dd6b5f66925d6205212d7092"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b9ca4e5dd6b5f66925d6205212d7092">name</a> () const =0</td></tr>
<tr class="separator:a7b9ca4e5dd6b5f66925d6205212d7092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268e63ee663b1e808ac1268710dc8809" id="r_a268e63ee663b1e808ac1268710dc8809"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a268e63ee663b1e808ac1268710dc8809">description</a> () const =0</td></tr>
<tr class="memdesc:a268e63ee663b1e808ac1268710dc8809"><td class="mdescLeft">&#160;</td><td class="mdescRight">The human-readable description of the driver.  <br /></td></tr>
<tr class="separator:a268e63ee663b1e808ac1268710dc8809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b72b19db059a107b8ca27647b20fbfb" id="r_a2b72b19db059a107b8ca27647b20fbfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b72b19db059a107b8ca27647b20fbfb">setCancelCallback</a> (<a class="el" href="class_t_s_l_direct_import_driver_1_1_cancel_callback.html">TSLDirectImportDriver::CancelCallback</a> *callback)</td></tr>
<tr class="separator:a2b72b19db059a107b8ca27647b20fbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a210ef29f0220d0a2b5336843743b10bf" id="r_a210ef29f0220d0a2b5336843743b10bf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a210ef29f0220d0a2b5336843743b10bf">TSLDirectImportDriver</a> ()</td></tr>
<tr class="memdesc:a210ef29f0220d0a2b5336843743b10bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a210ef29f0220d0a2b5336843743b10bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dab95b30d03206eb46d5c6df37d3390" id="r_a6dab95b30d03206eb46d5c6df37d3390"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dab95b30d03206eb46d5c6df37d3390">TSLDirectImportDriver</a> (const <a class="el" href="class_t_s_l_direct_import_driver.html">TSLDirectImportDriver</a> &amp;other)</td></tr>
<tr class="memdesc:a6dab95b30d03206eb46d5c6df37d3390"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:a6dab95b30d03206eb46d5c6df37d3390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c853717fd92642be1d3c8fbc3b70e2" id="r_a14c853717fd92642be1d3c8fbc3b70e2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14c853717fd92642be1d3c8fbc3b70e2">~TSLDirectImportDriver</a> ()</td></tr>
<tr class="separator:a14c853717fd92642be1d3c8fbc3b70e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ac750dbdd14acba717d5b9ab020ad439d" id="r_ac750dbdd14acba717d5b9ab020ad439d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_direct_import_driver_1_1_configuration.html">TSLDirectImportDriver::Configuration</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac750dbdd14acba717d5b9ab020ad439d">m_configuration</a></td></tr>
<tr class="separator:ac750dbdd14acba717d5b9ab020ad439d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ce4571d40e41cc03ae34d9789f0c5c" id="r_ac8ce4571d40e41cc03ae34d9789f0c5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_direct_import_driver_1_1_cancel_callback.html">TSLDirectImportDriver::CancelCallback</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac8ce4571d40e41cc03ae34d9789f0c5c">m_cancelCallback</a></td></tr>
<tr class="separator:ac8ce4571d40e41cc03ae34d9789f0c5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a676a187f5c314d78d502fd2470e7ee46" name="a676a187f5c314d78d502fd2470e7ee46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676a187f5c314d78d502fd2470e7ee46">&#9670;&#160;</a></span>DriverCreationFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="class_t_s_l_direct_import_driver.html">TSLDirectImportDriver</a> *(* TSLDirectImportDriver::DriverCreationFunc) ()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each plugin must provide a function with this signature, which creates an instance of the direct import driver class.</p>
<p>This function must be exported from the shared library, and be called 'createTSLDirectImportDriver'.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span></div>
<div class="line">{</div>
<div class="line">  TSLEXAMPLEDRIVERDLL_ <a class="code hl_function" href="#a210ef29f0220d0a2b5336843743b10bf">TSLDirectImportDriver</a>* createTSLDirectImportDriver()</div>
<div class="line">  {</div>
<div class="line">    <span class="keywordflow">return</span> <span class="keyword">new</span> ExampleDirectImportDriver();</div>
<div class="line">  }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_t_s_l_direct_import_driver_html_a210ef29f0220d0a2b5336843743b10bf"><div class="ttname"><a href="#a210ef29f0220d0a2b5336843743b10bf">TSLDirectImportDriver::TSLDirectImportDriver</a></div><div class="ttdeci">TSLDirectImportDriver()</div><div class="ttdoc">Constructor.</div></div>
</div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a67ee4d639052264b899c8814741ab56c" name="a67ee4d639052264b899c8814741ab56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67ee4d639052264b899c8814741ab56c">&#9670;&#160;</a></span>DataType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a67ee4d639052264b899c8814741ab56c">TSLDirectImportDriver::DataType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of a data set</p>
<p>Applications should treat these values as a bitmask. Unless otherwise specified, functions may return a combination of data types.</p>
<ul>
<li>A given data path may contain multiple types of data</li>
<li>A <a class="el" href="class_t_s_l_direct_import_driver.html">TSLDirectImportDriver</a> may support multiple types of data</li>
<li>A <a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a> will contain one type of data. Multiple data sets will be created if data contains multiple data types.</li>
</ul>
<p>If a driver supports more than one type, the values should be combined with a bitwise OR.</p>
<div class="fragment"><div class="line"><a class="code hl_enumeration" href="#a67ee4d639052264b899c8814741ab56c">DataType</a> supportedTypes =</div>
<div class="line"> (<a class="code hl_enumeration" href="#a67ee4d639052264b899c8814741ab56c">DataType</a>) (<a class="code hl_enumvalue" href="#a67ee4d639052264b899c8814741ab56cad9e1a8a7155f1c4221c9eb927237bd03">DataTypeVector</a> | <a class="code hl_enumvalue" href="#a67ee4d639052264b899c8814741ab56caa97caeccb351c0bd5a2620cfb5ea2b59">DataTypeRaster</a> );</div>
<div class="ttc" id="aclass_t_s_l_direct_import_driver_html_a67ee4d639052264b899c8814741ab56c"><div class="ttname"><a href="#a67ee4d639052264b899c8814741ab56c">TSLDirectImportDriver::DataType</a></div><div class="ttdeci">DataType</div><div class="ttdef"><b>Definition</b> tsldirectimportdriver.h:172</div></div>
<div class="ttc" id="aclass_t_s_l_direct_import_driver_html_a67ee4d639052264b899c8814741ab56caa97caeccb351c0bd5a2620cfb5ea2b59"><div class="ttname"><a href="#a67ee4d639052264b899c8814741ab56caa97caeccb351c0bd5a2620cfb5ea2b59">TSLDirectImportDriver::DataTypeRaster</a></div><div class="ttdeci">@ DataTypeRaster</div><div class="ttdoc">Raster data.</div><div class="ttdef"><b>Definition</b> tsldirectimportdriver.h:178</div></div>
<div class="ttc" id="aclass_t_s_l_direct_import_driver_html_a67ee4d639052264b899c8814741ab56cad9e1a8a7155f1c4221c9eb927237bd03"><div class="ttname"><a href="#a67ee4d639052264b899c8814741ab56cad9e1a8a7155f1c4221c9eb927237bd03">TSLDirectImportDriver::DataTypeVector</a></div><div class="ttdeci">@ DataTypeVector</div><div class="ttdoc">Vector data.</div><div class="ttdef"><b>Definition</b> tsldirectimportdriver.h:176</div></div>
</div><!-- fragment --> <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a67ee4d639052264b899c8814741ab56ca9a1ceda2298ae67f011e70b1d2683597" name="a67ee4d639052264b899c8814741ab56ca9a1ceda2298ae67f011e70b1d2683597"></a>DataTypeNone&#160;</td><td class="fielddoc"><p>None. </p>
</td></tr>
<tr><td class="fieldname"><a id="a67ee4d639052264b899c8814741ab56cad9e1a8a7155f1c4221c9eb927237bd03" name="a67ee4d639052264b899c8814741ab56cad9e1a8a7155f1c4221c9eb927237bd03"></a>DataTypeVector&#160;</td><td class="fielddoc"><p>Vector data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a67ee4d639052264b899c8814741ab56caa97caeccb351c0bd5a2620cfb5ea2b59" name="a67ee4d639052264b899c8814741ab56caa97caeccb351c0bd5a2620cfb5ea2b59"></a>DataTypeRaster&#160;</td><td class="fielddoc"><p>Raster data. </p>
</td></tr>
<tr><td class="fieldname"><a id="a67ee4d639052264b899c8814741ab56caa88408e9b065ee4e5648478b5cf080fe" name="a67ee4d639052264b899c8814741ab56caa88408e9b065ee4e5648478b5cf080fe"></a>DataTypeTerrain&#160;</td><td class="fielddoc"><p>Terrain data. </p>
</td></tr>
</table>

</div>
</div>
<a id="ad47a9ebdce73ec596c6d2c359e855bb0" name="ad47a9ebdce73ec596c6d2c359e855bb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47a9ebdce73ec596c6d2c359e855bb0">&#9670;&#160;</a></span>OverviewType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ad47a9ebdce73ec596c6d2c359e855bb0">TSLDirectImportDriver::OverviewType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This enum specifies the type of a raster overview, and is used with <a class="el" href="class_t_s_l_direct_import_data_layer.html#aed4b5b513fd02cc2fe98eb78ad2c4d55">TSLDirectImportDataLayer::createDataSets</a> to specify which overview types should be created.</p>
<p>This enum may be used as a bitmask to specify multiple overview types.</p>
<p>Overview data sets contain the same data as their parent data set, however will be processed and displayed at a lower resolution. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad47a9ebdce73ec596c6d2c359e855bb0abc70d1044fca850258858747b6f8efc0" name="ad47a9ebdce73ec596c6d2c359e855bb0abc70d1044fca850258858747b6f8efc0"></a>OverviewTypeNone&#160;</td><td class="fielddoc"><p>No type/Not an overview data set When creating data sets used to specify that no overviews should be created </p>
</td></tr>
<tr><td class="fieldname"><a id="ad47a9ebdce73ec596c6d2c359e855bb0abfcceeed3f1bbcab0969bea371b5ecda" name="ad47a9ebdce73ec596c6d2c359e855bb0abfcceeed3f1bbcab0969bea371b5ecda"></a>OverviewTypeNative&#160;</td><td class="fielddoc"><p>A Native overview, as found in the source data. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad47a9ebdce73ec596c6d2c359e855bb0a2a8210a1df2eb45802672ca1990f5d2a" name="ad47a9ebdce73ec596c6d2c359e855bb0a2a8210a1df2eb45802672ca1990f5d2a"></a>OverviewTypeGenerated&#160;</td><td class="fielddoc"><p>A Generated overview, created by the <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a> based on the source data. </p>
</td></tr>
<tr><td class="fieldname"><a id="ad47a9ebdce73ec596c6d2c359e855bb0aac924a5f9ba983e976367be569de2ed7" name="ad47a9ebdce73ec596c6d2c359e855bb0aac924a5f9ba983e976367be569de2ed7"></a>OverviewTypeAny&#160;</td><td class="fielddoc"><p>Any overview type. This is a helper bitmask used to request any type of overview from <a class="el" href="class_t_s_l_direct_import_data_layer.html#aed4b5b513fd02cc2fe98eb78ad2c4d55">TSLDirectImportDataLayer::createDataSets</a> </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a210ef29f0220d0a2b5336843743b10bf" name="a210ef29f0220d0a2b5336843743b10bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210ef29f0220d0a2b5336843743b10bf">&#9670;&#160;</a></span>TSLDirectImportDriver() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TSLDirectImportDriver::TSLDirectImportDriver </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>

</div>
</div>
<a id="a6dab95b30d03206eb46d5c6df37d3390" name="a6dab95b30d03206eb46d5c6df37d3390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dab95b30d03206eb46d5c6df37d3390">&#9670;&#160;</a></span>TSLDirectImportDriver() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TSLDirectImportDriver::TSLDirectImportDriver </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_direct_import_driver.html">TSLDirectImportDriver</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="a14c853717fd92642be1d3c8fbc3b70e2" name="a14c853717fd92642be1d3c8fbc3b70e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c853717fd92642be1d3c8fbc3b70e2">&#9670;&#160;</a></span>~TSLDirectImportDriver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TSLDirectImportDriver::~TSLDirectImportDriver </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor</p>
<p>This class is reference counted. To delete it call <a class="el" href="#a68677524145d0d2b35dfb8af3e63df64">TSLDirectImportDriver::dec()</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a686bdb6a41a99e98c893147062d3cc32" name="a686bdb6a41a99e98c893147062d3cc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a686bdb6a41a99e98c893147062d3cc32">&#9670;&#160;</a></span>analyseData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLDirectImportDriver::analyseData </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open the provided data and perform basic analysis.</p>
<p>In this function the driver should determine and store a reference to</p><ul>
<li>The coordinate system of the data</li>
<li>The extent of the data</li>
<li>The scale of the data</li>
</ul>
<p>If the driver cannot determine these parameters the <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a> will ask the application to provide them via <a class="el" href="class_t_s_l_direct_import_data_layer_callbacks.html">TSLDirectImportDataLayerCallbacks</a>. As such if this method returns false the datalayer will not immediately abort loading the data.</p>
<p>This should be a fast analysis. The driver should not read any geometry from the data, or perform any analysis on the features/attributes contained within the data. This should instead be done in getFeatures, getVector or getRaster.</p>
<p>The driver should store a copy of the 'data' parameter Unless specified otherwise all future function calls to the driver will relate to this data path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to analyse. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>false if no analysis could be performed, true otherwise. </dd></dl>

</div>
</div>
<a id="a7e955a3a461ffcde4e593c3d0a08653f" name="a7e955a3a461ffcde4e593c3d0a08653f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e955a3a461ffcde4e593c3d0a08653f">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_t_s_l_direct_import_driver.html">TSLDirectImportDriver</a> * TSLDirectImportDriver::clone </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clone the driver</p>
<p>If a driver supports processing of data in multiple threads, this method must be implemented. It will be used to clone the driver before calling getVector/getRaster from multiple threads.</p>
<p>The created driver must be in the same state as the original. If any load/analyse methods need to be called to setup the state the driver must do so at this point.</p>
<p>If this method is not implemented a single driver instance will be used for each data path. This will greatly increase loading and processing times.</p>
<p><a class="el" href="#adcad4b92d2a41c61f34a23c3150ef8d6">lock()</a> must be called before cloning a driver. </p>

</div>
</div>
<a id="a389b6d030a610281b4e3e78e0ee90700" name="a389b6d030a610281b4e3e78e0ee90700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389b6d030a610281b4e3e78e0ee90700">&#9670;&#160;</a></span>configuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_direct_import_driver_1_1_configuration.html">TSLDirectImportDriver::Configuration</a> &amp; TSLDirectImportDriver::configuration </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the driver's configuration data</p>
<p>This data may be modified in order to set driver-specific options </p><dl class="section return"><dt>Returns</dt><dd>A reference to the driver's configuration data </dd></dl>

</div>
</div>
<a id="a9c82ed39a86b0ebc7baea4fe1c645ca0" name="a9c82ed39a86b0ebc7baea4fe1c645ca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c82ed39a86b0ebc7baea4fe1c645ca0">&#9670;&#160;</a></span>createOverviewLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLDirectImportDriver::createOverviewLayer </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>baseLayerIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>overviewFactor</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>insertAtIndex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a definition for an overview layer</p>
<p>This function will be called by <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a> during basic data analysis if:</p><ul>
<li>Overview datasets have been requested by the application</li>
<li><a class="el" href="#ad40e2b9abf3ccc861589841e8f7439c9">TSLDirectImportDriver::supportsOverviews</a> returned true</li>
<li>No overview layers have been defined by the driver</li>
</ul>
<p>If the driver is able to return data for the given overview settings it should create an additional layer definition. Layer definitions remain up to the driver to define. Future references to this layer will be made by layer index.</p>
<p>If the driver is not able to return data for the given overview settings it must return false.</p>
<p>This function will be called repeatedly until the driver returns false, or the minimum overview size is reached.</p>
<p>Example set of function calls:</p><ul>
<li>Base layer is at index 1. A raster of 1000 x 1000 pixels</li>
<li>createOverviewLayer( 1, 2, 2 ); // Create an overview layer of 500 x 500 pixels, and insert at index 2</li>
<li>createOverviewLayer( 1, 4, 3 ); // Create an overview layer of 250 x 250 pixels, and insert at index 3</li>
</ul>
<p>The driver should not perform any heavy processing in this function. If an overview cannot be defined without processing data at this point the driver cannot support overviews. In this case <a class="el" href="#ad40e2b9abf3ccc861589841e8f7439c9">TSLDirectImportDriver::supportsOverviews</a> must return false, leaving overview creation to the <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseLayerIndex</td><td>The index of the base layer. The created overview layer will be a reduced resolution of this layer. </td></tr>
    <tr><td class="paramname">overviewFactor</td><td>The amount the base layer should be reduced by. This is a power of 2, starting at 2. </td></tr>
    <tr><td class="paramname">insertAtIndex</td><td>The index to insert the overview layer at. Overview layers are always placed largest first, immediately after the base layer definition. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the overview definition was created, false otherwise. </dd></dl>

</div>
</div>
<a id="a68677524145d0d2b35dfb8af3e63df64" name="a68677524145d0d2b35dfb8af3e63df64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68677524145d0d2b35dfb8af3e63df64">&#9670;&#160;</a></span>dec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDriver::dec </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decrement the driver's reference count</p>
<p>If the reference count reaches zero the driver will be deleted </p>

</div>
</div>
<a id="a268e63ee663b1e808ac1268710dc8809" name="a268e63ee663b1e808ac1268710dc8809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268e63ee663b1e808ac1268710dc8809">&#9670;&#160;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * TSLDirectImportDriver::description </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The human-readable description of the driver. </p>

</div>
</div>
<a id="abbcb4a4ece148c766b123c094ba48428" name="abbcb4a4ece148c766b123c094ba48428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbcb4a4ece148c766b123c094ba48428">&#9670;&#160;</a></span>getAttributeValues()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const <a class="el" href="class_t_s_l_attribute_values.html">TSLAttributeValues</a> * TSLDirectImportDriver::getAttributeValues </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>attributeName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>startLayer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>endLayer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the values of an attribute</p>
<p>This function will be called during the import process, in order to perform feature classification.</p>
<p>The results should contain each different value of the specified feature, and the number of times it occurs within the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>The feature to query attributes for. </td></tr>
    <tr><td class="paramname">attributeName</td><td>The attribute to query values for.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The attribute information, including the different values and the number of times each occurs in the data. </dd></dl>

</div>
</div>
<a id="ae710143adbd3925e86e00b8b482bf967" name="ae710143adbd3925e86e00b8b482bf967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae710143adbd3925e86e00b8b482bf967">&#9670;&#160;</a></span>getFeatures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLDirectImportDriver::getFeatures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_feature_list.html">TSLFeatureList</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>featureList</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>startLayer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>endLayer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the list of features and attributes in the data</p>
<p>This function will be called during <a class="el" href="class_t_s_l_direct_import_data_layer.html#a2fdc43169bbab67aea4f9858db64e5b2">TSLDirectImportDataLayer::analyseData</a>. This function will not be called during <a class="el" href="class_t_s_l_direct_import_data_layer.html#a1a96e295488d4c0ac7f397b8154fb762">TSLDirectImportDataLayer::loadData</a>.</p>
<p>The driver must add any features from the data to the provided <a class="el" href="class_t_s_l_feature_list.html">TSLFeatureList</a>. Each feature in the list must contain a list of attribute names. Attribute values are not required from this function.</p>
<p>This function will be called repeatedly if the data contains multiple sub-layers (TSLDirectImportDataSets).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureList</td><td>The feature list to add new features to. </td></tr>
    <tr><td class="paramname">startLayer</td><td>The first layer index to process (inclusive). </td></tr>
    <tr><td class="paramname">endLayer</td><td>The last layer index to process (inclusive). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any features were added, false otherwise. </dd></dl>

</div>
</div>
<a id="a5563bbd11fe081ced4931dfc4f3e7d8e" name="a5563bbd11fe081ced4931dfc4f3e7d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5563bbd11fe081ced4931dfc4f3e7d8e">&#9670;&#160;</a></span>getRaster()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_t_s_l_direct_import_raster.html">TSLDirectImportRaster</a> * TSLDirectImportDriver::getRaster </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_m_u_extent.html">TSLMUExtent</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boundingBox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>layerIndex</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Will be called to read raster data from the driver</p>
<p>The driver should return all raster data which overlaps the boundingBox</p>
<p>In most situations the driver should not perform any processing on the data, however it may perform simple operations such as a rough cull/clip if it will speed up the reading of data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundingBox</td><td>The extent to return data for. </td></tr>
    <tr><td class="paramname">layerIndex</td><td>The layer index to query data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested raster data. Ownership of this object is transferred to the caller. </dd></dl>

</div>
</div>
<a id="a321010e8677ee2adac0a919ff87fa7e4" name="a321010e8677ee2adac0a919ff87fa7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321010e8677ee2adac0a919ff87fa7e4">&#9670;&#160;</a></span>getRasterChannelStatistics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLDirectImportDriver::getRasterChannelStatistics </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>layerIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>channelIndex</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_s_l_direct_import_raster_settings_1_1_channel_statistics.html">TSLDirectImportRasterSettings::ChannelStatistics</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>statistics</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the minimum and maximum values for a raster channel</p>
<p>This function will be called by <a class="el" href="class_t_s_l_direct_import_raster_settings.html#a30b211835f3ca2ebb016a4656e11fc94">TSLDirectImportRasterSettings::calculateChannelStatistics</a> This function will be called after analyseRaster.</p>
<p>The driver does not need to implement this function, or calculate all values supported by <a class="el" href="struct_t_s_l_direct_import_raster_settings_1_1_channel_statistics.html">TSLDirectImportRasterSettings::ChannelStatistics</a>. The behaviour of this calculation will always depend on the driver implementation and data format/product.</p>
<p>If a value is set by the driver it must also set the corresponding validity flag to true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerIndex</td><td>The index of the raster layer </td></tr>
    <tr><td class="paramname">channelIndex</td><td>The channel index within the raster </td></tr>
    <tr><td class="paramname">statistics</td><td>Storage for the calculates statistics </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the values were calculated, false otherwise </dd></dl>

</div>
</div>
<a id="ab1c8fb0a143d2ee251a301c4ed721b12" name="ab1c8fb0a143d2ee251a301c4ed721b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c8fb0a143d2ee251a301c4ed721b12">&#9670;&#160;</a></span>getSupportedDataTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a67ee4d639052264b899c8814741ab56c">TSLDirectImportDriver::DataType</a> TSLDirectImportDriver::getSupportedDataTypes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query which data types this driver can read</p>
<p>If a driver is able to read multiple data types, the values should be combined with a bitwise OR. </p>

</div>
</div>
<a id="a6e613d12d04b0e5a127e1b6e367c5a77" name="a6e613d12d04b0e5a127e1b6e367c5a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e613d12d04b0e5a127e1b6e367c5a77">&#9670;&#160;</a></span>getTypeOfData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="#a67ee4d639052264b899c8814741ab56c">TSLDirectImportDriver::DataType</a> TSLDirectImportDriver::getTypeOfData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the type of the analysed data.</p>
<p>As with getSupportedDataTypes the driver may return a bitmask of data types.</p>
<dl class="section return"><dt>Returns</dt><dd>The type(s) of the analysed data </dd></dl>

</div>
</div>
<a id="a2873ef3f99a7a09dfc11c2ec85f54deb" name="a2873ef3f99a7a09dfc11c2ec85f54deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2873ef3f99a7a09dfc11c2ec85f54deb">&#9670;&#160;</a></span>getVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_t_s_l_m_u_geometry_set.html">TSLMUGeometrySet</a> * TSLDirectImportDriver::getVector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_m_u_extent.html">TSLMUExtent</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boundingBox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>startLayer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>endLayer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Will be called to read vector data from the driver</p>
<p>The driver should process all vector layers between startLayer and endLayer (inclusive). The driver may return vector data from the entire data extent, however should use the provided boundingBox to perform a basic clip operation.</p>
<p>The driver does not need to perform any styling. The driver just needs to extract geometry, feature names, and attribute values. It may use the feature configuration object to mask features/attributes but this is not required.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundingBox</td><td>The extent to return data for. </td></tr>
    <tr><td class="paramname">startLayer</td><td>The first layer index to query data from. </td></tr>
    <tr><td class="paramname">endLayer</td><td>The last layer index to query data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested vector data. Ownership of this object is transferred to the caller. </dd></dl>

</div>
</div>
<a id="a2b67c31697b28d4025cebc899bf1c797" name="a2b67c31697b28d4025cebc899bf1c797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b67c31697b28d4025cebc899bf1c797">&#9670;&#160;</a></span>getVectorTMF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_t_s_l_entity_set.html">TSLEntitySet</a> * TSLDirectImportDriver::getVectorTMF </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_m_u_extent.html">TSLMUExtent</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>boundingBox</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>startLayer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>endLayer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Will be called to read vector data from the driver, if <a class="el" href="#a731820e501b8d08ea70acd4737f93d0e">usesTMFVector()</a> == true</p>
<p>The driver should process all vector layers between startLayer and endLayer (inclusive). The driver may return vector data from the entire data extent, however should use the provided boundingBox to perform a basic clip operation.</p>
<p>The driver does not need to perform any styling, however may return preset entity rendering on the returned entity set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">boundingBox</td><td>The extent to return data for. </td></tr>
    <tr><td class="paramname">startLayer</td><td>The first layer index to query data from. </td></tr>
    <tr><td class="paramname">endLayer</td><td>The last layer index to query data from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested vector data. Ownership of this object is transferred to the caller. </dd></dl>

</div>
</div>
<a id="ad0884d33e344f158d1e8dd8b0b3e0d15" name="ad0884d33e344f158d1e8dd8b0b3e0d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0884d33e344f158d1e8dd8b0b3e0d15">&#9670;&#160;</a></span>inc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDriver::inc </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Increment the driver's reference count. </p>

</div>
</div>
<a id="a181547e3154e7b14ad722d44dd9fb774" name="a181547e3154e7b14ad722d44dd9fb774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a181547e3154e7b14ad722d44dd9fb774">&#9670;&#160;</a></span>layerInformation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html">TSLDirectImportDriver::LayerInformation</a> * TSLDirectImportDriver::layerInformation </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query information about a layer in the analysed data</p>
<p>This function will be called by <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a> during basic data analysis.</p>
<p>For driver-specific data a child class of LayerInfomation should be declared. If the <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a> has to make callbacks in order to determine information about the data the returned LayerInfomation* will be modified.</p>
<p>If the driver uses a separate mechanism for layer management it must preserve the returned object and use its setting during data loading.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the layer to query </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Information about the layer, or NULL on error </dd></dl>

</div>
</div>
<a id="adcad4b92d2a41c61f34a23c3150ef8d6" name="adcad4b92d2a41c61f34a23c3150ef8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcad4b92d2a41c61f34a23c3150ef8d6">&#9670;&#160;</a></span>lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDriver::lock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Lock the driver's mutex</p>
<p>The driver must be locked before cloning. </p>

</div>
</div>
<a id="a7b9ca4e5dd6b5f66925d6205212d7092" name="a7b9ca4e5dd6b5f66925d6205212d7092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b9ca4e5dd6b5f66925d6205212d7092">&#9670;&#160;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * TSLDirectImportDriver::name </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The name of the driver</p>
<p>The returned name will be used to uniquely identify the driver for registration and data processing. As such this function must always return the same value. </p>

</div>
</div>
<a id="a89ceddb460f263bc464ef1e4429afaa9" name="a89ceddb460f263bc464ef1e4429afaa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89ceddb460f263bc464ef1e4429afaa9">&#9670;&#160;</a></span>numLayers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int TSLDirectImportDriver::numLayers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the number of layers in the analysed data</p>
<p>Layers will be processed as separate TSLDirectImportDataSets where needed, however a collection of vector layers without raster between them will be processed as a single data set. </p>

</div>
</div>
<a id="a0ce969c13ee052fa4c2848ca0a2cd042" name="a0ce969c13ee052fa4c2848ca0a2cd042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ce969c13ee052fa4c2848ca0a2cd042">&#9670;&#160;</a></span>preprocess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLDirectImportDriver::preprocess </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform any preprocessing operations on the data before it is read from the driver.</p>
<p>This function will be called during <a class="el" href="class_t_s_l_direct_import_data_layer.html#a1a96e295488d4c0ac7f397b8154fb762">TSLDirectImportDataLayer::loadData</a>.</p>
<p>This function may be overridden in derived classes to perform any preprocessing tasks before the data is read from the driver for processing.</p>
<p>This function will be called on the root driver instance in a single-threaded manner.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the preprocessing was successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a2b72b19db059a107b8ca27647b20fbfb" name="a2b72b19db059a107b8ca27647b20fbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b72b19db059a107b8ca27647b20fbfb">&#9670;&#160;</a></span>setCancelCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDriver::setCancelCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_direct_import_driver_1_1_cancel_callback.html">TSLDirectImportDriver::CancelCallback</a> *</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides a mechanism to allow a job to be cancelled.</p>
<p>The driver should store the value passed and use the value to determine if the current processing should be cancelled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>class instance that implements the cancel() method. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0617f14675d7f9eb3bc410d72694a6d5" name="a0617f14675d7f9eb3bc410d72694a6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0617f14675d7f9eb3bc410d72694a6d5">&#9670;&#160;</a></span>setConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TSLDirectImportDriver::setConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_direct_import_driver_1_1_configuration.html">TSLDirectImportDriver::Configuration</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>config</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set The configuration object for this driver instance. </p>

</div>
</div>
<a id="a928f043a0e3e9a1838180a8d3d2f0219" name="a928f043a0e3e9a1838180a8d3d2f0219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928f043a0e3e9a1838180a8d3d2f0219">&#9670;&#160;</a></span>setFeatureConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TSLDirectImportDriver::setFeatureConfig </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_feature_class_config.html">TSLFeatureClassConfig</a> *</td>          <td class="paramname"><span class="paramname"><em>featureConfig</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the feature/attribute configuration to use when loading data.</p>
<p>This function will be called during <a class="el" href="class_t_s_l_direct_import_data_layer.html#a1a96e295488d4c0ac7f397b8154fb762">TSLDirectImportDataLayer::loadData</a>.</p>
<p>The driver may use this information while loading data, however it is not required to. </p>

</div>
</div>
<a id="a1085675daca8c5e88d0b5f721f7ae098" name="a1085675daca8c5e88d0b5f721f7ae098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1085675daca8c5e88d0b5f721f7ae098">&#9670;&#160;</a></span>supportedExtensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char * TSLDirectImportDriver::supportedExtensions </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the file extension(s) supported by this driver</p>
<p>If multiple file extensions are supported, they should be separated with a semi-colon.</p>
<p>If no extensions are returned, the direct import datalayer will try to use this driver for any extension, and call supportsData for every loaded file.</p>
<div class="fragment"><div class="line"><span class="keywordflow">return</span> <span class="stringliteral">&quot;tif;jpg;jpeg&quot;</span></div>
</div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The file extensions supported by the driver. </dd></dl>

</div>
</div>
<a id="ac350f106c86b8f4c0dda77b37374e80d" name="ac350f106c86b8f4c0dda77b37374e80d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac350f106c86b8f4c0dda77b37374e80d">&#9670;&#160;</a></span>supportsData()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLDirectImportDriver::supportsData </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether a driver supports a data file</p>
<p>The driver should not process the data when this method is called. It should only perform the checks required to test whether the data is supported by the driver.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Path to the data. This may be a file, folder or any other identifier if supportedExtensions returned NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the driver supports the data, false otherwise </dd></dl>

</div>
</div>
<a id="ad40e2b9abf3ccc861589841e8f7439c9" name="ad40e2b9abf3ccc861589841e8f7439c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40e2b9abf3ccc861589841e8f7439c9">&#9670;&#160;</a></span>supportsOverviews()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLDirectImportDriver::supportsOverviews </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether the driver supports overview layers</p>
<p>If overview data sets are supported by the driver it is expected to provide an implementation of <a class="el" href="#a9c82ed39a86b0ebc7baea4fe1c645ca0">TSLDirectImportDriver::createOverviewLayer</a>. The driver will also be expected to handle definitions of overview layers in getRaster.</p>
<p>If overview data sets are not supported by the driver they may still be exposed by <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a> however will be handled by down-sampling the base data set accordingly. In this situation the driver doesn't need any handling of overview data sets in getRaster.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the driver supports overview layers, false otherwise. Default false. </dd></dl>

</div>
</div>
<a id="a7ef4ddfa2668862bbccfb137be1bda6d" name="a7ef4ddfa2668862bbccfb137be1bda6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ef4ddfa2668862bbccfb137be1bda6d">&#9670;&#160;</a></span>supportsThreadedProcessing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLDirectImportDriver::supportsThreadedProcessing </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether a driver supports threaded processing</p>
<p>If this function returns true the driver must be thread safe and must implement <a class="el" href="#a7e955a3a461ffcde4e593c3d0a08653f">TSLDirectImportDriver::clone</a>.</p>
<p>A single driver instance will not be accessed from multiple threads at once, however multiple threads may access a single driver instance sequentially.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the driver supports threaded processing, false otherwise. </dd></dl>

</div>
</div>
<a id="ad4a4a2bc6f7c6c1923a273026bdc3c7a" name="ad4a4a2bc6f7c6c1923a273026bdc3c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a4a2bc6f7c6c1923a273026bdc3c7a">&#9670;&#160;</a></span>unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDriver::unlock </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlock the drivers mutex. </p>

</div>
</div>
<a id="a862ead7ccf9b6b0b51a9b4119d08e510" name="a862ead7ccf9b6b0b51a9b4119d08e510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a862ead7ccf9b6b0b51a9b4119d08e510">&#9670;&#160;</a></span>updateLayerCoordinateSystem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLDirectImportDriver::updateLayerCoordinateSystem </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html">TSLDirectImportDriver::LayerInformation</a> *</td>          <td class="paramname"><span class="paramname"><em>layerInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *</td>          <td class="paramname"><span class="paramname"><em>coordinateSystem</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update layer information with information provided by the application</p>
<p>This function will be called during <a class="el" href="class_t_s_l_direct_import_data_layer.html#aed4b5b513fd02cc2fe98eb78ad2c4d55">TSLDirectImportDataLayer::createDataSets</a>, if a coordinate system was specified by the application</p>
<p>For most drivers the default implementation will suffice, and will simply update the following</p><ul>
<li><a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html#a36f5bf2b6ff356d356ca069e060e5d23" title="The coordinate system of the layer.">LayerInformation.m_coordinateSystem</a></li>
</ul>
<p>If this method is overridden the child driver must set this variable, or call back to the base implementation to do so.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the layer to update. </td></tr>
    <tr><td class="paramname">layerInfo</td><td>The <a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html">LayerInformation</a> to update, as queried from <a class="el" href="#a181547e3154e7b14ad722d44dd9fb774">TSLDirectImportDriver::layerInformation</a>. </td></tr>
    <tr><td class="paramname">coordinateSystem</td><td>The coordinate system as provided by the application. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the coordinate system was set, false otherwise. Returning false will cause this dataset to be discarded. </dd></dl>

</div>
</div>
<a id="ac680715829cc0ab1058acbd2936ac75a" name="ac680715829cc0ab1058acbd2936ac75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac680715829cc0ab1058acbd2936ac75a">&#9670;&#160;</a></span>updateLayerExtent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLDirectImportDriver::updateLayerExtent </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html">TSLDirectImportDriver::LayerInformation</a> *</td>          <td class="paramname"><span class="paramname"><em>layerInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_m_u_extent.html">TSLMUExtent</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update layer information with information provided by the application</p>
<p>This function will be called during <a class="el" href="class_t_s_l_direct_import_data_layer.html#aed4b5b513fd02cc2fe98eb78ad2c4d55">TSLDirectImportDataLayer::createDataSets</a>, if an extent was specified by the application</p>
<p>For most drivers the default implementation will suffice, and will simply update the following</p><ul>
<li><a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html#a2562e699c45716e28be60fd08240ff27" title="The extent of the layer.">LayerInformation.m_extent</a></li>
</ul>
<p>If this method is overridden the child driver must set this variable, or call back to the base implementation to do so.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the layer to update. </td></tr>
    <tr><td class="paramname">layerInfo</td><td>The <a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html">LayerInformation</a> to update, as queried from <a class="el" href="#a181547e3154e7b14ad722d44dd9fb774">TSLDirectImportDriver::layerInformation</a>. </td></tr>
    <tr><td class="paramname">extent</td><td>The extent as provided by the application. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the extent was set, false otherwise. Returning false will cause this dataset to be discarded. </dd></dl>

</div>
</div>
<a id="aa6d07c8a468c4716853607e6cb37d2d8" name="aa6d07c8a468c4716853607e6cb37d2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6d07c8a468c4716853607e6cb37d2d8">&#9670;&#160;</a></span>updateLayerScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLDirectImportDriver::updateLayerScale </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>index</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html">TSLDirectImportDriver::LayerInformation</a> *</td>          <td class="paramname"><span class="paramname"><em>layerInfo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scale</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update layer information with information provided by the application</p>
<p>This function will be called during <a class="el" href="class_t_s_l_direct_import_data_layer.html#aed4b5b513fd02cc2fe98eb78ad2c4d55">TSLDirectImportDataLayer::createDataSets</a>, if a scale was calculated by the data layer</p>
<p>For most drivers the default implementation will suffice, and will simply update the following</p><ul>
<li><a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html#a48e1f6767a4e4f23077cd10e4e607f56">LayerInformation.m_scale</a></li>
</ul>
<p>If this method is overridden the child driver must set this variable, or call back to the base implementation to do so.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the layer to update. </td></tr>
    <tr><td class="paramname">layerInfo</td><td>The <a class="el" href="struct_t_s_l_direct_import_driver_1_1_layer_information.html">LayerInformation</a> to update, as queried from <a class="el" href="#a181547e3154e7b14ad722d44dd9fb774">TSLDirectImportDriver::layerInformation</a>. </td></tr>
    <tr><td class="paramname">scale</td><td>The scale as calculated by the data layer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the scale was set, false otherwise. Returning false will cause this dataset to be discarded. </dd></dl>

</div>
</div>
<a id="a0228f13ad356e4f526569db9dcbc022a" name="a0228f13ad356e4f526569db9dcbc022a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0228f13ad356e4f526569db9dcbc022a">&#9670;&#160;</a></span>usesEntityRendering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLDirectImportDriver::usesEntityRendering </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether the driver returns vector data with pre-set entity rendering</p>
<p>This capability should only be used for compatibility with legacy import mechanisms, or where the driver is unable to support feature rendering. If this capability is used the driver must return vector data as TMF.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the driver uses entity rendering, false otherwise. Default false. </dd></dl>

</div>
</div>
<a id="a731820e501b8d08ea70acd4737f93d0e" name="a731820e501b8d08ea70acd4737f93d0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731820e501b8d08ea70acd4737f93d0e">&#9670;&#160;</a></span>usesTMFVector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLDirectImportDriver::usesTMFVector </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query whether the driver returns vector data as TMF/TSLEntity based classes</p>
<p>This capability should only be used for compatibility with legacy import mechanisms. Wherever possible the driver should return vector data using the default <a class="el" href="class_t_s_l_m_u_geometry.html">TSLMUGeometry</a> hierarchy, which provides a more flexible interface to the <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a>.</p>
<p>If this method returns true the datalayer will call getVectorTMF instead of getVector.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the driver returns data as TMF, false otherwise. Default false. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac8ce4571d40e41cc03ae34d9789f0c5c" name="ac8ce4571d40e41cc03ae34d9789f0c5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ce4571d40e41cc03ae34d9789f0c5c">&#9670;&#160;</a></span>m_cancelCallback</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_direct_import_driver_1_1_cancel_callback.html">TSLDirectImportDriver::CancelCallback</a>* TSLDirectImportDriver::m_cancelCallback</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac750dbdd14acba717d5b9ab020ad439d" name="ac750dbdd14acba717d5b9ab020ad439d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac750dbdd14acba717d5b9ab020ad439d">&#9670;&#160;</a></span>m_configuration</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_direct_import_driver_1_1_configuration.html">TSLDirectImportDriver::Configuration</a> TSLDirectImportDriver::m_configuration</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_direct_import_driver.html">TSLDirectImportDriver</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.2 | Documentation created Wed Jul 23 2025 18:22:38 | Generated with <a href="http://www.doxygen.org/index.html">Doxygen 1.13.2</a> | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
