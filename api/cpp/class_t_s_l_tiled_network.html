<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLTiledNetwork Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.2</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_tiled_network.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_t_s_l_tiled_network-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLTiledNetwork Class Reference<div class="ingroups"><a class="el" href="group__group__networksdk.html">MapLink Network API</a> &raquo; <a class="el" href="group__group__networksdk__tilednetwork.html">Tiled Network</a></div></div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae6611b129eb1478984cda2476ee39692" id="r_ae6611b129eb1478984cda2476ee39692"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae6611b129eb1478984cda2476ee39692">find_type</a> { <a class="el" href="#ae6611b129eb1478984cda2476ee39692a9120c18b9b918ba9ed20271a02ccebff">tsl_nwk_find_both</a> = 0
, <a class="el" href="#ae6611b129eb1478984cda2476ee39692af54fbb68204f94053b826db0c5425bf8">tsl_nwk_find_links</a> = 1
, <a class="el" href="#ae6611b129eb1478984cda2476ee39692a200b69e24bac781372fa8ac72607fb86">tsl_nwk_find_nodes</a> = 2
 }</td></tr>
<tr class="separator:ae6611b129eb1478984cda2476ee39692"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7ac27049bf53b66fc4664107b77b4a12" id="r_a7ac27049bf53b66fc4664107b77b4a12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7ac27049bf53b66fc4664107b77b4a12">addPath</a> (const char *dir_name)</td></tr>
<tr class="separator:a7ac27049bf53b66fc4664107b77b4a12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac161bd8d6e3b502ce216f6a6a7483d95" id="r_ac161bd8d6e3b502ce216f6a6a7483d95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac161bd8d6e3b502ce216f6a6a7483d95">begin_links</a> (const <a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> &amp;it)</td></tr>
<tr class="separator:ac161bd8d6e3b502ce216f6a6a7483d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf43dd12d6e65b12c152d9c5634b5fa5" id="r_abf43dd12d6e65b12c152d9c5634b5fa5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf43dd12d6e65b12c152d9c5634b5fa5">begin_links</a> (long node_id)</td></tr>
<tr class="separator:abf43dd12d6e65b12c152d9c5634b5fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac45979ce28b7b87b2d81fedfb08ef36d" id="r_ac45979ce28b7b87b2d81fedfb08ef36d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac45979ce28b7b87b2d81fedfb08ef36d">begin_turns</a> (long node_id)</td></tr>
<tr class="separator:ac45979ce28b7b87b2d81fedfb08ef36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ccb6662d05377d272dd9c4bd6d6e68" id="r_ac0ccb6662d05377d272dd9c4bd6d6e68"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0ccb6662d05377d272dd9c4bd6d6e68">begin_turns</a> (const <a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> &amp;it)</td></tr>
<tr class="separator:ac0ccb6662d05377d272dd9c4bd6d6e68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cee22ac2f745c473bb9a1f7c1cd98a" id="r_af6cee22ac2f745c473bb9a1f7c1cd98a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6cee22ac2f745c473bb9a1f7c1cd98a">cacheSize</a> (long new_size)</td></tr>
<tr class="separator:af6cee22ac2f745c473bb9a1f7c1cd98a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ee0eb45355c622d194e1c4b1a0502c" id="r_a64ee0eb45355c622d194e1c4b1a0502c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64ee0eb45355c622d194e1c4b1a0502c">cacheFlushLimit</a> (long flush_limit)</td></tr>
<tr class="separator:a64ee0eb45355c622d194e1c4b1a0502c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dec1204448f635785e8db5a0421f88b" id="r_a2dec1204448f635785e8db5a0421f88b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2dec1204448f635785e8db5a0421f88b">clearCache</a> ()</td></tr>
<tr class="separator:a2dec1204448f635785e8db5a0421f88b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2fdb1ae20ad3e6edcbf46585516ad3" id="r_aea2fdb1ae20ad3e6edcbf46585516ad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aea2fdb1ae20ad3e6edcbf46585516ad3">end_links</a> (long node_id)</td></tr>
<tr class="separator:aea2fdb1ae20ad3e6edcbf46585516ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0c9db88a3bcf66c03dec4db339ddb5" id="r_afc0c9db88a3bcf66c03dec4db339ddb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc0c9db88a3bcf66c03dec4db339ddb5">end_links</a> (const <a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> &amp;it)</td></tr>
<tr class="separator:afc0c9db88a3bcf66c03dec4db339ddb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9303c515743e7d6feb822763038cde15" id="r_a9303c515743e7d6feb822763038cde15"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9303c515743e7d6feb822763038cde15">end_turns</a> (long node_id)</td></tr>
<tr class="separator:a9303c515743e7d6feb822763038cde15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4549f0e6d3aaa04e5294a5d46a9fac75" id="r_a4549f0e6d3aaa04e5294a5d46a9fac75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4549f0e6d3aaa04e5294a5d46a9fac75">end_turns</a> (const <a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> &amp;it)</td></tr>
<tr class="separator:a4549f0e6d3aaa04e5294a5d46a9fac75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527cdc1c9a2047a8885a9ae0d11d2309" id="r_a527cdc1c9a2047a8885a9ae0d11d2309"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_query.html">TSLNetworkQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a527cdc1c9a2047a8885a9ae0d11d2309">find</a> (const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> *extent, const <a class="el" href="class_t_s_l_nwk_selector.html">TSLNwkSelector</a> &amp;filter, <a class="el" href="#ae6611b129eb1478984cda2476ee39692">TSLTiledNetwork::find_type</a> filter_mode=<a class="el" href="#ae6611b129eb1478984cda2476ee39692a9120c18b9b918ba9ed20271a02ccebff">TSLTiledNetwork::tsl_nwk_find_both</a>)</td></tr>
<tr class="separator:a527cdc1c9a2047a8885a9ae0d11d2309"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553259d101ab5f327ace83f842e6bd5d" id="r_a553259d101ab5f327ace83f842e6bd5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a553259d101ab5f327ace83f842e6bd5d">find_link</a> (const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;location, Long aperture)</td></tr>
<tr class="separator:a553259d101ab5f327ace83f842e6bd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262c85325f5e714c24295c55754f8355" id="r_a262c85325f5e714c24295c55754f8355"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a262c85325f5e714c24295c55754f8355">find_node</a> (const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;location, Long aperture)</td></tr>
<tr class="separator:a262c85325f5e714c24295c55754f8355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e240877c5afbb3cdba305e3d72d7cf" id="r_a07e240877c5afbb3cdba305e3d72d7cf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07e240877c5afbb3cdba305e3d72d7cf">get_link</a> (long link_id)</td></tr>
<tr class="separator:a07e240877c5afbb3cdba305e3d72d7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b2bd2c9b74f0902efd1c4788859091c" id="r_a9b2bd2c9b74f0902efd1c4788859091c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b2bd2c9b74f0902efd1c4788859091c">get_node</a> (long node_id)</td></tr>
<tr class="separator:a9b2bd2c9b74f0902efd1c4788859091c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd30409710541babddfe521d8e85e7ed" id="r_abd30409710541babddfe521d8e85e7ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd30409710541babddfe521d8e85e7ed">get_turn</a> (long turn_id)</td></tr>
<tr class="separator:abd30409710541babddfe521d8e85e7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645d4a47d46465d574b56b6087b4ff30" id="r_a645d4a47d46465d574b56b6087b4ff30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a645d4a47d46465d574b56b6087b4ff30">linkDestinNode</a> (const <a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> &amp;it)</td></tr>
<tr class="separator:a645d4a47d46465d574b56b6087b4ff30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7c32da3801de2a31dbf9a280f9c09e" id="r_ada7c32da3801de2a31dbf9a280f9c09e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ada7c32da3801de2a31dbf9a280f9c09e">linkSourceNode</a> (const <a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> &amp;it)</td></tr>
<tr class="separator:ada7c32da3801de2a31dbf9a280f9c09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d7f51769697afa03193e2222004c4b9" id="r_a9d7f51769697afa03193e2222004c4b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d7f51769697afa03193e2222004c4b9">loadData</a> (const char *filename)</td></tr>
<tr class="separator:a9d7f51769697afa03193e2222004c4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a651e5aa8a6487e16989b8db7c8828ca5" id="r_a651e5aa8a6487e16989b8db7c8828ca5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a651e5aa8a6487e16989b8db7c8828ca5">lockQuery</a> (const <a class="el" href="class_t_s_l_network_query.html">TSLNetworkQuery</a> &amp;query, bool *all_loaded=0)</td></tr>
<tr class="separator:a651e5aa8a6487e16989b8db7c8828ca5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2463b5377a290e00fb9b6f8160171043" id="r_a2463b5377a290e00fb9b6f8160171043"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2463b5377a290e00fb9b6f8160171043">lockQuery</a> (const <a class="el" href="class_t_s_l_route_query.html">TSLRouteQuery</a> &amp;query, bool *all_loaded=0)</td></tr>
<tr class="separator:a2463b5377a290e00fb9b6f8160171043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c50bcc4087afdd95f9d715efc3fce6f" id="r_a1c50bcc4087afdd95f9d715efc3fce6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c50bcc4087afdd95f9d715efc3fce6f">lockRegion</a> (const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent, bool *all_loaded=0)</td></tr>
<tr class="separator:a1c50bcc4087afdd95f9d715efc3fce6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c91b27f008bbf3a318b881200df96d" id="r_a94c91b27f008bbf3a318b881200df96d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94c91b27f008bbf3a318b881200df96d">lockRegion</a> (const <a class="el" href="class_t_s_l_polyline.html">TSLPolyline</a> &amp;polyline, bool *all_loaded=0)</td></tr>
<tr class="separator:a94c91b27f008bbf3a318b881200df96d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b53ca843163933b27eafe8dbce80c0" id="r_aa0b53ca843163933b27eafe8dbce80c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0b53ca843163933b27eafe8dbce80c0">removeData</a> ()</td></tr>
<tr class="separator:aa0b53ca843163933b27eafe8dbce80c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca88cf160eefb85605786a4fc8b4554a" id="r_aca88cf160eefb85605786a4fc8b4554a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_route_query.html">TSLRouteQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca88cf160eefb85605786a4fc8b4554a">route</a> (long from_node, long to_node, long *via_nodes, long via_count, <a class="el" href="struct_t_s_l_path_cost.html">TSLPathCost</a> &amp;cost, double max_cost)</td></tr>
<tr class="separator:aca88cf160eefb85605786a4fc8b4554a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f4a2be58a1ca2eeaf7ae05e8ad9b9b" id="r_a38f4a2be58a1ca2eeaf7ae05e8ad9b9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a38f4a2be58a1ca2eeaf7ae05e8ad9b9b">turnDestinLink</a> (const <a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> &amp;it)</td></tr>
<tr class="separator:a38f4a2be58a1ca2eeaf7ae05e8ad9b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a649f0cb7dd40ccaf068b282076691" id="r_af8a649f0cb7dd40ccaf068b282076691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8a649f0cb7dd40ccaf068b282076691">turnSourceLink</a> (const <a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> &amp;it)</td></tr>
<tr class="separator:af8a649f0cb7dd40ccaf068b282076691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8483dcedb9ad0f31bb7384468dc6316e" id="r_a8483dcedb9ad0f31bb7384468dc6316e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8483dcedb9ad0f31bb7384468dc6316e">unlockAll</a> ()</td></tr>
<tr class="separator:a8483dcedb9ad0f31bb7384468dc6316e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834eb8c3b31e02dd6caa9e7629c92cc8" id="r_a834eb8c3b31e02dd6caa9e7629c92cc8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a834eb8c3b31e02dd6caa9e7629c92cc8">unlockQuery</a> (const <a class="el" href="class_t_s_l_network_query.html">TSLNetworkQuery</a> &amp;query)</td></tr>
<tr class="separator:a834eb8c3b31e02dd6caa9e7629c92cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab60e9d7fd57ceaa9edac6ca1283592f7" id="r_ab60e9d7fd57ceaa9edac6ca1283592f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab60e9d7fd57ceaa9edac6ca1283592f7">unlockQuery</a> (const <a class="el" href="class_t_s_l_route_query.html">TSLRouteQuery</a> &amp;query)</td></tr>
<tr class="separator:ab60e9d7fd57ceaa9edac6ca1283592f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1046335b075f46587a7a130dac568066" id="r_a1046335b075f46587a7a130dac568066"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1046335b075f46587a7a130dac568066">unlockRegion</a> (const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent)</td></tr>
<tr class="separator:a1046335b075f46587a7a130dac568066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8730aef1fa9d6cd63735319f2e04fdbf" id="r_a8730aef1fa9d6cd63735319f2e04fdbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8730aef1fa9d6cd63735319f2e04fdbf">unlockRegion</a> (const <a class="el" href="class_t_s_l_polyline.html">TSLPolyline</a> &amp;polyline)</td></tr>
<tr class="separator:a8730aef1fa9d6cd63735319f2e04fdbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a067812613acfda523a74733d14f0a256" id="r_a067812613acfda523a74733d14f0a256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a067812613acfda523a74733d14f0a256">destroy</a> ()</td></tr>
<tr class="separator:a067812613acfda523a74733d14f0a256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834b852635f60379236470693f7c40a2" id="r_a834b852635f60379236470693f7c40a2"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a834b852635f60379236470693f7c40a2">operator new</a> (size_t size)</td></tr>
<tr class="separator:a834b852635f60379236470693f7c40a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a496cdc4ebfe52a21656265ddb4ae9169" id="r_a496cdc4ebfe52a21656265ddb4ae9169"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a496cdc4ebfe52a21656265ddb4ae9169">operator new</a> (size_t size, char *filename, int line)</td></tr>
<tr class="separator:a496cdc4ebfe52a21656265ddb4ae9169"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ae6611b129eb1478984cda2476ee39692" name="ae6611b129eb1478984cda2476ee39692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6611b129eb1478984cda2476ee39692">&#9670;&#160;</a></span>find_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ae6611b129eb1478984cda2476ee39692">TSLTiledNetwork::find_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae6611b129eb1478984cda2476ee39692a9120c18b9b918ba9ed20271a02ccebff" name="ae6611b129eb1478984cda2476ee39692a9120c18b9b918ba9ed20271a02ccebff"></a>tsl_nwk_find_both&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae6611b129eb1478984cda2476ee39692af54fbb68204f94053b826db0c5425bf8" name="ae6611b129eb1478984cda2476ee39692af54fbb68204f94053b826db0c5425bf8"></a>tsl_nwk_find_links&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae6611b129eb1478984cda2476ee39692a200b69e24bac781372fa8ac72607fb86" name="ae6611b129eb1478984cda2476ee39692a200b69e24bac781372fa8ac72607fb86"></a>tsl_nwk_find_nodes&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7ac27049bf53b66fc4664107b77b4a12" name="a7ac27049bf53b66fc4664107b77b4a12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac27049bf53b66fc4664107b77b4a12">&#9670;&#160;</a></span>addPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLTiledNetwork::addPath </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dir_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a directory path to the pathlist to search for individual tiles. By default the <a class="el" href="class_t_s_l_tiled_network.html">TSLTiledNetwork</a> will search for tiles in the same directory as the TiledNetwork file. If Network tiles are located in other directories it will be necessary to inform the <a class="el" href="class_t_s_l_tiled_network.html">TSLTiledNetwork</a> of where the tiles can be located.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dir_name</td><td>name of the directory to add to the search path.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the dir_name was successfully added , false if the dir_name already exists in the search path. </dd></dl>

</div>
</div>
<a id="ac161bd8d6e3b502ce216f6a6a7483d95" name="ac161bd8d6e3b502ce216f6a6a7483d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac161bd8d6e3b502ce216f6a6a7483d95">&#9670;&#160;</a></span>begin_links() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> TSLTiledNetwork::begin_links </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> into the global links list associated with the given node iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> to obtain the links for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> referring to the first outgoing link from the specified node. </dd></dl>

</div>
</div>
<a id="abf43dd12d6e65b12c152d9c5634b5fa5" name="abf43dd12d6e65b12c152d9c5634b5fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf43dd12d6e65b12c152d9c5634b5fa5">&#9670;&#160;</a></span>begin_links() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> TSLTiledNetwork::begin_links </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>node_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> into the global links list associated with the given node id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>global id of the node to obtain the links for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> referring to the first outgoing link from the specified node. </dd></dl>

</div>
</div>
<a id="ac0ccb6662d05377d272dd9c4bd6d6e68" name="ac0ccb6662d05377d272dd9c4bd6d6e68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ccb6662d05377d272dd9c4bd6d6e68">&#9670;&#160;</a></span>begin_turns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> TSLTiledNetwork::begin_turns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> into the global turns list associated with the given node id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> to obtain the turns for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> referring to the first turn from the specified node. </dd></dl>

</div>
</div>
<a id="ac45979ce28b7b87b2d81fedfb08ef36d" name="ac45979ce28b7b87b2d81fedfb08ef36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac45979ce28b7b87b2d81fedfb08ef36d">&#9670;&#160;</a></span>begin_turns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> TSLTiledNetwork::begin_turns </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>node_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> into the global turns list associated with the given node id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>global id for the node to obtain the turns for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> referring to the first turn from the specified node. </dd></dl>

</div>
</div>
<a id="a64ee0eb45355c622d194e1c4b1a0502c" name="a64ee0eb45355c622d194e1c4b1a0502c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ee0eb45355c622d194e1c4b1a0502c">&#9670;&#160;</a></span>cacheFlushLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLTiledNetwork::cacheFlushLimit </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>flush_limit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method allows the user to set the cache flush limit for the TSLTiled Network. When the cache is full the system will remove the LEAST recently used files to make room for the new data to load. The cache flush limit indicates the number of MOST recently used data files that the system will try keep in memory while flushing the cache. If the system cannot free enough memory and keep the flush limit number of files it will temporarily halve the flush limit until the cache memory usage is below 90% of the allowable cache size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flush_limit</td><td>the number of files to (attempt to ) keep when flushing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="af6cee22ac2f745c473bb9a1f7c1cd98a" name="af6cee22ac2f745c473bb9a1f7c1cd98a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6cee22ac2f745c473bb9a1f7c1cd98a">&#9670;&#160;</a></span>cacheSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLTiledNetwork::cacheSize </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>new_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method allows the user to set the total filesize that the tile cache can use. The default tile cache is 20Mb</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>The size in kilobytes for the cache to hold.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a2dec1204448f635785e8db5a0421f88b" name="a2dec1204448f635785e8db5a0421f88b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dec1204448f635785e8db5a0421f88b">&#9670;&#160;</a></span>clearCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLTiledNetwork::clearCache </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method requests the <a class="el" href="class_t_s_l_tiled_network.html">TSLTiledNetwork</a> to clear all cached data from memory. After a call to clearCache any operations involving the TSLTiled Network will re-load all required data from disk. This will not clear any locked tiles from memory.</p>
<dl class="section return"><dt>Returns</dt><dd>True if the cache was flushed or is already empty, false otherwise. </dd></dl>

</div>
</div>
<a id="a067812613acfda523a74733d14f0a256" name="a067812613acfda523a74733d14f0a256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a067812613acfda523a74733d14f0a256">&#9670;&#160;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLTiledNetwork::destroy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor for the object </p>

</div>
</div>
<a id="afc0c9db88a3bcf66c03dec4db339ddb5" name="afc0c9db88a3bcf66c03dec4db339ddb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0c9db88a3bcf66c03dec4db339ddb5">&#9670;&#160;</a></span>end_links() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> TSLTiledNetwork::end_links </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> to the last link of the global links list associated with the given node id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> to the node to obtain the links for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> to one past the last outgoing link of the specified node </dd></dl>

</div>
</div>
<a id="aea2fdb1ae20ad3e6edcbf46585516ad3" name="aea2fdb1ae20ad3e6edcbf46585516ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2fdb1ae20ad3e6edcbf46585516ad3">&#9670;&#160;</a></span>end_links() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> TSLTiledNetwork::end_links </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>node_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> to the last link of the global links list associated with the given node id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>global id of the node to obtain the links for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> to one past the last outgoing link of the specified node </dd></dl>

</div>
</div>
<a id="a4549f0e6d3aaa04e5294a5d46a9fac75" name="a4549f0e6d3aaa04e5294a5d46a9fac75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4549f0e6d3aaa04e5294a5d46a9fac75">&#9670;&#160;</a></span>end_turns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> TSLTiledNetwork::end_turns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> to the last turn of the global turns list associated with the given node iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> to the node to obtain the turns for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> to one past the last turn of the specified node </dd></dl>

</div>
</div>
<a id="a9303c515743e7d6feb822763038cde15" name="a9303c515743e7d6feb822763038cde15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9303c515743e7d6feb822763038cde15">&#9670;&#160;</a></span>end_turns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> TSLTiledNetwork::end_turns </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>node_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> to the last turn of the global turns list associated with the given node id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>global id of the node to obtain the turns for</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> to one past the last turn of the specified node </dd></dl>

</div>
</div>
<a id="a527cdc1c9a2047a8885a9ae0d11d2309" name="a527cdc1c9a2047a8885a9ae0d11d2309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527cdc1c9a2047a8885a9ae0d11d2309">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_query.html">TSLNetworkQuery</a> * TSLTiledNetwork::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> *</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_nwk_selector.html">TSLNwkSelector</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#ae6611b129eb1478984cda2476ee39692">TSLTiledNetwork::find_type</a></td>          <td class="paramname"><span class="paramname"><em>filter_mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#ae6611b129eb1478984cda2476ee39692a9120c18b9b918ba9ed20271a02ccebff">TSLTiledNetwork::tsl_nwk_find_both</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will generate a TSLNetworkQueryObject which will contain read-only copies of all links and nodes which satisfy the criteria specified by the filter object. Note: the simplest filter object will return everything that is sent to it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>region to query. specifying a very large region may take some time.</td></tr>
    <tr><td class="paramname">filter</td><td>reference to a TSLNetworkSelector object whose methods will be called by the <a class="el" href="class_t_s_l_tiled_network.html">TSLTiledNetwork</a> for any link and/or node which is within the specified extent.</td></tr>
    <tr><td class="paramname">filter_mode</td><td>any of TSLTiledNetwork::find_both TSLTileNetwork::find_links TSLTileNetwork::find_nodes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TSLNetworkQueryObject which contains copies of all link and/or nodes which satisfy the criteria defined by the filter. </dd></dl>

</div>
</div>
<a id="a553259d101ab5f327ace83f842e6bd5d" name="a553259d101ab5f327ace83f842e6bd5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553259d101ab5f327ace83f842e6bd5d">&#9670;&#160;</a></span>find_link()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> TSLTiledNetwork::find_link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>location</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long</td>          <td class="paramname"><span class="paramname"><em>aperture</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the nearest link based on location and aperture</p>
<p>Note complex searches ( e.g. based on attributes) can be achieved by the find routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>centre point of area to search </td></tr>
    <tr><td class="paramname">aperture</td><td>distance from the centre point to search</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> that refers to the link that was found. If no link was found the <a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> will refer to a dummy link. </dd></dl>

</div>
</div>
<a id="a262c85325f5e714c24295c55754f8355" name="a262c85325f5e714c24295c55754f8355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262c85325f5e714c24295c55754f8355">&#9670;&#160;</a></span>find_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> TSLTiledNetwork::find_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>location</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Long</td>          <td class="paramname"><span class="paramname"><em>aperture</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the nearest node based on a location and aperture.</p>
<p>Note complex searches ( e.g. based on attributes) can be achieved by the find routine.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>centre point of area to search </td></tr>
    <tr><td class="paramname">aperture</td><td>distance from the centre point to search</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> that refers to the node that was found. If no node was found the node iterator will refer to a dummy node. </dd></dl>

</div>
</div>
<a id="a07e240877c5afbb3cdba305e3d72d7cf" name="a07e240877c5afbb3cdba305e3d72d7cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e240877c5afbb3cdba305e3d72d7cf">&#9670;&#160;</a></span>get_link()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> TSLTiledNetwork::get_link </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>link_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a link iterator based on the global ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_id</td><td>global id for the link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> that refers to the link that was found. If no link was found the <a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> will refer to a dummy link. </dd></dl>

</div>
</div>
<a id="a9b2bd2c9b74f0902efd1c4788859091c" name="a9b2bd2c9b74f0902efd1c4788859091c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b2bd2c9b74f0902efd1c4788859091c">&#9670;&#160;</a></span>get_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> TSLTiledNetwork::get_node </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>node_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> based on the global ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_id</td><td>global id for the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> that refers to the node that was found. If no node was found the <a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> will refer to a dummy node. </dd></dl>

</div>
</div>
<a id="abd30409710541babddfe521d8e85e7ed" name="abd30409710541babddfe521d8e85e7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd30409710541babddfe521d8e85e7ed">&#9670;&#160;</a></span>get_turn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> TSLTiledNetwork::get_turn </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>turn_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> based on the global ID</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">turn_id</td><td>global id for the turn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> that refers to the turn that was found. If no turn was found the <a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> will refer to a dummy turn. </dd></dl>

</div>
</div>
<a id="a645d4a47d46465d574b56b6087b4ff30" name="a645d4a47d46465d574b56b6087b4ff30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645d4a47d46465d574b56b6087b4ff30">&#9670;&#160;</a></span>linkDestinNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> TSLTiledNetwork::linkDestinNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the link's destination <a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> to the link</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> to the destination node for the link </dd></dl>

</div>
</div>
<a id="ada7c32da3801de2a31dbf9a280f9c09e" name="ada7c32da3801de2a31dbf9a280f9c09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7c32da3801de2a31dbf9a280f9c09e">&#9670;&#160;</a></span>linkSourceNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> TSLTiledNetwork::linkSourceNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the link's source node iterator</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> to the link</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1node__iterator.html">node_iterator</a> to the source node for the link </dd></dl>

</div>
</div>
<a id="a9d7f51769697afa03193e2222004c4b9" name="a9d7f51769697afa03193e2222004c4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d7f51769697afa03193e2222004c4b9">&#9670;&#160;</a></span>loadData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLTiledNetwork::loadData </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load data from a file for the <a class="el" href="class_t_s_l_tiled_network.html">TSLTiledNetwork</a>. If data is already loaded into this <a class="el" href="class_t_s_l_tiled_network.html">TSLTiledNetwork</a> then it will be removed from memory and all references to it deleted. The specified filename must refer to a tiled network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>fully specified path to the tiled network file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if successfully loaded, false otherwise. </dd></dl>

</div>
</div>
<a id="a651e5aa8a6487e16989b8db7c8828ca5" name="a651e5aa8a6487e16989b8db7c8828ca5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a651e5aa8a6487e16989b8db7c8828ca5">&#9670;&#160;</a></span>lockQuery() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLTiledNetwork::lockQuery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_query.html">TSLNetworkQuery</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>all_loaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads the tiles associated with the links and nodes contained within the <a class="el" href="class_t_s_l_network_query.html">TSLNetworkQuery</a> object. Only as many tiles as can be held by the cache will be loaded. All_loaded indicates if all the tiles in the region were loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>reference to an existing query</td></tr>
    <tr><td class="paramname">all_loaded</td><td>boolean value to indicate if all the required tiles were loaded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all or some of the tiles were loaded , false otherwise. </dd></dl>

</div>
</div>
<a id="a2463b5377a290e00fb9b6f8160171043" name="a2463b5377a290e00fb9b6f8160171043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2463b5377a290e00fb9b6f8160171043">&#9670;&#160;</a></span>lockQuery() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLTiledNetwork::lockQuery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_route_query.html">TSLRouteQuery</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>query</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>all_loaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads the tiles associated with the links and nodes contained within the <a class="el" href="class_t_s_l_route_query.html">TSLRouteQuery</a> object. Only as many tiles as can be held by the cache will be loaded. All_loaded indicates if all the tiles in the region were loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>reference to an existing query</td></tr>
    <tr><td class="paramname">all_loaded</td><td>boolean value to indicate if all the required tiles were loaded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all or some of the tiles were loaded , false otherwise. </dd></dl>

</div>
</div>
<a id="a1c50bcc4087afdd95f9d715efc3fce6f" name="a1c50bcc4087afdd95f9d715efc3fce6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c50bcc4087afdd95f9d715efc3fce6f">&#9670;&#160;</a></span>lockRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLTiledNetwork::lockRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>all_loaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads all the tiles that overlap with the extent and locks them in memory so that they will not be cleared when the memory cache is automatically cleared. If the region includes tiles which have already been locked then their locked count will be incremented. It is important when locking a region that the all_loaded value is checked to make sure that the lock was successful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>rectangular extent to lock</td></tr>
    <tr><td class="paramname">all_loaded</td><td>boolean value to indicate if all the required tiles were loaded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all or some of the tiles were loaded , false otherwise. </dd></dl>

</div>
</div>
<a id="a94c91b27f008bbf3a318b881200df96d" name="a94c91b27f008bbf3a318b881200df96d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c91b27f008bbf3a318b881200df96d">&#9670;&#160;</a></span>lockRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLTiledNetwork::lockRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_polyline.html">TSLPolyline</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>all_loaded</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loads all the tiles that overlap with the polyline and locks them in memory so that they will not be cleared when the memory cache is automatically cleared. If the region includes tiles which have already been locked then their locked count will be incremented. It is important when locking a region that the all_loaded value is checked to make sure that the lock was successful.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polyline</td><td><a class="el" href="class_t_s_l_polyline.html">TSLPolyline</a> object that identifies a path</td></tr>
    <tr><td class="paramname">all_loaded</td><td>boolean value to indicate if all the required tiles were loaded.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if all or some of the tiles were loaded , false otherwise. </dd></dl>

</div>
</div>
<a id="a834b852635f60379236470693f7c40a2" name="a834b852635f60379236470693f7c40a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834b852635f60379236470693f7c40a2">&#9670;&#160;</a></span>operator new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLTiledNetwork::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are here to avoid being documented Allocation override for API redirection. </p>

</div>
</div>
<a id="a496cdc4ebfe52a21656265ddb4ae9169" name="a496cdc4ebfe52a21656265ddb4ae9169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a496cdc4ebfe52a21656265ddb4ae9169">&#9670;&#160;</a></span>operator new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLTiledNetwork::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When included in an MFC application in debug mode, the debug new expects this to be here. Override it and return the same as the normal one. The library must include it when compiled in release mode, since the user's application may be in debug mode. </p>

</div>
</div>
<a id="aa0b53ca843163933b27eafe8dbce80c0" name="aa0b53ca843163933b27eafe8dbce80c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b53ca843163933b27eafe8dbce80c0">&#9670;&#160;</a></span>removeData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLTiledNetwork::removeData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all data attached to this TSLTiledNetworkLayer.</p>
<dl class="section return"><dt>Returns</dt><dd>True if data was successfully removed or the tiled network was already empty, false otherwise. </dd></dl>

</div>
</div>
<a id="aca88cf160eefb85605786a4fc8b4554a" name="aca88cf160eefb85605786a4fc8b4554a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca88cf160eefb85605786a4fc8b4554a">&#9670;&#160;</a></span>route()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_route_query.html">TSLRouteQuery</a> * TSLTiledNetwork::route </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>from_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>to_node</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long *</td>          <td class="paramname"><span class="paramname"><em>via_nodes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>via_count</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_t_s_l_path_cost.html">TSLPathCost</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>cost</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>max_cost</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Will generate a NetworkRouteQuery object which contains copies of all the links and nodes involved in the best route returned. The links and nodes objects returned in the NetworkRouteQuery object will be read-only copies of the originals. This will allow the route to be analysed without the need for the original tiles</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from_node</td><td>global id of the start node for the route.</td></tr>
    <tr><td class="paramname">to_node</td><td>global id of the destination node for the route.</td></tr>
    <tr><td class="paramname">via_nodes</td><td>list of global ids for nodes to visit along the route.</td></tr>
    <tr><td class="paramname">via_count</td><td>number of via nodes contained in via_nodes.</td></tr>
    <tr><td class="paramname">cost</td><td>cost object for the path ( as in standard network )</td></tr>
    <tr><td class="paramname">max_cost</td><td>An upper bound for the cost of a path. Links from nodes whose cost exceeds max_cost will not be traversed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38f4a2be58a1ca2eeaf7ae05e8ad9b9b" name="a38f4a2be58a1ca2eeaf7ae05e8ad9b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f4a2be58a1ca2eeaf7ae05e8ad9b9b">&#9670;&#160;</a></span>turnDestinLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> TSLTiledNetwork::turnDestinLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the turns destination link iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> to the turn</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> to the destination node for the turn </dd></dl>

</div>
</div>
<a id="af8a649f0cb7dd40ccaf068b282076691" name="af8a649f0cb7dd40ccaf068b282076691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8a649f0cb7dd40ccaf068b282076691">&#9670;&#160;</a></span>turnSourceLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> TSLTiledNetwork::turnSourceLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the turns source link iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td><a class="el" href="class_t_s_l_tiled_network_1_1turn__iterator.html">turn_iterator</a> to the turn</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_t_s_l_tiled_network_1_1link__iterator.html">link_iterator</a> to the source link for the turn </dd></dl>

</div>
</div>
<a id="a8483dcedb9ad0f31bb7384468dc6316e" name="a8483dcedb9ad0f31bb7384468dc6316e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8483dcedb9ad0f31bb7384468dc6316e">&#9670;&#160;</a></span>unlockAll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLTiledNetwork::unlockAll </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks the all currently locked tiles and sets their lock count to zero. UnlockAll does not mean the tiles will immediately be freed from memory. This will be done when the memory cache is automatically cleared if the unlocked tiles are the "least recently used".</p>
<dl class="section return"><dt>Returns</dt><dd>True if all tiles were unlocked , false if there were no tile to unlock. </dd></dl>

</div>
</div>
<a id="a834eb8c3b31e02dd6caa9e7629c92cc8" name="a834eb8c3b31e02dd6caa9e7629c92cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834eb8c3b31e02dd6caa9e7629c92cc8">&#9670;&#160;</a></span>unlockQuery() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLTiledNetwork::unlockQuery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_query.html">TSLNetworkQuery</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>query</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks the tiles that relate to the specified query if they are currently loaded into memory. If a tile has been locked more than once then this will decrement its lock count. Unlocking a region so does not mean the tiles will immediately be freed from memory. This will be done when the memory cache is automatically cleared if the unlocked tiles are the "least recently used".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td><a class="el" href="class_t_s_l_network_query.html">TSLNetworkQuery</a> object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any tiles in the region were unlocked , false otherwise. </dd></dl>

</div>
</div>
<a id="ab60e9d7fd57ceaa9edac6ca1283592f7" name="ab60e9d7fd57ceaa9edac6ca1283592f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab60e9d7fd57ceaa9edac6ca1283592f7">&#9670;&#160;</a></span>unlockQuery() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLTiledNetwork::unlockQuery </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_route_query.html">TSLRouteQuery</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>query</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks the tiles that relate to the specified query if they are currently loaded into memory. If a tile has been locked more than once then this will decrement its lock count. Unlocking a region so does not mean the tiles will immediately be freed from memory. This will be done when the memory cache is automatically cleared if the unlocked tiles are the "least recently used".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td><a class="el" href="class_t_s_l_route_query.html">TSLRouteQuery</a> object</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any tiles in the region were unlocked , false otherwise. </dd></dl>

</div>
</div>
<a id="a1046335b075f46587a7a130dac568066" name="a1046335b075f46587a7a130dac568066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1046335b075f46587a7a130dac568066">&#9670;&#160;</a></span>unlockRegion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLTiledNetwork::unlockRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks the tiles that overlap with the specified extent if they are currently loaded into memory. If a tile has been locked more than once then this will decrement its lock count. Unlocking a region so does not mean the tiles will immediately be freed from memory. This will be done when the memory cache is automatically cleared if the unlocked tiles are the "least
recently used".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>rectangular extent to unlock</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any tiles in the region were unlocked , false otherwise. </dd></dl>

</div>
</div>
<a id="a8730aef1fa9d6cd63735319f2e04fdbf" name="a8730aef1fa9d6cd63735319f2e04fdbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8730aef1fa9d6cd63735319f2e04fdbf">&#9670;&#160;</a></span>unlockRegion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLTiledNetwork::unlockRegion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_polyline.html">TSLPolyline</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>polyline</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks the tiles that overlap with the specified polyline if they are currently loaded into memory. If a tile has been locked more than once then this will decrement its lock count. Unlocking a region so does not mean the tiles will immediately be freed from memory. This will be done when the memory cache is automatically cleared if the unlocked tiles are the "least
recently used".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">polyline</td><td><a class="el" href="class_t_s_l_polyline.html">TSLPolyline</a> object specifying a path</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if any tiles in the region were unlocked , false otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_tiled_network.html">TSLTiledNetwork</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.2 | Documentation created Wed Jul 23 2025 16:52:06 | Generated with <a href="http://www.doxygen.org/index.html">Doxygen 1.13.2</a> | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
