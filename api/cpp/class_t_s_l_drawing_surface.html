<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLDrawingSurface Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.1</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_drawing_surface.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_t_s_l_drawing_surface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLDrawingSurface Class Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span><div class="ingroups"><a class="el" href="group__apigroup__maplink__pro__developers__toolkit.html">MapLink Pro Developer Toolkit</a> &raquo; <a class="el" href="group__apigroup__api.html">Core API</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for TSLDrawingSurface:</div>
<div class="dyncontent">
<div class="center"><img src="class_t_s_l_drawing_surface__inherit__graph.png" border="0" usemap="#a_t_s_l_drawing_surface_inherit__map" alt="Inheritance graph"/></div>
<map name="a_t_s_l_drawing_surface_inherit__map" id="a_t_s_l_drawing_surface_inherit__map">
<area shape="rect" title=" " alt="" coords="205,132,329,159"/>
<area shape="rect" href="class_t_s_l_accelerated_surface.html" title=" " alt="" coords="377,56,521,83"/>
<area shape="poly" title=" " alt="" coords="309,122,376,92,406,81,408,86,378,97,311,127"/>
<area shape="rect" href="class_t_s_l_motif_surface.html" title=" " alt="" coords="396,107,502,133"/>
<area shape="poly" title=" " alt="" coords="344,132,395,125,396,130,345,137"/>
<area shape="rect" href="class_t_s_l_n_t_surface.html" title=" " alt="" coords="403,157,495,184"/>
<area shape="poly" title=" " alt="" coords="345,153,403,162,402,167,344,159"/>
<area shape="rect" href="class_t_s_l_open_g_l_surface.html" title=" " alt="" coords="388,208,510,235"/>
<area shape="poly" title=" " alt="" coords="311,163,378,194,408,205,406,210,376,198,309,168"/>
<area shape="rect" href="class_t_s_l_drawing_surface_base.html" title=" " alt="" coords="5,132,157,159"/>
<area shape="poly" title=" " alt="" coords="172,143,205,143,205,148,172,148"/>
<area shape="rect" href="class_t_s_l_d_x_accelerated_surface.html" title=" " alt="" coords="575,5,734,32"/>
<area shape="poly" title=" " alt="" coords="521,49,597,30,598,35,522,54"/>
<area shape="rect" href="class_t_s_l_w_g_l_accelerated_surface.html" title=" " alt="" coords="571,56,738,83"/>
<area shape="poly" title=" " alt="" coords="537,67,570,67,570,72,537,72"/>
<area shape="rect" href="class_t_s_l_x11_g_l_accelerated_surface.html" title=" " alt="" coords="569,107,740,133"/>
<area shape="poly" title=" " alt="" coords="522,84,598,103,597,109,521,90"/>
<area shape="rect" href="class_t_s_l_e_g_l_surface.html" title=" " alt="" coords="606,157,703,184"/>
<area shape="poly" title=" " alt="" coords="520,201,605,180,606,185,522,206"/>
<area shape="rect" href="class_t_s_l_g_l_x_surface.html" title=" " alt="" coords="605,208,704,235"/>
<area shape="poly" title=" " alt="" coords="525,219,605,219,605,224,525,224"/>
<area shape="rect" href="class_t_s_l_w_g_l_surface.html" title=" " alt="" coords="603,259,706,285"/>
<area shape="poly" title=" " alt="" coords="522,236,604,257,602,262,520,242"/>
<area shape="rect" href="class_t_s_l_native_e_g_l_surface.html" title=" " alt="" coords="788,157,919,184"/>
<area shape="poly" title=" " alt="" coords="719,168,787,168,787,173,719,173"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Passive component for displaying 2D data to a user supplied window.</p>
<p>The <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> component is responsible for the display of 2D data in a window supplied by the end user. As the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> is passive, there are no inherent event handling routines.</p>
<p>This component provides the following capabilities</p>
<ul>
<li>Drawing and view methods</li>
<li>Coordinate Conversions</li>
<li>Miscellaneous methods</li>
</ul>
<p>Other capabilities such as feature rendering, decluttering and style queries are provided by the base <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> class and the derived platform specific classes.</p>
<p>A <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> must be connected to a user-supplied window (or HDC/Pixmap) before it can display anything. It does not create a window of its own. This gives the user control over what is displayed in the window.</p>
<p>A <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> will display 2D data from any data layers that are connected to it. Layer control is handled by the <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> class.</p>
<p>The area of data displayed by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> can be modified by the methods 'zoom' and 'pan'. These methods take user-unit parameters and attempt to maintain the aspect ratio of the view. To redraw a specific area on the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>, two 'draw...' methods are available. The user must inform the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> of any modifications to the window size (in pixels) using the method 'wndResize' so that the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> can correctly calculate the area to display in the window.</p>
<p>The user has an alternative method of changing the area displayed by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> by calling 'resize'. This informs the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> of the complete world co-ordinate area to display. The image displayed by the drawing surface may be rotated by the 'rotate' method. This does not alter the raw data, only the way it is displayed on screen. Note that at present, Raster data cannot be rotated by MapLink.</p>
<p>Various methods are also available to set up user units, convert from internal TMC co-ordinate units to user units and vice versa. Line styles, fill styles, symbol styles, colors and fonts are loaded by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> from a file by calling 'loadStandardConfig' or by individual calls to 'setupLineStyles', 'setupFillStyles', 'setupSymbols', 'setupColours' and 'setupFonts'. These methods are static should only be called once by the application. To free the memory associated with these configurations, the 'cleanup' static method should be called when an application finishes. References to single styles take the form of an index into the list of styles loaded.</p>
<p><a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> provides mapping between 4 co-ordinate spaces:</p><ul>
<li>MapLink Mapping Co-ordinate (TMC). This is the internal representation of the map data co-ordinate space.</li>
<li>Map unit. This is the co-ordinate space of the map. For example, if a projection has been applied to the map, the map units may be metres, whereas if no projection or transformation has been applied the map units are directly mapped to the co-ordinate space of the input data set.</li>
<li>User unit. This is a scaled version of the map units, so that the user can choose the unit he will work with. For example, if the map units is metres, a user unit scaling factor of 1000 can be applied allowing the user to work in kilometres.</li>
<li>Device unit: co-ordinate space of the display device (usually pixel).</li>
</ul>
<p>This class is an abstract class, specifying the generic behaviour of a 2D <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0265147d1b95af2e58dba9044794e7ad" id="r_a0265147d1b95af2e58dba9044794e7ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0265147d1b95af2e58dba9044794e7ad">clearAllRendering</a> ()</td></tr>
<tr class="separator:a0265147d1b95af2e58dba9044794e7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf31e090d3f2a5d7fd9f009b19c53fe" id="r_aeaf31e090d3f2a5d7fd9f009b19c53fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeaf31e090d3f2a5d7fd9f009b19c53fe">clearDynamicColours</a> ()</td></tr>
<tr class="separator:aeaf31e090d3f2a5d7fd9f009b19c53fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e495c3693a20a9c7bacd180d9e9e452" id="r_a2e495c3693a20a9c7bacd180d9e9e452"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e495c3693a20a9c7bacd180d9e9e452">clone</a> (bool copyUserData=false)=0</td></tr>
<tr class="separator:a2e495c3693a20a9c7bacd180d9e9e452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471fe3d0a6601709cb7add89ce78c8a8" id="r_a471fe3d0a6601709cb7add89ce78c8a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_raster_buffer.html">TSLRasterBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a471fe3d0a6601709cb7add89ce78c8a8">createRasterBuffer</a> (unsigned int width, unsigned int height, <a class="el" href="class_t_s_l_raster_buffer.html#a1fafd2ab8f125b29ddceb5a2aaa91f7e">TSLRasterBuffer::Format</a> format, <a class="el" href="class_t_s_l_raster_buffer.html#a02b2cc2b1da9b354c4a40466d650cf24">TSLRasterBuffer::FilterMode</a> filterMode=<a class="el" href="class_t_s_l_raster_buffer.html#a02b2cc2b1da9b354c4a40466d650cf24a91eaf68f9a0200a02757022d9d863dae">TSLRasterBuffer::Linear</a>)</td></tr>
<tr class="separator:a471fe3d0a6601709cb7add89ce78c8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206fed500549fb011a7e64d391273899" id="r_a206fed500549fb011a7e64d391273899"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a206fed500549fb011a7e64d391273899">declutterIsVisible</a> (const char *feature_name, double resolution=0.0, const char *layer_name=0) const</td></tr>
<tr class="separator:a206fed500549fb011a7e64d391273899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbaf1905aaff87cfb59d77caa722e34" id="r_a9dbaf1905aaff87cfb59d77caa722e34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9dbaf1905aaff87cfb59d77caa722e34">drawDU</a> (TSLDeviceUnits x1, TSLDeviceUnits y1, TSLDeviceUnits x2, TSLDeviceUnits y2, bool clear, bool updateExtentOnly=false)</td></tr>
<tr class="separator:a9dbaf1905aaff87cfb59d77caa722e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c53e5790d1eb3b0b01672050d655d7" id="r_af6c53e5790d1eb3b0b01672050d655d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af6c53e5790d1eb3b0b01672050d655d7">drawUU</a> (double x1, double y1, double x2, double y2, bool clear, bool updateExtentOnly=false)</td></tr>
<tr class="separator:af6c53e5790d1eb3b0b01672050d655d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55958d05038aa959c54f21a03a95a017" id="r_a55958d05038aa959c54f21a03a95a017"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55958d05038aa959c54f21a03a95a017">DUToLatLong</a> (TSLDeviceUnits x, TSLDeviceUnits y, double *latitude, double *longitude, bool local=false, bool boundCheck=true) const</td></tr>
<tr class="separator:a55958d05038aa959c54f21a03a95a017"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5ccbb0dbce745dc1b1352285013e11" id="r_a9c5ccbb0dbce745dc1b1352285013e11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c5ccbb0dbce745dc1b1352285013e11">DUToMU</a> (TSLDeviceUnits x1, TSLDeviceUnits y1, double *x2, double *y2) const</td></tr>
<tr class="separator:a9c5ccbb0dbce745dc1b1352285013e11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92256bdb7597267758967a8889c10189" id="r_a92256bdb7597267758967a8889c10189"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92256bdb7597267758967a8889c10189">DUToTMC</a> (TSLDeviceUnits x1, TSLDeviceUnits y1, TSLTMC *x2, TSLTMC *y2) const</td></tr>
<tr class="separator:a92256bdb7597267758967a8889c10189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb8bfb6a862d236426427dcc7bb7de7" id="r_a9bb8bfb6a862d236426427dcc7bb7de7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bb8bfb6a862d236426427dcc7bb7de7">DUToUU</a> (TSLDeviceUnits x1, TSLDeviceUnits y1, double *x2, double *y2) const</td></tr>
<tr class="separator:a9bb8bfb6a862d236426427dcc7bb7de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fee92015216e73a978cbed135a5771" id="r_a26fee92015216e73a978cbed135a5771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a26fee92015216e73a978cbed135a5771">findEntityDU</a> (TSLDeviceUnits x, TSLDeviceUnits y, TSLDeviceUnits aperture, int depth, const char *feature_name=NULL)</td></tr>
<tr class="separator:a26fee92015216e73a978cbed135a5771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c864c485c3eaffa69cccc51fef7711d" id="r_a1c864c485c3eaffa69cccc51fef7711d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1c864c485c3eaffa69cccc51fef7711d">findEntityUU</a> (double x, double y, double aperture, int depth, const char *feature_name=NULL)</td></tr>
<tr class="separator:a1c864c485c3eaffa69cccc51fef7711d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12f7671255ef058944cb4e2b0d32063" id="r_aa12f7671255ef058944cb4e2b0d32063"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa12f7671255ef058944cb4e2b0d32063">findSelectedEntityDU</a> (TSLDeviceUnits x, TSLDeviceUnits y, TSLDeviceUnits aperture, int depth=-1, bool ignoreMapDataLayers=false)</td></tr>
<tr class="separator:aa12f7671255ef058944cb4e2b0d32063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834b6cd5cd46e2e37d28f248cfa32e3f" id="r_a834b6cd5cd46e2e37d28f248cfa32e3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a834b6cd5cd46e2e37d28f248cfa32e3f">findSelectedEntityUU</a> (double x, double y, double aperture, int depth=-1, bool ignoreMapDataLayers=false)</td></tr>
<tr class="separator:a834b6cd5cd46e2e37d28f248cfa32e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088da526a941a7e8b89ce030f7809b2a" id="r_a088da526a941a7e8b89ce030f7809b2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a088da526a941a7e8b89ce030f7809b2a">getColourIndices</a> (int **indices, int *num)</td></tr>
<tr class="separator:a088da526a941a7e8b89ce030f7809b2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62280c4a00af92d96b697809a45a2ad3" id="r_a62280c4a00af92d96b697809a45a2ad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a62280c4a00af92d96b697809a45a2ad3">getCoordinateProvidingLayer</a> ()</td></tr>
<tr class="separator:a62280c4a00af92d96b697809a45a2ad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a5c65d839aa420ceee2c397f629293" id="r_a77a5c65d839aa420ceee2c397f629293"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77a5c65d839aa420ceee2c397f629293">getCoordinateProvidingLayer</a> () const</td></tr>
<tr class="separator:a77a5c65d839aa420ceee2c397f629293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24685986e62832473065717f5d85121b" id="r_a24685986e62832473065717f5d85121b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24685986e62832473065717f5d85121b">getDeclutterRange</a> (const char *featureName, double *innerLimit, double *outerLimit, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:a24685986e62832473065717f5d85121b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7ca890687234f55c562a6b1cfe9605" id="r_a0b7ca890687234f55c562a6b1cfe9605"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b7ca890687234f55c562a6b1cfe9605">getDeviceCapabilities</a> (int &amp;horizontalSizeMM, int &amp;verticalSizeMM, int &amp;horizontalSizePixels, int &amp;verticalSizePixels) const</td></tr>
<tr class="separator:a0b7ca890687234f55c562a6b1cfe9605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16108f4d82547522e368cc6ab1194a7" id="r_ac16108f4d82547522e368cc6ab1194a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac16108f4d82547522e368cc6ab1194a7">getDeviceCapabilities</a> (<a class="el" href="class_t_s_l_device_capabilities.html">TSLDeviceCapabilities</a> &amp;capabilities) const</td></tr>
<tr class="separator:ac16108f4d82547522e368cc6ab1194a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1db5a44878ac35f0aedb681000ccf3" id="r_a8f1db5a44878ac35f0aedb681000ccf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f1db5a44878ac35f0aedb681000ccf3">getDUExtent</a> (TSLDeviceUnits *x1, TSLDeviceUnits *y1, TSLDeviceUnits *x2, TSLDeviceUnits *y2) const</td></tr>
<tr class="separator:a8f1db5a44878ac35f0aedb681000ccf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bde97604179aa10b89500cfd543dd06" id="r_a9bde97604179aa10b89500cfd543dd06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bde97604179aa10b89500cfd543dd06">getFillStyleIndices</a> (int **indices, int *num)</td></tr>
<tr class="separator:a9bde97604179aa10b89500cfd543dd06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56af95ebf21a45ca380a0ce42da51249" id="r_a56af95ebf21a45ca380a0ce42da51249"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a56af95ebf21a45ca380a0ce42da51249">getFontStyleIndices</a> (int **indices, int *num)</td></tr>
<tr class="separator:a56af95ebf21a45ca380a0ce42da51249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051cf30191f83100d566ea4b35700456" id="r_a051cf30191f83100d566ea4b35700456"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a051cf30191f83100d566ea4b35700456">getLineStyleIndices</a> (int **indices, int *num)</td></tr>
<tr class="separator:a051cf30191f83100d566ea4b35700456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f256aabb5b59e80b88e08038effc5c" id="r_a65f256aabb5b59e80b88e08038effc5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65f256aabb5b59e80b88e08038effc5c">getMUExtent</a> (double *x1, double *y1, double *x2, double *y2) const</td></tr>
<tr class="separator:a65f256aabb5b59e80b88e08038effc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c36e88a1ea95c97448f9d9bd41bcf4" id="r_a39c36e88a1ea95c97448f9d9bd41bcf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39c36e88a1ea95c97448f9d9bd41bcf4">getSymbolStyleIndices</a> (int **indices, int *num)</td></tr>
<tr class="separator:a39c36e88a1ea95c97448f9d9bd41bcf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a5044855e7098d3dfd31aeb50def3a" id="r_af7a5044855e7098d3dfd31aeb50def3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_drawing_surface_tiled_buffer_control.html">TSLDrawingSurfaceTiledBufferControl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7a5044855e7098d3dfd31aeb50def3a">getTiledBufferController</a> ()</td></tr>
<tr class="separator:af7a5044855e7098d3dfd31aeb50def3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4858d5b71cf4b0e867b363cfec4be4d" id="r_ab4858d5b71cf4b0e867b363cfec4be4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab4858d5b71cf4b0e867b363cfec4be4d">getTMCExtent</a> (<a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent) const</td></tr>
<tr class="separator:ab4858d5b71cf4b0e867b363cfec4be4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a127c44f812974a35def9bf6670dcb" id="r_a05a127c44f812974a35def9bf6670dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05a127c44f812974a35def9bf6670dcb">getUUExtent</a> (double *x1, double *y1, double *x2, double *y2) const</td></tr>
<tr class="separator:a05a127c44f812974a35def9bf6670dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb2c6838847338edd95ea19dff318bc" id="r_abeb2c6838847338edd95ea19dff318bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abeb2c6838847338edd95ea19dff318bc">getViewedLatLongRange</a> (double *latitude, double *longitude, double *range, bool local=false, bool boundCheck=true) const</td></tr>
<tr class="separator:abeb2c6838847338edd95ea19dff318bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad4b5bf36e222d864ee5db18a81054d" id="r_abad4b5bf36e222d864ee5db18a81054d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abad4b5bf36e222d864ee5db18a81054d">latLongToDU</a> (double latitude, double longitude, TSLDeviceUnits *x, TSLDeviceUnits *y, bool local=false) const</td></tr>
<tr class="separator:abad4b5bf36e222d864ee5db18a81054d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396b86032a83c3a8b8eec53ca10dc10b" id="r_a396b86032a83c3a8b8eec53ca10dc10b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a396b86032a83c3a8b8eec53ca10dc10b">latLongToMU</a> (double latitude, double longitude, double *x, double *y, bool local=false) const</td></tr>
<tr class="separator:a396b86032a83c3a8b8eec53ca10dc10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cba4efaf42d5cc263331f6031ab1a19" id="r_a8cba4efaf42d5cc263331f6031ab1a19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8cba4efaf42d5cc263331f6031ab1a19">latLongToTMC</a> (double latitude, double longitude, TSLTMC *x, TSLTMC *y, bool local=false) const</td></tr>
<tr class="separator:a8cba4efaf42d5cc263331f6031ab1a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a585738cf746b7ba0fd07121f09d57" id="r_a24a585738cf746b7ba0fd07121f09d57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24a585738cf746b7ba0fd07121f09d57">latLongToUU</a> (double latitude, double longitude, double *x, double *y, bool local=false) const</td></tr>
<tr class="separator:a24a585738cf746b7ba0fd07121f09d57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229a7af4f762a8b08fa85ec98c4a6216" id="r_a229a7af4f762a8b08fa85ec98c4a6216"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a229a7af4f762a8b08fa85ec98c4a6216">MUToDU</a> (double x1, double y1, TSLDeviceUnits *x2, TSLDeviceUnits *y2) const</td></tr>
<tr class="separator:a229a7af4f762a8b08fa85ec98c4a6216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e6d157fa0bc20f57c0ac472c2f89d1" id="r_a34e6d157fa0bc20f57c0ac472c2f89d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34e6d157fa0bc20f57c0ac472c2f89d1">MUToLatLong</a> (double x, double y, double *latitude, double *longitude, bool local=false, bool boundCheck=true) const</td></tr>
<tr class="separator:a34e6d157fa0bc20f57c0ac472c2f89d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056dc5745b1ddb69eee0107691a6d156" id="r_a056dc5745b1ddb69eee0107691a6d156"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a056dc5745b1ddb69eee0107691a6d156">MUToTMC</a> (double x1, double y1, TSLTMC *x2, TSLTMC *y2) const</td></tr>
<tr class="separator:a056dc5745b1ddb69eee0107691a6d156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519dcb08d580a637d8e99a55ed71b8cf" id="r_a519dcb08d580a637d8e99a55ed71b8cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a519dcb08d580a637d8e99a55ed71b8cf">MUToUU</a> (double x1, double y1, double *x2, double *y2) const</td></tr>
<tr class="separator:a519dcb08d580a637d8e99a55ed71b8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72dfae3357186a52e4cf5f33c7ff121" id="r_af72dfae3357186a52e4cf5f33c7ff121"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af72dfae3357186a52e4cf5f33c7ff121">pan</a> (double x1, double y1, bool auto_redraw=true)</td></tr>
<tr class="separator:af72dfae3357186a52e4cf5f33c7ff121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e7ebe67614f96a87a04e8dfac6b2aa" id="r_a90e7ebe67614f96a87a04e8dfac6b2aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a90e7ebe67614f96a87a04e8dfac6b2aa">pan</a> (double x1, double y1, TSLDeviceUnits xDU, TSLDeviceUnits yDU, bool auto_redraw=true)</td></tr>
<tr class="separator:a90e7ebe67614f96a87a04e8dfac6b2aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9491068819845644862267d6338fc263" id="r_a9491068819845644862267d6338fc263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9491068819845644862267d6338fc263">query</a> (const char *layerName, TSLTMC x1, TSLTMC y1, TSLTMC x2, TSLTMC y2, int depth=-1, const char *feature_name=NULL) const</td></tr>
<tr class="separator:a9491068819845644862267d6338fc263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e56090a87893c5fb5f07cfe30835d8f" id="r_a5e56090a87893c5fb5f07cfe30835d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e56090a87893c5fb5f07cfe30835d8f">query</a> (const char *layerName, TSLTMC x1, TSLTMC y1, TSLTMC x2, TSLTMC y2, <a class="el" href="class_t_s_l_selector.html">TSLSelector</a> *selector) const</td></tr>
<tr class="separator:a5e56090a87893c5fb5f07cfe30835d8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85ac70f3315d04cf26c6a90025b4944" id="r_ae85ac70f3315d04cf26c6a90025b4944"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae85ac70f3315d04cf26c6a90025b4944">redraw</a> ()</td></tr>
<tr class="separator:ae85ac70f3315d04cf26c6a90025b4944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed93ce6d7d56190ca1c06cf9701822dc" id="r_aed93ce6d7d56190ca1c06cf9701822dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed93ce6d7d56190ca1c06cf9701822dc">reset</a> (bool auto_redraw=true)</td></tr>
<tr class="separator:aed93ce6d7d56190ca1c06cf9701822dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7690d28806f4f49eefa448236c693ed" id="r_ab7690d28806f4f49eefa448236c693ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7690d28806f4f49eefa448236c693ed">resize</a> (double x1, double y1, double x2, double y2, bool auto_redraw=true, bool keep_aspect=false)</td></tr>
<tr class="separator:ab7690d28806f4f49eefa448236c693ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800690766b84cce3a78c08bf1f81bf85" id="r_a800690766b84cce3a78c08bf1f81bf85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a800690766b84cce3a78c08bf1f81bf85">rotate</a> (double angle)</td></tr>
<tr class="separator:a800690766b84cce3a78c08bf1f81bf85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed652727aa64811d82939686f197953" id="r_a2ed652727aa64811d82939686f197953"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ed652727aa64811d82939686f197953">rotation</a> () const</td></tr>
<tr class="separator:a2ed652727aa64811d82939686f197953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48130aab4aea41eaacd059d307573e0" id="r_aa48130aab4aea41eaacd059d307573e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa48130aab4aea41eaacd059d307573e0">setDeclutterRange</a> (const char *featureName, double innerLimit, double outerLimit, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:aa48130aab4aea41eaacd059d307573e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c1fbad2ef1ae403936f7d92b06ce29" id="r_ac3c1fbad2ef1ae403936f7d92b06ce29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac3c1fbad2ef1ae403936f7d92b06ce29">setDeviceCapabilities</a> (const int horizontalSizeMM=0, const int verticalSizeMM=0, const int horizontalSizePixels=0, const int verticalSizePixels=0)</td></tr>
<tr class="separator:ac3c1fbad2ef1ae403936f7d92b06ce29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164f432573707f6d4ee485bccf136f74" id="r_a164f432573707f6d4ee485bccf136f74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a164f432573707f6d4ee485bccf136f74">setDeviceCapabilities</a> (const <a class="el" href="class_t_s_l_device_capabilities.html">TSLDeviceCapabilities</a> &amp;capabilities)</td></tr>
<tr class="separator:a164f432573707f6d4ee485bccf136f74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98ffd5550409dab6aa56886979538b3" id="r_ab98ffd5550409dab6aa56886979538b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab98ffd5550409dab6aa56886979538b3">setRedrawCallback</a> (<a class="el" href="class_t_s_l_drawing_surface_draw_callback.html">TSLDrawingSurfaceDrawCallback</a> *callback)</td></tr>
<tr class="separator:ab98ffd5550409dab6aa56886979538b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f51404204385733cd71891f4dd7b6fc" id="r_a7f51404204385733cd71891f4dd7b6fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7f51404204385733cd71891f4dd7b6fc">setupDynamicColours</a> (const char *filename)</td></tr>
<tr class="separator:a7f51404204385733cd71891f4dd7b6fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12ea6c2b80dc64f1c48041f8669455c" id="r_ae12ea6c2b80dc64f1c48041f8669455c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae12ea6c2b80dc64f1c48041f8669455c">setViewedLatLongRange</a> (double latitude, double longitude, double range, bool local=false, bool auto_redraw=true, bool keep_aspect=false)</td></tr>
<tr class="separator:ae12ea6c2b80dc64f1c48041f8669455c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e19f07cd5d254d552f72555af9a8c3b" id="r_a8e19f07cd5d254d552f72555af9a8c3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e19f07cd5d254d552f72555af9a8c3b">TMCperDU</a> (double &amp;xr, double &amp;yr)</td></tr>
<tr class="separator:a8e19f07cd5d254d552f72555af9a8c3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce349a3c79510c6e24e2dabdc7ecfc8" id="r_a8ce349a3c79510c6e24e2dabdc7ecfc8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ce349a3c79510c6e24e2dabdc7ecfc8">TMCperUU</a> ()</td></tr>
<tr class="separator:a8ce349a3c79510c6e24e2dabdc7ecfc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8e6605f56df449e17d44e200e36d4c" id="r_a0b8e6605f56df449e17d44e200e36d4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b8e6605f56df449e17d44e200e36d4c">TMCToDU</a> (TSLTMC x1, TSLTMC y1, TSLDeviceUnits *x2, TSLDeviceUnits *y2) const</td></tr>
<tr class="separator:a0b8e6605f56df449e17d44e200e36d4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4f2031604fd46d50acbc2df498decf" id="r_a4f4f2031604fd46d50acbc2df498decf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f4f2031604fd46d50acbc2df498decf">TMCToLatLong</a> (TSLTMC x, TSLTMC y, double *latitude, double *longitude, bool local=false, bool boundCheck=true) const</td></tr>
<tr class="separator:a4f4f2031604fd46d50acbc2df498decf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd800e36b15f4eed4777d08d1d522410" id="r_afd800e36b15f4eed4777d08d1d522410"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd800e36b15f4eed4777d08d1d522410">TMCToMU</a> (TSLTMC x1, TSLTMC y1, double *x2, double *y2) const</td></tr>
<tr class="separator:afd800e36b15f4eed4777d08d1d522410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7992c07cb5d68bc4721823711a11e8e" id="r_ae7992c07cb5d68bc4721823711a11e8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae7992c07cb5d68bc4721823711a11e8e">TMCToUU</a> (TSLTMC x1, TSLTMC y1, double *x2, double *y2) const</td></tr>
<tr class="separator:ae7992c07cb5d68bc4721823711a11e8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e24f4cf626a0e8c4b092f12f9a94dff" id="r_a7e24f4cf626a0e8c4b092f12f9a94dff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e24f4cf626a0e8c4b092f12f9a94dff">updateEntityExtent</a> (<a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *entity, const char *layerName)</td></tr>
<tr class="separator:a7e24f4cf626a0e8c4b092f12f9a94dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941815a45e93b11238a630e068ea10cf" id="r_a941815a45e93b11238a630e068ea10cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a941815a45e93b11238a630e068ea10cf">userUnitOrigin</a> (double x_origin, double y_origin)</td></tr>
<tr class="separator:a941815a45e93b11238a630e068ea10cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e943708c846dbecc4585ac7ef926e39" id="r_a7e943708c846dbecc4585ac7ef926e39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e943708c846dbecc4585ac7ef926e39">userUnitOrigin</a> (<a class="el" href="group__apigroup__api.html#gaea852777270e6ad45b6398b684f03fb5">TSLUUEnum</a> origin_enum)</td></tr>
<tr class="separator:a7e943708c846dbecc4585ac7ef926e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5c4a9338fc9a7f7c19020a2f3cf2ee" id="r_aee5c4a9338fc9a7f7c19020a2f3cf2ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee5c4a9338fc9a7f7c19020a2f3cf2ee">userUnits</a> (double factor)</td></tr>
<tr class="separator:aee5c4a9338fc9a7f7c19020a2f3cf2ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7eb89e0d8eb0bb0311a36bb60a4b9fb" id="r_ad7eb89e0d8eb0bb0311a36bb60a4b9fb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7eb89e0d8eb0bb0311a36bb60a4b9fb">userUnits</a> ()</td></tr>
<tr class="separator:ad7eb89e0d8eb0bb0311a36bb60a4b9fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c636fd6c2727611dde71d21546dfb6" id="r_a17c636fd6c2727611dde71d21546dfb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17c636fd6c2727611dde71d21546dfb6">UUToDU</a> (double x1, double y1, TSLDeviceUnits *x2, TSLDeviceUnits *y2) const</td></tr>
<tr class="separator:a17c636fd6c2727611dde71d21546dfb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1874cf113c30ee0fd2523a673968aecc" id="r_a1874cf113c30ee0fd2523a673968aecc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1874cf113c30ee0fd2523a673968aecc">UUToLatLong</a> (double x, double y, double *latitude, double *longitude, bool local=false, bool boundCheck=true) const</td></tr>
<tr class="separator:a1874cf113c30ee0fd2523a673968aecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3708fb917b3f5d376322fb4aeee38ee" id="r_ad3708fb917b3f5d376322fb4aeee38ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad3708fb917b3f5d376322fb4aeee38ee">UUToMU</a> (double x1, double y1, double *x2, double *y2) const</td></tr>
<tr class="separator:ad3708fb917b3f5d376322fb4aeee38ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381ad674e87bbb437ad98b75ebb52a9e" id="r_a381ad674e87bbb437ad98b75ebb52a9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a381ad674e87bbb437ad98b75ebb52a9e">UUToTMC</a> (double x1, double y1, TSLTMC *x2, TSLTMC *y2) const</td></tr>
<tr class="separator:a381ad674e87bbb437ad98b75ebb52a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82700ea425c05e6350ecb8a3f66db1d" id="r_ab82700ea425c05e6350ecb8a3f66db1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab82700ea425c05e6350ecb8a3f66db1d">wndResize</a> (TSLDeviceUnits x1, TSLDeviceUnits y1, TSLDeviceUnits x2, TSLDeviceUnits y2, bool auto_redraw=true, <a class="el" href="group__apigroup__api.html#gac1205ab450d747428b9d32017d80d9ad">TSLResizeActionEnum</a> action=<a class="el" href="group__apigroup__api.html#ggac1205ab450d747428b9d32017d80d9adac27a24e79765e5ca34941717c2173eed">TSLResizeActionNone</a>)</td></tr>
<tr class="separator:ab82700ea425c05e6350ecb8a3f66db1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac788a5c33da53c07951fc0ce7de2d17" id="r_aac788a5c33da53c07951fc0ce7de2d17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac788a5c33da53c07951fc0ce7de2d17">zoom</a> (double percent, bool zoom_in, bool auto_redraw=true)</td></tr>
<tr class="separator:aac788a5c33da53c07951fc0ce7de2d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30e410f6da8fb2f7c1b1c3ac570c0b7" id="r_af30e410f6da8fb2f7c1b1c3ac570c0b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af30e410f6da8fb2f7c1b1c3ac570c0b7">TSLDrawingSurface</a> ()</td></tr>
<tr class="separator:af30e410f6da8fb2f7c1b1c3ac570c0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a5f72960f6f6184d429ae5cbbc99f0" id="r_a19a5f72960f6f6184d429ae5cbbc99f0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19a5f72960f6f6184d429ae5cbbc99f0">~TSLDrawingSurface</a> ()</td></tr>
<tr class="separator:a19a5f72960f6f6184d429ae5cbbc99f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a09056395ae216959f9cdab30d7744" id="r_a01a09056395ae216959f9cdab30d7744"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01a09056395ae216959f9cdab30d7744">clearSymbolList</a> ()</td></tr>
<tr class="separator:a01a09056395ae216959f9cdab30d7744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824eeb7f498f27ee606cf6858d0c8b3b" id="r_a824eeb7f498f27ee606cf6858d0c8b3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a824eeb7f498f27ee606cf6858d0c8b3b">clearFontList</a> ()</td></tr>
<tr class="separator:a824eeb7f498f27ee606cf6858d0c8b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396aa24cca72491d62ec7b6f379da219" id="r_a396aa24cca72491d62ec7b6f379da219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a396aa24cca72491d62ec7b6f379da219">clearLineList</a> ()</td></tr>
<tr class="separator:a396aa24cca72491d62ec7b6f379da219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fdbce18a41087bc8240fcf807050ce" id="r_a15fdbce18a41087bc8240fcf807050ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15fdbce18a41087bc8240fcf807050ce">clearFillList</a> ()</td></tr>
<tr class="separator:a15fdbce18a41087bc8240fcf807050ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6c56019d6190af127879ce48b6250a" id="r_acb6c56019d6190af127879ce48b6250a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb6c56019d6190af127879ce48b6250a">removeFillStyle</a> (TSLStyleID style)</td></tr>
<tr class="separator:acb6c56019d6190af127879ce48b6250a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72941d15fa3abb4af65b41d2d3e0205d" id="r_a72941d15fa3abb4af65b41d2d3e0205d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72941d15fa3abb4af65b41d2d3e0205d">removeLineStyle</a> (TSLStyleID style)</td></tr>
<tr class="separator:a72941d15fa3abb4af65b41d2d3e0205d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4829860c91707d31cf426c4d63de5835" id="r_a4829860c91707d31cf426c4d63de5835"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4829860c91707d31cf426c4d63de5835">removeSymbolStyle</a> (TSLStyleID style)</td></tr>
<tr class="separator:a4829860c91707d31cf426c4d63de5835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f89f337edd9a76ca9d1fd2638b09106" id="r_a3f89f337edd9a76ca9d1fd2638b09106"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f89f337edd9a76ca9d1fd2638b09106">removeFontStyle</a> (TSLStyleID style)</td></tr>
<tr class="separator:a3f89f337edd9a76ca9d1fd2638b09106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946c15e83276c2a5d308efb701062c18" id="r_a946c15e83276c2a5d308efb701062c18"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a946c15e83276c2a5d308efb701062c18">createFontID</a> (const <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;name, TSLFontType meaningOfName, int fontWeight, bool italic=false, bool underline=false, bool antiAliased=false, const unsigned char *memoryBlock=NULL, TSLSize memoryBlockSize=0)</td></tr>
<tr class="separator:a946c15e83276c2a5d308efb701062c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e5fda0f85949120c75f961c35be4b3" id="r_af5e5fda0f85949120c75f961c35be4b3"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5e5fda0f85949120c75f961c35be4b3">createStandardLineID</a> (const unsigned char *pattern, TSLSize patternLength, int initialOffset, TSLLineScalingType scaleType)</td></tr>
<tr class="separator:af5e5fda0f85949120c75f961c35be4b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b86b6973e62cdd0a1ca4a244328c32" id="r_ad0b86b6973e62cdd0a1ca4a244328c32"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0b86b6973e62cdd0a1ca4a244328c32">createSymbolLineID</a> (int symbolID, double size=0.0, <a class="el" href="group__apigroup__geometry__api.html#ga575681bd39e0be106648609e4958788c">TSLDimensionUnits</a> sizeUnits=<a class="el" href="group__apigroup__geometry__api.html#gga575681bd39e0be106648609e4958788cae841a878e751716330b78e01d1f7b0b1">TSLDimensionUnitsUndefined</a>, float <a class="el" href="#a2ed652727aa64811d82939686f197953">rotation</a>=0.0f, double anchorPointX=0.0, double anchorPointY=0.0, <a class="el" href="group__apigroup__geometry__api.html#ga575681bd39e0be106648609e4958788c">TSLDimensionUnits</a> anchorPointUnits=<a class="el" href="group__apigroup__geometry__api.html#gga575681bd39e0be106648609e4958788cae841a878e751716330b78e01d1f7b0b1">TSLDimensionUnitsUndefined</a>)</td></tr>
<tr class="separator:ad0b86b6973e62cdd0a1ca4a244328c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a2d9eed2a9376eeca1d7ee7c1d6d2f" id="r_a69a2d9eed2a9376eeca1d7ee7c1d6d2f"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a69a2d9eed2a9376eeca1d7ee7c1d6d2f">createStandardFillID</a> (const unsigned char *pattern=NULL, TSLSize patternSizeInBytes=0, int patternXSize=0, int patternYSize=0)</td></tr>
<tr class="separator:a69a2d9eed2a9376eeca1d7ee7c1d6d2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c125151569f85aa2d1dd3eb4cb6d893" id="r_a3c125151569f85aa2d1dd3eb4cb6d893"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c125151569f85aa2d1dd3eb4cb6d893">createSymbolFillID</a> (int symbolID, double size=0.0, <a class="el" href="group__apigroup__geometry__api.html#ga575681bd39e0be106648609e4958788c">TSLDimensionUnits</a> sizeUnits=<a class="el" href="group__apigroup__geometry__api.html#gga575681bd39e0be106648609e4958788cae841a878e751716330b78e01d1f7b0b1">TSLDimensionUnitsUndefined</a>, float <a class="el" href="#a2ed652727aa64811d82939686f197953">rotation</a>=0.0f, double anchorPointX=0.0, double anchorPointY=0.0, <a class="el" href="group__apigroup__geometry__api.html#ga575681bd39e0be106648609e4958788c">TSLDimensionUnits</a> anchorPointUnits=<a class="el" href="group__apigroup__geometry__api.html#gga575681bd39e0be106648609e4958788cae841a878e751716330b78e01d1f7b0b1">TSLDimensionUnitsUndefined</a>)</td></tr>
<tr class="separator:a3c125151569f85aa2d1dd3eb4cb6d893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbce81dc062e8f57bbeed7f994499421" id="r_adbce81dc062e8f57bbeed7f994499421"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbce81dc062e8f57bbeed7f994499421">createSVGSymbolID</a> (const <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;name, const unsigned char *memoryBlock=NULL, TSLSize memoryBlockSize=0)</td></tr>
<tr class="separator:adbce81dc062e8f57bbeed7f994499421"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb63ecf6e6e4c00abaf2136b1ccb79c" id="r_a5fb63ecf6e6e4c00abaf2136b1ccb79c"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb63ecf6e6e4c00abaf2136b1ccb79c">createFontSymbolID</a> (const <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;name, TSLFontType meaningOfName, const unsigned char *memoryBlock=NULL, TSLSize memoryBlockSize=0)</td></tr>
<tr class="separator:a5fb63ecf6e6e4c00abaf2136b1ccb79c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72399f3239a3b10e121069a0dbed6bb2" id="r_a72399f3239a3b10e121069a0dbed6bb2"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72399f3239a3b10e121069a0dbed6bb2">createRasterSymbolID</a> (const <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;name, int xorigin, int yorigin, bool scaleable, const unsigned char *memoryBlock=NULL, TSLSize memoryBlockSize=0)</td></tr>
<tr class="separator:a72399f3239a3b10e121069a0dbed6bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab0a60b674c19e504b6e85e04f7937a" id="r_a6ab0a60b674c19e504b6e85e04f7937a"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ab0a60b674c19e504b6e85e04f7937a">createSymbolIDFromSymbol</a> (TSLStyleID symbolID, int numberofColourPairs, const int *colourFrom, const int *colourTo)</td></tr>
<tr class="separator:a6ab0a60b674c19e504b6e85e04f7937a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_t_s_l_drawing_surface_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_t_s_l_drawing_surface_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a></td></tr>
<tr class="memitem:adf2508e14060aa37e3f64d3d4daedb83 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_adf2508e14060aa37e3f64d3d4daedb83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#adf2508e14060aa37e3f64d3d4daedb83">addDataLayer</a> (<a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> *data_layer_interface, const char *data_id)</td></tr>
<tr class="separator:adf2508e14060aa37e3f64d3d4daedb83 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756782b5ecf3f00c22d8a20c40096453 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a756782b5ecf3f00c22d8a20c40096453"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a756782b5ecf3f00c22d8a20c40096453">addDynamicRenderer</a> (<a class="el" href="class_t_s_l_dynamic_renderer.html">TSLDynamicRenderer</a> *renderer, TSLFeatureID featureID=-1, const char *layerName=0)</td></tr>
<tr class="separator:a756782b5ecf3f00c22d8a20c40096453 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28c609ffd861cc7e0f1de9a4e3ffff9 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ab28c609ffd861cc7e0f1de9a4e3ffff9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ab28c609ffd861cc7e0f1de9a4e3ffff9">addFeatureRendering</a> (const char *featureName, TSLFeatureID featureID)</td></tr>
<tr class="separator:ab28c609ffd861cc7e0f1de9a4e3ffff9 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad695674703054f6dde4f8f472160ca82 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ad695674703054f6dde4f8f472160ca82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ad695674703054f6dde4f8f472160ca82">attach</a> (TSLDeviceContext handle)</td></tr>
<tr class="separator:ad695674703054f6dde4f8f472160ca82 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac268beaaf3462b6d6a1845bebb3fb113 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ac268beaaf3462b6d6a1845bebb3fb113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ac268beaaf3462b6d6a1845bebb3fb113">attach</a> (TSLWindowHandle handle)</td></tr>
<tr class="separator:ac268beaaf3462b6d6a1845bebb3fb113 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab367bb38ef5a8e3ce9df1b17fe665fbd inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ab367bb38ef5a8e3ce9df1b17fe665fbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ab367bb38ef5a8e3ce9df1b17fe665fbd">attach</a> (TSLDrawableHandle handle)</td></tr>
<tr class="separator:ab367bb38ef5a8e3ce9df1b17fe665fbd inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa764a7e039e56f2489a1f62d238701 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a5fa764a7e039e56f2489a1f62d238701"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a5fa764a7e039e56f2489a1f62d238701">bringInFrontof</a> (const char *move_data_layer, const char *target_data_layer)</td></tr>
<tr class="separator:a5fa764a7e039e56f2489a1f62d238701 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccd258d58e99d15c4bcae1b4c1170f7 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_aeccd258d58e99d15c4bcae1b4c1170f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#aeccd258d58e99d15c4bcae1b4c1170f7">bringToFront</a> (const char *move_data_layer)</td></tr>
<tr class="separator:aeccd258d58e99d15c4bcae1b4c1170f7 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171387fcf2304549fffe4982562ca4c2 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a171387fcf2304549fffe4982562ca4c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a171387fcf2304549fffe4982562ca4c2">clearAllDeclutterData</a> (const char *layer_name=0)</td></tr>
<tr class="separator:a171387fcf2304549fffe4982562ca4c2 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bdcd971140c6640265b2acc4457eb5 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a55bdcd971140c6640265b2acc4457eb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a55bdcd971140c6640265b2acc4457eb5">clearAllDynamicRenderers</a> ()</td></tr>
<tr class="separator:a55bdcd971140c6640265b2acc4457eb5 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdabfe424ab268061573eafed87ffb04 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_afdabfe424ab268061573eafed87ffb04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#afdabfe424ab268061573eafed87ffb04">clearBackgroundColour</a> ()</td></tr>
<tr class="separator:afdabfe424ab268061573eafed87ffb04 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e94baf9c65b8079c543b7945365d07 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a59e94baf9c65b8079c543b7945365d07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a59e94baf9c65b8079c543b7945365d07">clearDeclutterData</a> (const char *feature_name, const char *layer_name=0)</td></tr>
<tr class="separator:a59e94baf9c65b8079c543b7945365d07 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7373de95bfb938c2226e8f294280a3a inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_af7373de95bfb938c2226e8f294280a3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#af7373de95bfb938c2226e8f294280a3a">clearDynamicRenderer</a> (TSLFeatureID featureID=-1, const char *layerName=0)</td></tr>
<tr class="separator:af7373de95bfb938c2226e8f294280a3a inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a6a56d2729aa0a1fafe37b6aa04f52 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a25a6a56d2729aa0a1fafe37b6aa04f52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a25a6a56d2729aa0a1fafe37b6aa04f52">clearFeatureRendering</a> (const char *featureName, TSLFeatureID featureID)</td></tr>
<tr class="separator:a25a6a56d2729aa0a1fafe37b6aa04f52 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b812d3c132366b9f20b92110c8dad6f inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a7b812d3c132366b9f20b92110c8dad6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a7b812d3c132366b9f20b92110c8dad6f">clearFrame</a> ()</td></tr>
<tr class="separator:a7b812d3c132366b9f20b92110c8dad6f inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e62109d1d6673dc37cbb79f0d13cef inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ab3e62109d1d6673dc37cbb79f0d13cef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ab3e62109d1d6673dc37cbb79f0d13cef">copyDeclutterData</a> (const char *src_feature_name, const char *dest_feature_name, const char *src_layer_name=0, const char *dest_layer_name=0)</td></tr>
<tr class="separator:ab3e62109d1d6673dc37cbb79f0d13cef inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b35a14f96de605f73191cbb04b86cf inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a27b35a14f96de605f73191cbb04b86cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a27b35a14f96de605f73191cbb04b86cf">detach</a> ()</td></tr>
<tr class="separator:a27b35a14f96de605f73191cbb04b86cf inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f3ab638243f6016c21bdffb6f28a44 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_aa6f3ab638243f6016c21bdffb6f28a44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#aa6f3ab638243f6016c21bdffb6f28a44">detachAllDynamicRenderers</a> ()</td></tr>
<tr class="separator:aa6f3ab638243f6016c21bdffb6f28a44 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc62268d7293cc9fac136200e6aed62 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a0fc62268d7293cc9fac136200e6aed62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a0fc62268d7293cc9fac136200e6aed62">detachDynamicRenderer</a> (TSLFeatureID featureID=-1, const char *layerName=0)</td></tr>
<tr class="separator:a0fc62268d7293cc9fac136200e6aed62 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da02a3dca66e350f188cc66d49b95d5 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a0da02a3dca66e350f188cc66d49b95d5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a0da02a3dca66e350f188cc66d49b95d5">featureClass</a> (TSLFeatureID feature_id)</td></tr>
<tr class="separator:a0da02a3dca66e350f188cc66d49b95d5 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f617343c50c8f907c05a895adc0f710 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a5f617343c50c8f907c05a895adc0f710"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a5f617343c50c8f907c05a895adc0f710">forceLayer</a> (const char *data_id, const char *detail_layer_name)</td></tr>
<tr class="separator:a5f617343c50c8f907c05a895adc0f710 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3f571b473fae1be0e3fda757f8a84a inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_aef3f571b473fae1be0e3fda757f8a84a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#aef3f571b473fae1be0e3fda757f8a84a">getBackgroundColour</a> (TSLStyleID *value)</td></tr>
<tr class="separator:aef3f571b473fae1be0e3fda757f8a84a inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff44ab7558d9044846c390b9c69b43c7 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_aff44ab7558d9044846c390b9c69b43c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#aff44ab7558d9044846c390b9c69b43c7">getColourValue</a> (int colour, unsigned char &amp;r, unsigned char &amp;g, unsigned char &amp;b)</td></tr>
<tr class="separator:aff44ab7558d9044846c390b9c69b43c7 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008b6ccaa73f5e7dedf2c09cc7feeb64 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a008b6ccaa73f5e7dedf2c09cc7feeb64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a008b6ccaa73f5e7dedf2c09cc7feeb64">getDataLayer</a> (const char *data_id)</td></tr>
<tr class="separator:a008b6ccaa73f5e7dedf2c09cc7feeb64 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ab91eba6e19889be3e4bb041cf023 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a630ab91eba6e19889be3e4bb041cf023"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a630ab91eba6e19889be3e4bb041cf023">getDataLayerInfo</a> (int N, <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> **dataLayer, const char **layerName) const</td></tr>
<tr class="separator:a630ab91eba6e19889be3e4bb041cf023 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319f8ac2a9cd7254e95120afe0c1ecfa inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a319f8ac2a9cd7254e95120afe0c1ecfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a319f8ac2a9cd7254e95120afe0c1ecfa">getDataLayerProps</a> (const char *data_id, <a class="el" href="group__apigroup__api.html#ga1c467581ddf31341ac6acf6baa297a9a">TSLPropertyEnum</a> property_id, TSLPropertyValue *old_value)</td></tr>
<tr class="separator:a319f8ac2a9cd7254e95120afe0c1ecfa inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d9532d2f61896824476e912db4efff inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ad2d9532d2f61896824476e912db4efff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ad2d9532d2f61896824476e912db4efff">getDeclutterStatus</a> (const char *feature_name, <a class="el" href="group__apigroup__api.html#gadd64c2d584f0cab2498c784c9451d85e">TSLDeclutterStatusResultEnum</a> *value, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:ad2d9532d2f61896824476e912db4efff inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61d832cd81e2c7a0ea2fa9744aec16a inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ae61d832cd81e2c7a0ea2fa9744aec16a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ae61d832cd81e2c7a0ea2fa9744aec16a">getDeclutterStatus</a> (TSLFeatureID feature_id, <a class="el" href="group__apigroup__api.html#gadd64c2d584f0cab2498c784c9451d85e">TSLDeclutterStatusResultEnum</a> *value, const char *dataLayerName, const char *detailLayerName=0)</td></tr>
<tr class="separator:ae61d832cd81e2c7a0ea2fa9744aec16a inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d31320e6500e887e85cc4a95e19c198 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a0d31320e6500e887e85cc4a95e19c198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_dynamic_renderer.html">TSLDynamicRenderer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a0d31320e6500e887e85cc4a95e19c198">getDynamicRenderer</a> (TSLFeatureID featureID=-1, const char *layerName=0)</td></tr>
<tr class="separator:a0d31320e6500e887e85cc4a95e19c198 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b26948542c04c89ed561e953ba0e3a inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a80b26948542c04c89ed561e953ba0e3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a80b26948542c04c89ed561e953ba0e3a">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a> attribute, int *result) const</td></tr>
<tr class="separator:a80b26948542c04c89ed561e953ba0e3a inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4df913acb00ac825e165e5c71fdf73 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a8c4df913acb00ac825e165e5c71fdf73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a8c4df913acb00ac825e165e5c71fdf73">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a> attribute, double *result) const</td></tr>
<tr class="separator:a8c4df913acb00ac825e165e5c71fdf73 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4248cc44247ca3696199db1b2913b5 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a0b4248cc44247ca3696199db1b2913b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a0b4248cc44247ca3696199db1b2913b5">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a> attribute, bool *result) const</td></tr>
<tr class="separator:a0b4248cc44247ca3696199db1b2913b5 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13420230fd95cafe4f7829a49ffa2b07 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a13420230fd95cafe4f7829a49ffa2b07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a13420230fd95cafe4f7829a49ffa2b07">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *result) const</td></tr>
<tr class="separator:a13420230fd95cafe4f7829a49ffa2b07 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef0f78c36be8c30078671de5f56e2a1 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_acef0f78c36be8c30078671de5f56e2a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#acef0f78c36be8c30078671de5f56e2a1">getNumDataLayers</a> () const</td></tr>
<tr class="separator:acef0f78c36be8c30078671de5f56e2a1 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a03a127eeee2f9c9a8fed466a7e5edd inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a0a03a127eeee2f9c9a8fed466a7e5edd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a0a03a127eeee2f9c9a8fed466a7e5edd">getOption</a> (<a class="el" href="group__apigroup__api.html#ga28a256688c01415721a7700d84fa55bd">TSLOptionEnum</a> option)</td></tr>
<tr class="separator:a0a03a127eeee2f9c9a8fed466a7e5edd inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a0fb6b5f0ac7270b4f321822897192 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a07a0fb6b5f0ac7270b4f321822897192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a07a0fb6b5f0ac7270b4f321822897192">id</a> (int id_)</td></tr>
<tr class="separator:a07a0fb6b5f0ac7270b4f321822897192 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41229ebf8a2a4e0e1639616d7a8efffd inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a41229ebf8a2a4e0e1639616d7a8efffd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a41229ebf8a2a4e0e1639616d7a8efffd">id</a> () const</td></tr>
<tr class="separator:a41229ebf8a2a4e0e1639616d7a8efffd inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fb9812a2e699c06d1aa787787f9ad6 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a18fb9812a2e699c06d1aa787787f9ad6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a18fb9812a2e699c06d1aa787787f9ad6">idleProcess</a> ()</td></tr>
<tr class="separator:a18fb9812a2e699c06d1aa787787f9ad6 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8e4094017e7699433efa30fdbbde9b inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a5f8e4094017e7699433efa30fdbbde9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a5f8e4094017e7699433efa30fdbbde9b">loadDeclutter</a> (const char *filename)</td></tr>
<tr class="separator:a5f8e4094017e7699433efa30fdbbde9b inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337cadfa02f94128a8f90a82083292fa inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a337cadfa02f94128a8f90a82083292fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a337cadfa02f94128a8f90a82083292fa">loadRendering</a> (const char *filename)</td></tr>
<tr class="separator:a337cadfa02f94128a8f90a82083292fa inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4585d14f142c6517ddbe21c72cca8f7 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ac4585d14f142c6517ddbe21c72cca8f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_pick_result_set.html">TSLPickResultSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ac4585d14f142c6517ddbe21c72cca8f7">pick</a> (TSLDeviceUnits x, TSLDeviceUnits y, TSLDeviceUnits aperture, int depth, <a class="el" href="class_t_s_l_pick_selector.html">TSLPickSelector</a> *selector=0)</td></tr>
<tr class="separator:ac4585d14f142c6517ddbe21c72cca8f7 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ab561be1f46b9cc34cdd5d9fc42664 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ad0ab561be1f46b9cc34cdd5d9fc42664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_pick_result_set.html">TSLPickResultSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ad0ab561be1f46b9cc34cdd5d9fc42664">pick</a> (const char *data_id, TSLDeviceUnits x, TSLDeviceUnits y, TSLDeviceUnits aperture, int depth=-1, <a class="el" href="class_t_s_l_pick_selector.html">TSLPickSelector</a> *selector=0)</td></tr>
<tr class="separator:ad0ab561be1f46b9cc34cdd5d9fc42664 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b56d4ff2cebea8e1606d4554d9c18c4 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a4b56d4ff2cebea8e1606d4554d9c18c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a4b56d4ff2cebea8e1606d4554d9c18c4">queryActiveLayer</a> (const char *data_id, char *detail_layer_name, int detail_layer_name_size)</td></tr>
<tr class="separator:a4b56d4ff2cebea8e1606d4554d9c18c4 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035ee62299073d81104620eb96ee8d58 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a035ee62299073d81104620eb96ee8d58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a035ee62299073d81104620eb96ee8d58">removeDataLayer</a> (const char *data_id)</td></tr>
<tr class="separator:a035ee62299073d81104620eb96ee8d58 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dda3044708be3978cb05fb57bf23b4 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a82dda3044708be3978cb05fb57bf23b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a82dda3044708be3978cb05fb57bf23b4">saveDeclutter</a> (const char *filename, <a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a> ver=<a class="el" href="group__apigroup__common.html#gga8141b1e165228e088c49024076e13758a0ecdea6c91f1d3104d6166d69b57c88d">TSL_CURRENT_MAPLINK_VERSION</a>)</td></tr>
<tr class="separator:a82dda3044708be3978cb05fb57bf23b4 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b70a8a01f666ecd5fa6ebe04feed246 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a4b70a8a01f666ecd5fa6ebe04feed246"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a4b70a8a01f666ecd5fa6ebe04feed246">saveRendering</a> (const char *filename, <a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a> ver=<a class="el" href="group__apigroup__common.html#gga8141b1e165228e088c49024076e13758a0ecdea6c91f1d3104d6166d69b57c88d">TSL_CURRENT_MAPLINK_VERSION</a>)</td></tr>
<tr class="separator:a4b70a8a01f666ecd5fa6ebe04feed246 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12641ebccfa6b934b66b47dacf0d6e4f inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a12641ebccfa6b934b66b47dacf0d6e4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a12641ebccfa6b934b66b47dacf0d6e4f">sendToBack</a> (const char *move_data_layer)</td></tr>
<tr class="separator:a12641ebccfa6b934b66b47dacf0d6e4f inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4862277014463d564f9b3a64bb1f32e9 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a4862277014463d564f9b3a64bb1f32e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a4862277014463d564f9b3a64bb1f32e9">sendToBackOf</a> (const char *move_data_layer, const char *target_data_layer)</td></tr>
<tr class="separator:a4862277014463d564f9b3a64bb1f32e9 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e4919227d150a0aa99fc135ea032ee inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a17e4919227d150a0aa99fc135ea032ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a17e4919227d150a0aa99fc135ea032ee">setBackgroundColour</a> (int value)</td></tr>
<tr class="separator:a17e4919227d150a0aa99fc135ea032ee inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6f63130d3fbb377eec5c56d2d68cea inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a0b6f63130d3fbb377eec5c56d2d68cea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a0b6f63130d3fbb377eec5c56d2d68cea">setCoordinateProvidingLayer</a> (const char *layer_name)</td></tr>
<tr class="separator:a0b6f63130d3fbb377eec5c56d2d68cea inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe537ed2746b65ecf6349f9efd967173 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_afe537ed2746b65ecf6349f9efd967173"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#afe537ed2746b65ecf6349f9efd967173">setDataLayerProps</a> (const char *data_id, <a class="el" href="group__apigroup__api.html#ga1c467581ddf31341ac6acf6baa297a9a">TSLPropertyEnum</a> property_id, TSLPropertyValue new_value)</td></tr>
<tr class="separator:afe537ed2746b65ecf6349f9efd967173 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1652a09b42b30587627b88c83ac0ecec inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a1652a09b42b30587627b88c83ac0ecec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a1652a09b42b30587627b88c83ac0ecec">setDeclutterStatus</a> (const char *feature_name, <a class="el" href="group__apigroup__api.html#gababcf35d0e42f024d8d93535c70bf928">TSLDeclutterStatusEnum</a> value, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:a1652a09b42b30587627b88c83ac0ecec inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b777dcbefd270725084ff917384de5 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a59b777dcbefd270725084ff917384de5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a59b777dcbefd270725084ff917384de5">setDeclutterStatus</a> (TSLFeatureID feature_id, <a class="el" href="group__apigroup__api.html#gababcf35d0e42f024d8d93535c70bf928">TSLDeclutterStatusEnum</a> value, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:a59b777dcbefd270725084ff917384de5 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1edf066975321c7cd825af58beb1d4 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a7e1edf066975321c7cd825af58beb1d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a7e1edf066975321c7cd825af58beb1d4">setDeclutterStatusOnAllFeatures</a> (<a class="el" href="group__apigroup__api.html#gababcf35d0e42f024d8d93535c70bf928">TSLDeclutterStatusEnum</a> value, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:a7e1edf066975321c7cd825af58beb1d4 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad28bc4cacd259f533cd6b6d31baff5f inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_aad28bc4cacd259f533cd6b6d31baff5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#aad28bc4cacd259f533cd6b6d31baff5f">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a> attribute, int value)</td></tr>
<tr class="separator:aad28bc4cacd259f533cd6b6d31baff5f inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843e54b936b459e6dfecf49543665bfa inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a843e54b936b459e6dfecf49543665bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a843e54b936b459e6dfecf49543665bfa">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a> attribute, double value)</td></tr>
<tr class="separator:a843e54b936b459e6dfecf49543665bfa inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d01bf5edd3a7f32f012a5b9a852cad1 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a6d01bf5edd3a7f32f012a5b9a852cad1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a6d01bf5edd3a7f32f012a5b9a852cad1">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a> attribute, bool value)</td></tr>
<tr class="separator:a6d01bf5edd3a7f32f012a5b9a852cad1 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e00cc9c70d5fbef37124d4e309ab00c inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a6e00cc9c70d5fbef37124d4e309ab00c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a6e00cc9c70d5fbef37124d4e309ab00c">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *value)</td></tr>
<tr class="separator:a6e00cc9c70d5fbef37124d4e309ab00c inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14d30f7088fab43c1f816d823d1955b inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ae14d30f7088fab43c1f816d823d1955b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ae14d30f7088fab43c1f816d823d1955b">setFrame</a> (int style, int colour, int thickness)</td></tr>
<tr class="separator:ae14d30f7088fab43c1f816d823d1955b inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f53b83793beb451d1dd7be0f3303d8 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a11f53b83793beb451d1dd7be0f3303d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a11f53b83793beb451d1dd7be0f3303d8">setOption</a> (<a class="el" href="group__apigroup__api.html#ga28a256688c01415721a7700d84fa55bd">TSLOptionEnum</a> option, bool value)</td></tr>
<tr class="separator:a11f53b83793beb451d1dd7be0f3303d8 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3c2bc3e7e95b72564a91c16f046cfd inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_adb3c2bc3e7e95b72564a91c16f046cfd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#adb3c2bc3e7e95b72564a91c16f046cfd">TMCperMU</a> ()</td></tr>
<tr class="separator:adb3c2bc3e7e95b72564a91c16f046cfd inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dadd653096a1f0cb6fb49a2a08ebf6b inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a5dadd653096a1f0cb6fb49a2a08ebf6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apigroup__api.html#ga76e1969f4b1b3d601f72cf5936520601">TSLDrawingSurfaceTypeEnum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a5dadd653096a1f0cb6fb49a2a08ebf6b">type</a> () const</td></tr>
<tr class="separator:a5dadd653096a1f0cb6fb49a2a08ebf6b inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de924d9df6935f26a9e3bee9d59253a inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a1de924d9df6935f26a9e3bee9d59253a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a1de924d9df6935f26a9e3bee9d59253a">userWord</a> (void *ptr) const</td></tr>
<tr class="separator:a1de924d9df6935f26a9e3bee9d59253a inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba63d2164415f471b835402054095de inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a2ba63d2164415f471b835402054095de"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a2ba63d2164415f471b835402054095de">userWord</a> () const</td></tr>
<tr class="separator:a2ba63d2164415f471b835402054095de inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca53495ddd20981f1ff20b3f4972b17 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a8ca53495ddd20981f1ff20b3f4972b17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a8ca53495ddd20981f1ff20b3f4972b17">cloneDynamicRenderersFrom</a> (const <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> *otherSurface)</td></tr>
<tr class="separator:a8ca53495ddd20981f1ff20b3f4972b17 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a5591424a0629788811bca54086242 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a58a5591424a0629788811bca54086242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a58a5591424a0629788811bca54086242">addDuplicateLayers</a> (bool value)</td></tr>
<tr class="separator:a58a5591424a0629788811bca54086242 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6867615c69a56a04cf0d742233ffd4b2 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a6867615c69a56a04cf0d742233ffd4b2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a6867615c69a56a04cf0d742233ffd4b2">~TSLDrawingSurfaceBase</a> ()</td></tr>
<tr class="separator:a6867615c69a56a04cf0d742233ffd4b2 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1856e3df51781fb80a1e85613fb99b90" id="r_a1856e3df51781fb80a1e85613fb99b90"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1856e3df51781fb80a1e85613fb99b90">cleanup</a> ()</td></tr>
<tr class="separator:a1856e3df51781fb80a1e85613fb99b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8772169e0c0c790b31b27dc334c749ea" id="r_a8772169e0c0c790b31b27dc334c749ea"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8772169e0c0c790b31b27dc334c749ea">copy</a> (<a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *copyTo, <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *copyFrom, bool copyUserData=false)</td></tr>
<tr class="separator:a8772169e0c0c790b31b27dc334c749ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a964579c2078caf7fd785ae5ca59590" id="r_a1a964579c2078caf7fd785ae5ca59590"><td class="memItemLeft" align="right" valign="top">static TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a964579c2078caf7fd785ae5ca59590">getIDOfNearestColour</a> (int r, int g, int b)</td></tr>
<tr class="separator:a1a964579c2078caf7fd785ae5ca59590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa311653bc595b8f619483d097bc91fe2" id="r_aa311653bc595b8f619483d097bc91fe2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa311653bc595b8f619483d097bc91fe2">loadStandardConfig</a> (const char *path=0, bool delayLoadIncludes=false)</td></tr>
<tr class="separator:aa311653bc595b8f619483d097bc91fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b9dd3cf9821d65515a1d23d3f9cecc" id="r_a36b9dd3cf9821d65515a1d23d3f9cecc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36b9dd3cf9821d65515a1d23d3f9cecc">setupColours</a> (const char *filename)</td></tr>
<tr class="separator:a36b9dd3cf9821d65515a1d23d3f9cecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa170198d571f4d15d556412e149a4080" id="r_aa170198d571f4d15d556412e149a4080"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa170198d571f4d15d556412e149a4080">setupFillStyles</a> (const char *filename, bool delayLoadIncludes=false)</td></tr>
<tr class="separator:aa170198d571f4d15d556412e149a4080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046b8114dfb56a9d09f85dcb7716479d" id="r_a046b8114dfb56a9d09f85dcb7716479d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a046b8114dfb56a9d09f85dcb7716479d">setupFonts</a> (const char *filename, bool delayLoadIncludes=false)</td></tr>
<tr class="separator:a046b8114dfb56a9d09f85dcb7716479d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeda81868b934c3a05a71cfa3c5bc611" id="r_afeda81868b934c3a05a71cfa3c5bc611"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afeda81868b934c3a05a71cfa3c5bc611">setupLineStyles</a> (const char *filename, bool delayLoadIncludes=false)</td></tr>
<tr class="separator:afeda81868b934c3a05a71cfa3c5bc611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98418e65bfd9026740db3c77abf260d0" id="r_a98418e65bfd9026740db3c77abf260d0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98418e65bfd9026740db3c77abf260d0">setupSymbols</a> (const char *filename, bool delayLoadIncludes=false)</td></tr>
<tr class="separator:a98418e65bfd9026740db3c77abf260d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91d7d50cada7a5626bd58e597a15f18" id="r_aa91d7d50cada7a5626bd58e597a15f18"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa91d7d50cada7a5626bd58e597a15f18">disableAntiAliasFonts</a> ()</td></tr>
<tr class="separator:aa91d7d50cada7a5626bd58e597a15f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ec24d8d55cd08c24e1409997950a89" id="r_a42ec24d8d55cd08c24e1409997950a89"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42ec24d8d55cd08c24e1409997950a89">enableAntiAliasFonts</a> ()</td></tr>
<tr class="separator:a42ec24d8d55cd08c24e1409997950a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_t_s_l_drawing_surface_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_class_t_s_l_drawing_surface_base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a></td></tr>
<tr class="memitem:aed9a67d3faea852e71e981ba5550b10e inherit pub_static_methods_class_t_s_l_drawing_surface_base" id="r_aed9a67d3faea852e71e981ba5550b10e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#aed9a67d3faea852e71e981ba5550b10e">addLoader</a> (<a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *loader)</td></tr>
<tr class="separator:aed9a67d3faea852e71e981ba5550b10e inherit pub_static_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d868cc316b91af4b7ad52e07b0ebde0 inherit pub_static_methods_class_t_s_l_drawing_surface_base" id="r_a8d868cc316b91af4b7ad52e07b0ebde0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a8d868cc316b91af4b7ad52e07b0ebde0">addPathList</a> (<a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> *path_list)</td></tr>
<tr class="separator:a8d868cc316b91af4b7ad52e07b0ebde0 inherit pub_static_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d9c0144fcd50dd472f4a4aa01852e4 inherit pub_static_methods_class_t_s_l_drawing_surface_base" id="r_ab2d9c0144fcd50dd472f4a4aa01852e4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ab2d9c0144fcd50dd472f4a4aa01852e4">findFile</a> (const char *filename, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;foundPath)</td></tr>
<tr class="separator:ab2d9c0144fcd50dd472f4a4aa01852e4 inherit pub_static_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7feaa515d8d97a663bfe2e11d71d893 inherit pub_static_methods_class_t_s_l_drawing_surface_base" id="r_ad7feaa515d8d97a663bfe2e11d71d893"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ad7feaa515d8d97a663bfe2e11d71d893">getLoader</a> ()</td></tr>
<tr class="separator:ad7feaa515d8d97a663bfe2e11d71d893 inherit pub_static_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_methods_class_t_s_l_drawing_surface_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_class_t_s_l_drawing_surface_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a></td></tr>
<tr class="memitem:affbc1d90c399f996a0cf64dcbbcde711 inherit pro_methods_class_t_s_l_drawing_surface_base" id="r_affbc1d90c399f996a0cf64dcbbcde711"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#affbc1d90c399f996a0cf64dcbbcde711">TSLDrawingSurfaceBase</a> ()</td></tr>
<tr class="separator:affbc1d90c399f996a0cf64dcbbcde711 inherit pro_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_t_s_l_drawing_surface_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_class_t_s_l_drawing_surface_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a></td></tr>
<tr class="memitem:a06d217cc978c3dd7d7838602a74b8041 inherit pro_attribs_class_t_s_l_drawing_surface_base" id="r_a06d217cc978c3dd7d7838602a74b8041"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a06d217cc978c3dd7d7838602a74b8041">m_classID</a></td></tr>
<tr class="separator:a06d217cc978c3dd7d7838602a74b8041 inherit pro_attribs_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="af30e410f6da8fb2f7c1b1c3ac570c0b7" name="af30e410f6da8fb2f7c1b1c3ac570c0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30e410f6da8fb2f7c1b1c3ac570c0b7">&#9670;&#160;</a></span>TSLDrawingSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLDrawingSurface::TSLDrawingSurface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19a5f72960f6f6184d429ae5cbbc99f0" name="a19a5f72960f6f6184d429ae5cbbc99f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a5f72960f6f6184d429ae5cbbc99f0">&#9670;&#160;</a></span>~TSLDrawingSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TSLDrawingSurface::~TSLDrawingSurface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1856e3df51781fb80a1e85613fb99b90" name="a1856e3df51781fb80a1e85613fb99b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1856e3df51781fb80a1e85613fb99b90">&#9670;&#160;</a></span>cleanup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TSLDrawingSurface::cleanup </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free configuration settings.</p>
<p>This method should be called once before exiting the application which instanciates any number of TSLDrawingSurfaces. It will perform a full memory clean on all objects statically created by the application when setting it up, including any memory allocated during the setupFonts/Colours/Fillstyles/Linestyles/Symbols calls.</p>
<dl class="section note"><dt>Note</dt><dd>This method cleans up static data and should only be called on exit. Calling at any other time and subsequently using MapLink may cause a crash.</dd></dl>
<p>This method is designed to minimise the close down messages from Visual Studio which are in this case false positives. </p>

</div>
</div>
<a id="a0265147d1b95af2e58dba9044794e7ad" name="a0265147d1b95af2e58dba9044794e7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0265147d1b95af2e58dba9044794e7ad">&#9670;&#160;</a></span>clearAllRendering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::clearAllRendering </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeaf31e090d3f2a5d7fd9f009b19c53fe" name="aeaf31e090d3f2a5d7fd9f009b19c53fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaf31e090d3f2a5d7fd9f009b19c53fe">&#9670;&#160;</a></span>clearDynamicColours()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::clearDynamicColours </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the dynamic colour list.</p>
<p>Returns true on success, false otherwise. </p>

</div>
</div>
<a id="a15fdbce18a41087bc8240fcf807050ce" name="a15fdbce18a41087bc8240fcf807050ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fdbce18a41087bc8240fcf807050ce">&#9670;&#160;</a></span>clearFillList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurface::clearFillList </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the dynamic fill list - Future Enhancement </p>

</div>
</div>
<a id="a824eeb7f498f27ee606cf6858d0c8b3b" name="a824eeb7f498f27ee606cf6858d0c8b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824eeb7f498f27ee606cf6858d0c8b3b">&#9670;&#160;</a></span>clearFontList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurface::clearFontList </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the dynamic font list - Future Enhancement </p>

</div>
</div>
<a id="a396aa24cca72491d62ec7b6f379da219" name="a396aa24cca72491d62ec7b6f379da219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396aa24cca72491d62ec7b6f379da219">&#9670;&#160;</a></span>clearLineList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurface::clearLineList </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the dynamic line list - Future Enhancement </p>

</div>
</div>
<a id="a01a09056395ae216959f9cdab30d7744" name="a01a09056395ae216959f9cdab30d7744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01a09056395ae216959f9cdab30d7744">&#9670;&#160;</a></span>clearSymbolList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurface::clearSymbolList </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Future Enhancements Do Not Use. Clear the dynamic symbol list - Future Enhancement </p>

</div>
</div>
<a id="a2e495c3693a20a9c7bacd180d9e9e452" name="a2e495c3693a20a9c7bacd180d9e9e452"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e495c3693a20a9c7bacd180d9e9e452">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> * TSLDrawingSurface::clone </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>copyUserData</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method clones the drawing surface and creates another drawing surface which reference the same data layers, data layer properties, options and coordinate system configuration.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copyUserData</td><td>If true, the userID and userWord will be copied to the new surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new cloned drawing surface, NULL on error. </dd></dl>

<p>Implemented in <a class="el" href="class_t_s_l_d_x_accelerated_surface.html#a4eac769d857ae44c29944f73209cfc98">TSLDXAcceleratedSurface</a>, <a class="el" href="class_t_s_l_motif_surface.html#a4a98487cc9c796459b3ec691eb8bd273">TSLMotifSurface</a>, <a class="el" href="class_t_s_l_n_t_surface.html#aee0fae77ee08980355723d05d84beed2">TSLNTSurface</a>, <a class="el" href="class_t_s_l_open_g_l_surface.html#a66f323a8671c859ea87dd71b66e44be6">TSLOpenGLSurface</a>, <a class="el" href="class_t_s_l_w_g_l_accelerated_surface.html#a4ecdc7ac63f27490fc0be49d01576cb9">TSLWGLAcceleratedSurface</a>, and <a class="el" href="class_t_s_l_x11_g_l_accelerated_surface.html#a4e47a607bda6720bbd76a9d37ffd8787">TSLX11GLAcceleratedSurface</a>.</p>

</div>
</div>
<a id="a8772169e0c0c790b31b27dc334c749ea" name="a8772169e0c0c790b31b27dc334c749ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8772169e0c0c790b31b27dc334c749ea">&#9670;&#160;</a></span>copy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLDrawingSurface::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *</td>          <td class="paramname"><span class="paramname"><em>copyTo</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *</td>          <td class="paramname"><span class="paramname"><em>copyFrom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>copyUserData</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copies the contents of the drawing surface from 'copyFrom' to 'copyTo'.</p>
<p>The copy does not copy any HDC, HWND, Display* etc... settings.</p>
<p>The perceived purpose of this method is for printing surfaces which do not support printing.</p>
<p>The copy is not a deep copy as it takes references to the layers.</p>
<p>The copy does not copy any dynamic resources.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">copyTo</td><td>Drawing Surface to copy too.</td></tr>
    <tr><td class="paramname">copyFrom</td><td>Drawing Surface to copy from.</td></tr>
    <tr><td class="paramname">copyUserData</td><td>If true, the userID and userWord will be copied to the new surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a946c15e83276c2a5d308efb701062c18" name="a946c15e83276c2a5d308efb701062c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946c15e83276c2a5d308efb701062c18">&#9670;&#160;</a></span>createFontID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLStyleID TSLDrawingSurface::createFontID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFontType</td>          <td class="paramname"><span class="paramname"><em>meaningOfName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>fontWeight</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>italic</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>underline</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>antiAliased</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>memoryBlock</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLSize</td>          <td class="paramname"><span class="paramname"><em>memoryBlockSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Font-style - Future Enhancement </p>

</div>
</div>
<a id="a5fb63ecf6e6e4c00abaf2136b1ccb79c" name="a5fb63ecf6e6e4c00abaf2136b1ccb79c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb63ecf6e6e4c00abaf2136b1ccb79c">&#9670;&#160;</a></span>createFontSymbolID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLStyleID TSLDrawingSurface::createFontSymbolID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFontType</td>          <td class="paramname"><span class="paramname"><em>meaningOfName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>memoryBlock</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLSize</td>          <td class="paramname"><span class="paramname"><em>memoryBlockSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Symbol-style - Future Enhancement </p>

</div>
</div>
<a id="a471fe3d0a6601709cb7add89ce78c8a8" name="a471fe3d0a6601709cb7add89ce78c8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a471fe3d0a6601709cb7add89ce78c8a8">&#9670;&#160;</a></span>createRasterBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_raster_buffer.html">TSLRasterBuffer</a> * TSLDrawingSurface::createRasterBuffer </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>width</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>height</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_raster_buffer.html#a1fafd2ab8f125b29ddceb5a2aaa91f7e">TSLRasterBuffer::Format</a></td>          <td class="paramname"><span class="paramname"><em>format</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_raster_buffer.html#a02b2cc2b1da9b354c4a40466d650cf24">TSLRasterBuffer::FilterMode</a></td>          <td class="paramname"><span class="paramname"><em>filterMode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_t_s_l_raster_buffer.html#a02b2cc2b1da9b354c4a40466d650cf24a91eaf68f9a0200a02757022d9d863dae">TSLRasterBuffer::Linear</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new object that can be used to draw rasters to a MapLink drawing surface through the <a class="el" href="class_t_s_l_rendering_interface.html">TSLRenderingInterface</a>. For details on how to use the returned object refer to the class documentation for <a class="el" href="class_t_s_l_raster_buffer.html">TSLRasterBuffer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">width</td><td>The width in pixels of the raster to create.</td></tr>
    <tr><td class="paramname">height</td><td>The height in pixels of the raster to create.</td></tr>
    <tr><td class="paramname">format</td><td>The image format to use for the raster.</td></tr>
    <tr><td class="paramname">filterMode</td><td>The filtering mode to use when drawing the raster at a different resolution to the underlying image data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72399f3239a3b10e121069a0dbed6bb2" name="a72399f3239a3b10e121069a0dbed6bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72399f3239a3b10e121069a0dbed6bb2">&#9670;&#160;</a></span>createRasterSymbolID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLStyleID TSLDrawingSurface::createRasterSymbolID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>xorigin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>yorigin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>scaleable</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>memoryBlock</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLSize</td>          <td class="paramname"><span class="paramname"><em>memoryBlockSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Symbol-style - Future Enhancement </p>

</div>
</div>
<a id="a69a2d9eed2a9376eeca1d7ee7c1d6d2f" name="a69a2d9eed2a9376eeca1d7ee7c1d6d2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a2d9eed2a9376eeca1d7ee7c1d6d2f">&#9670;&#160;</a></span>createStandardFillID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLStyleID TSLDrawingSurface::createStandardFillID </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLSize</td>          <td class="paramname"><span class="paramname"><em>patternSizeInBytes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>patternXSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>patternYSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Fill-style - Future Enhancement </p>

</div>
</div>
<a id="af5e5fda0f85949120c75f961c35be4b3" name="af5e5fda0f85949120c75f961c35be4b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e5fda0f85949120c75f961c35be4b3">&#9670;&#160;</a></span>createStandardLineID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLStyleID TSLDrawingSurface::createStandardLineID </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>pattern</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLSize</td>          <td class="paramname"><span class="paramname"><em>patternLength</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>initialOffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLLineScalingType</td>          <td class="paramname"><span class="paramname"><em>scaleType</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Line-style - Future Enhancement </p>

</div>
</div>
<a id="adbce81dc062e8f57bbeed7f994499421" name="adbce81dc062e8f57bbeed7f994499421"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbce81dc062e8f57bbeed7f994499421">&#9670;&#160;</a></span>createSVGSymbolID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLStyleID TSLDrawingSurface::createSVGSymbolID </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>memoryBlock</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLSize</td>          <td class="paramname"><span class="paramname"><em>memoryBlockSize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Symbol-style - Future Enhancement - not implemented </p>

</div>
</div>
<a id="a3c125151569f85aa2d1dd3eb4cb6d893" name="a3c125151569f85aa2d1dd3eb4cb6d893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c125151569f85aa2d1dd3eb4cb6d893">&#9670;&#160;</a></span>createSymbolFillID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLStyleID TSLDrawingSurface::createSymbolFillID </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>symbolID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#ga575681bd39e0be106648609e4958788c">TSLDimensionUnits</a></td>          <td class="paramname"><span class="paramname"><em>sizeUnits</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__apigroup__geometry__api.html#gga575681bd39e0be106648609e4958788cae841a878e751716330b78e01d1f7b0b1">TSLDimensionUnitsUndefined</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rotation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>anchorPointX</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>anchorPointY</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#ga575681bd39e0be106648609e4958788c">TSLDimensionUnits</a></td>          <td class="paramname"><span class="paramname"><em>anchorPointUnits</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__apigroup__geometry__api.html#gga575681bd39e0be106648609e4958788cae841a878e751716330b78e01d1f7b0b1">TSLDimensionUnitsUndefined</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Fill-style - Future Enhancement - not implemented </p>

</div>
</div>
<a id="a6ab0a60b674c19e504b6e85e04f7937a" name="a6ab0a60b674c19e504b6e85e04f7937a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab0a60b674c19e504b6e85e04f7937a">&#9670;&#160;</a></span>createSymbolIDFromSymbol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLStyleID TSLDrawingSurface::createSymbolIDFromSymbol </td>
          <td>(</td>
          <td class="paramtype">TSLStyleID</td>          <td class="paramname"><span class="paramname"><em>symbolID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numberofColourPairs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>colourFrom</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *</td>          <td class="paramname"><span class="paramname"><em>colourTo</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Symbol-style - Future Enhancement - not implemented </p>

</div>
</div>
<a id="ad0b86b6973e62cdd0a1ca4a244328c32" name="ad0b86b6973e62cdd0a1ca4a244328c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b86b6973e62cdd0a1ca4a244328c32">&#9670;&#160;</a></span>createSymbolLineID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLStyleID TSLDrawingSurface::createSymbolLineID </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>symbolID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>size</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#ga575681bd39e0be106648609e4958788c">TSLDimensionUnits</a></td>          <td class="paramname"><span class="paramname"><em>sizeUnits</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__apigroup__geometry__api.html#gga575681bd39e0be106648609e4958788cae841a878e751716330b78e01d1f7b0b1">TSLDimensionUnitsUndefined</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float</td>          <td class="paramname"><span class="paramname"><em>rotation</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0f</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>anchorPointX</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>anchorPointY</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#ga575681bd39e0be106648609e4958788c">TSLDimensionUnits</a></td>          <td class="paramname"><span class="paramname"><em>anchorPointUnits</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__apigroup__geometry__api.html#gga575681bd39e0be106648609e4958788cae841a878e751716330b78e01d1f7b0b1">TSLDimensionUnitsUndefined</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a Line-style - Future Enhancement - not implemented </p>

</div>
</div>
<a id="a206fed500549fb011a7e64d391273899" name="a206fed500549fb011a7e64d391273899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a206fed500549fb011a7e64d391273899">&#9670;&#160;</a></span>declutterIsVisible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::declutterIsVisible </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>feature_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>resolution</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layer_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query for feature visibility at specified resolution on specified layer.</p>
<p>This method allows the user to query whether the feature defined by the input parameter feature_name, is visible at the resolution specified by the input parameter resolution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature_name</td><td>Name of the feature being queried.</td></tr>
    <tr><td class="paramname">resolution</td><td>User units per device unit. 0.0 may be used to specify the current screen resolution.</td></tr>
    <tr><td class="paramname">layer_name</td><td>: The data layer to set the decluttering value for. If the name supplied does not match a loaded layer then this will fail, returning true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>This method true if the feature would be visible at the specified resolution or if no declutter information is found for this feature. Returns false if it is not visible. </dd></dl>

</div>
</div>
<a id="aa91d7d50cada7a5626bd58e597a15f18" name="aa91d7d50cada7a5626bd58e597a15f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa91d7d50cada7a5626bd58e597a15f18">&#9670;&#160;</a></span>disableAntiAliasFonts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TSLDrawingSurface::disableAntiAliasFonts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Disable anti-aliasing of fonts on the GDI drawing surface</p>
<p>Calling this method will disable font anti-aliasing in all instances of the <a class="el" href="class_t_s_l_n_t_surface.html">TSLNTSurface</a> This change will persist until the application terminates, or calls <a class="el" href="#a42ec24d8d55cd08c24e1409997950a89">enableAntiAliasFonts()</a>. </p>

</div>
</div>
<a id="a9dbaf1905aaff87cfb59d77caa722e34" name="a9dbaf1905aaff87cfb59d77caa722e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dbaf1905aaff87cfb59d77caa722e34">&#9670;&#160;</a></span>drawDU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::drawDU </td>
          <td>(</td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clear</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>updateExtentOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draw area of map onto drawing surface.</p>
<p>This method requests the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> to redraw the MapLink data within the area defined by the input co-ordinates. This method may be called whenever a part of the Drawing Surface has been exposed through some action.</p>
<p>Note, this method will only redraw the primitives if the view or decluttering have changed, or if any of the data layers have been notified as changed. If the drawing surface is double buffered, the attached TSLDataLayers are drawn into the double buffer and then the double buffer is written to the window handle. Any layer buffering is also taken into account.</p>
<p>If an individual TSLDatalayer is double buffered, and the user unit extent of the Drawing Surface has not changed, then the existing double buffer is copied to the attached window handle. If the user unit extent has changed, then the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> is drawn into the double buffer and then the double buffer is written to the window handle.</p>
<p>The updateExtentOnly flag is used to update only certain areas of the screen. Under some circumstances, such as a paint message from Windows, it is necessary to clip the area that is drawn to the window. However, if the window is partially obscured, then any double buffers will only be partially drawn and may thus contain invalid data. If you are certain that only the specified area needs updating then set this flag to true, otherwise set it to false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>x value of bottom left co-ordinate (in device units) of the area to redraw.</td></tr>
    <tr><td class="paramname">y1</td><td>y value of bottom left coordinate (in device units) of the area to redraw.</td></tr>
    <tr><td class="paramname">x2</td><td>x value of top right co-ordinate (in device units) of the area to redraw.</td></tr>
    <tr><td class="paramname">y2</td><td>y value of top right coordinate (in device units) of the area to redraw.</td></tr>
    <tr><td class="paramname">clear</td><td>If true this will clear the specified area before drawing any of the data.</td></tr>
    <tr><td class="paramname">updateExtentOnly</td><td>See drawUU.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="af6c53e5790d1eb3b0b01672050d655d7" name="af6c53e5790d1eb3b0b01672050d655d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c53e5790d1eb3b0b01672050d655d7">&#9670;&#160;</a></span>drawUU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::drawUU </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clear</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>updateExtentOnly</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Draw area of map onto drawing surface.</p>
<p>This method requests the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> to redraw the MapLink data within the area defined by the input co-ordinates. This method may be called whenever a part of the Drawing Surface has been exposed through some action.</p>
<p>Note, this method will only redraw the primitives if the view or decluttering have changed, or if any of the data layers have been notified as changed. If the drawing surface is double buffered, the attached TSLDataLayers are drawn into the double buffer and then the double buffer is written to the window handle. Any layer buffering is also taken into account.</p>
<p>The updateExtentOnly flag is used to update only certain areas of the screen. Under some circumstances, such as a paint message from Windows, it is necessary to clip the area that is drawn to the window. However, if the window is partially obscured, then any double buffers will only be partially drawn and may thus contain invalid data. If you are certain that only the specified area needs updating then set this flag to true, otherwise set it to false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Bottom left co-ordinate (in user-units) of the area to redraw.</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Top right co-ordinate (in user-units) of the area to redraw.</td></tr>
    <tr><td class="paramname">clear</td><td>If true this will clear the specified area before drawing any of the data.</td></tr>
    <tr><td class="paramname">updateExtentOnly</td><td>If true, then the updates to buffers and the window are clipped to the specified extent, otherwise only updates to the window are clipped.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a55958d05038aa959c54f21a03a95a017" name="a55958d05038aa959c54f21a03a95a017"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55958d05038aa959c54f21a03a95a017">&#9670;&#160;</a></span>DUToLatLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::DUToLatLong </td>
          <td>(</td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>latitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>longitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>boundCheck</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from device co-ordinate to latitude/longitude co-ordinate.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y)</td><td>Device unit co-ordinate</td></tr>
    <tr><td class="paramname">(latitude,longitude)</td><td>Storage for lat/lon co-ordinate.</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the lat/lon co-ordinate is in WGS84 or the local datum.</td></tr>
    <tr><td class="paramname">boundCheck</td><td>When the initial coordinates are outside of the map extent, the lat/lon returned could be invalid. When this flag is true, a check for invalid results is performed. This check will double the processing time required by the method, but return a validated status code. If the specified coordinate is guaranteed to be within the map extent, then this flag may be turned off.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a9c5ccbb0dbce745dc1b1352285013e11" name="a9c5ccbb0dbce745dc1b1352285013e11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5ccbb0dbce745dc1b1352285013e11">&#9670;&#160;</a></span>DUToMU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::DUToMU </td>
          <td>(</td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert device unit co-ordinate to map units.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Device unit co-ordinate</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for map unit co-ordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a92256bdb7597267758967a8889c10189" name="a92256bdb7597267758967a8889c10189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92256bdb7597267758967a8889c10189">&#9670;&#160;</a></span>DUToTMC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::DUToTMC </td>
          <td>(</td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert device co-ordinate to internal co-ordinate.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Device co-ordinate.</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for internal co-ordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a9bb8bfb6a862d236426427dcc7bb7de7" name="a9bb8bfb6a862d236426427dcc7bb7de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb8bfb6a862d236426427dcc7bb7de7">&#9670;&#160;</a></span>DUToUU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::DUToUU </td>
          <td>(</td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from device co-ordinate to user unit co-ordinate.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Device unit co-ordinate</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for user unit co-ordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a42ec24d8d55cd08c24e1409997950a89" name="a42ec24d8d55cd08c24e1409997950a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ec24d8d55cd08c24e1409997950a89">&#9670;&#160;</a></span>enableAntiAliasFonts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TSLDrawingSurface::enableAntiAliasFonts </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enable anti-aliasing of fonts on the GDI drawing surface</p>
<p>Calling this method will enable font anti-aliasing in all instances of the <a class="el" href="class_t_s_l_n_t_surface.html">TSLNTSurface</a> This change will persist until the application terminates, or calls <a class="el" href="#aa91d7d50cada7a5626bd58e597a15f18">disableAntiAliasFonts()</a>. </p>

</div>
</div>
<a id="a26fee92015216e73a978cbed135a5771" name="a26fee92015216e73a978cbed135a5771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26fee92015216e73a978cbed135a5771">&#9670;&#160;</a></span>findEntityDU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> * TSLDrawingSurface::findEntityDU </td>
          <td>(</td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>aperture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>feature_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an entity at device unit position.</p>
<p>Note: For simple selection through a user interaction, see <a class="el" href="#aa12f7671255ef058944cb4e2b0d32063">findSelectedEntityDU()</a></p>
<p>This method allows the user to retrieve an entity from any data layer attached to the drawing surface according to a location. The entity search can be refined by setting the last parameter in the argument list to a valid feature name. In this case an entity will be returned only if it belongs to the named feature. Only data layers which are visible and detectable will be searched. Only entities which are not decluttered on the drawing surface will be examined.</p>
<p>The <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> returned is embedded within the tile so should not be destroyed by the user unless it is not required. Note that an entity deleted from a MapDataLayer tile may be reloaded when the tile is removed from the cache.</p>
<p>The search algorithm is as follows:</p>
<ul>
<li>Iterate across visible, detectable data layers in reverse order (ie. from topmost to bottommost)</li>
<li>For map layers, the detail layer that would be used for drawing the aperture extent is used</li>
<li>In each layer, all entities whose last rendered extent overlaps the aperture extent are analysed further<ul>
<li>If a feature name is specified, only entities of that feature name are considered</li>
<li>The analysis goes no deeper into the Entity Set hierarchy than specified below</li>
<li>These entities have the distance to the selection point calculated<ul>
<li>If the point is within a polygon, the distance to the polygon is 0.</li>
<li>If the point is within the last rendered extent of a text or symbol entity, the distance to that entity is 0</li>
</ul>
</li>
<li>If the distance is within the aperture distance then the entity is considered a candidate</li>
<li>The results for a layer are sorted according to distance from the aperture and entity type<ul>
<li>Entity types are sorted according to the following precedence and by distance within each type:<ul>
<li>text</li>
<li>symbol</li>
<li>curves (arc/polylines)</li>
<li>surfaces (ellipse/rect/polygon)</li>
<li>entity sets</li>
</ul>
</li>
<li>This means that text is always considered before symbols, etc.</li>
</ul>
</li>
<li>If any candidate entities are found in a layer, then the first visible entity in the sorted list is returned</li>
<li>If no visible candidate entities are found in a layer, then the next layer is analysed</li>
</ul>
</li>
</ul>
<p>NOTE: When querying an Optimised map the query may return objects that can not be further analysed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,y</td><td>Co-ordinate of the location where to find the entity on the map. These co-ordinates are in device units.</td></tr>
    <tr><td class="paramname">aperture</td><td>This specifies an extent around the location co-ordinate in which to search for the entity. This is in device units.</td></tr>
    <tr><td class="paramname">depth</td><td>Specifies how deep to look before returning a pointer to an object. If the depth is 0 it searches at the highest level in the model (that is it will return a Group rather than an entity within the Group).</td></tr>
    <tr><td class="paramname">feature_name</td><td>If not NULL, only entities of this feature name will be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> if found, NULL otherwise. </dd></dl>

</div>
</div>
<a id="a1c864c485c3eaffa69cccc51fef7711d" name="a1c864c485c3eaffa69cccc51fef7711d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c864c485c3eaffa69cccc51fef7711d">&#9670;&#160;</a></span>findEntityUU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> * TSLDrawingSurface::findEntityUU </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>aperture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>feature_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an entity at user unit position.</p>
<p>This method allows the user to retrieve an entity from any data layer attached to the drawing surface according to a location. The entity search can be refined by setting the last parameter in the argument list to a valid feature name. In this case an entity will be returned only if it belongs to the named feature. Only data layers which are visible and detectable will be searched. Only entities which are not decluttered on the drawing surface will be examined.</p>
<p>The <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> returned is embedded within the tile so should not be destroyed by the user unless it is not required. Note that an entity deleted from a MapDataLayer tile may be reloaded when the tile is removed from the cache.</p>
<p>The search algorithm is as follows :</p>
<ul>
<li>Iterate across visible, detectable data layers in reverse order (ie. from topmost to bottommost)</li>
<li>For map layers, the detail layer that would be used for drawing the aperture extent is used</li>
<li>In each layer, all entities whose last rendered extent overlaps the aperture extent are analysed further<ul>
<li>If a feature name is specified, only entities of that feature name are considered</li>
<li>The analysis goes no deeper into the Entity Set hierarchy than specified below</li>
<li>These entities have the distance to the selection point calculated<ul>
<li>If the point is within a polygon, the distance to the polygon is 0.</li>
<li>If the point is within the last rendered extent of a text or symbol entity, the distance to that entity is 0</li>
</ul>
</li>
<li>If the distance is within the aperture distance then the entity is considered a candidate</li>
<li>The results for a layer are sorted according to distance from the aperture and entity type<ul>
<li>Entity types are sorted according to the following precedence and by distance within each type:<ul>
<li>text</li>
<li>symbol</li>
<li>curves (arc/polylines)</li>
<li>surfaces (ellipse/rect/polygon)</li>
<li>entity sets</li>
</ul>
</li>
<li>This means that text is always considered before symbols, etc.</li>
</ul>
</li>
<li>If any candidate entities are found in a layer, then the first visible entity in the sorted list is returned</li>
<li>If no visible candidate entities are found in a layer, then the next layer is analysed</li>
</ul>
</li>
</ul>
<p>NOTE: When querying an Optimised map the query may return objects that can not be further analysed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,y</td><td>Co-ordinate of the location where to find the entity on the map. These co-ordinates are in user units.</td></tr>
    <tr><td class="paramname">aperture</td><td>This specifies an extent around the location co-ordinate in which to search for the entity. This is in user units.</td></tr>
    <tr><td class="paramname">depth</td><td>Specifies how deep to look before returning a pointer to an object. If the depth is 0 it searches at the highest level in the tile (that is it may return a Group rather than an entity within the Group).</td></tr>
    <tr><td class="paramname">feature_name</td><td>If not NULL, only entities of this feature name will be checked.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> if found, NULL otherwise. </dd></dl>

</div>
</div>
<a id="aa12f7671255ef058944cb4e2b0d32063" name="aa12f7671255ef058944cb4e2b0d32063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa12f7671255ef058944cb4e2b0d32063">&#9670;&#160;</a></span>findSelectedEntityDU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> * TSLDrawingSurface::findSelectedEntityDU </td>
          <td>(</td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>aperture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignoreMapDataLayers</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an entity at device unit position.</p>
<p>This method allows the user to retrieve an entity from any data layer attached to the drawing surface according to a location. Only data layers which are visible and detectable will be searched. Only entities which are not decluttered on the drawing surface will be examined.</p>
<p>The <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> returned may embedded within a map tile so should not be destroyed by the user unless it is not required. Note that an entity deleted from a MapDataLayer tile may be reloaded when the tile is removed from the cache.</p>
<p>The search algorithm is as follows:</p>
<ul>
<li>Iterate across visible, detectable data layers in reverse order (i.e. from topmost to bottommost)</li>
<li>For map layers, the currently display detail layer is used</li>
<li>In each layer, all entities whose last rendered extent overlaps the aperture extent are analysed further<ul>
<li>The analysis goes no deeper into the Entity Set hierarchy than specified below</li>
<li>These entities have the distance to the selection point calculated</li>
<li>The entities are analysed in reverse display order (i.e. from topmost to bottommost)<ul>
<li>If the point is within a polygon, the distance to the polygon is 0.</li>
<li>If the point is within the last rendered extent of a text or symbol entity, the distance to that entity is 0</li>
<li>Note that the extents may be bigger than they appear due to font sizing with text and hidden boundaries in symbols</li>
</ul>
</li>
<li>If the distance is within the aperture distance then the entity is considered a candidate</li>
<li>If the calculated distance is 0 and the object is a surface (polygon/ellipse/rectangle), then the closest entity previously found is returned. If none have been found, then the surface is returned. This allows for selection of objects within a polygon.</li>
<li>Apart from the special surface behaviour, the nearest visible candidate is the layer is returned</li>
<li>If no visible candidate entities are found in a layer, then the next layer is analysed</li>
</ul>
</li>
</ul>
<p>NOTE: When querying an Optimised map the query may return objects that can not be further analysed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,y</td><td>Co-ordinate of the location where to find the entity on the map. These co-ordinates are in device units.</td></tr>
    <tr><td class="paramname">aperture</td><td>This specifies an extent around the location co-ordinate in which to search for the entity. This is in device units.</td></tr>
    <tr><td class="paramname">depth</td><td>Specifies how deep to look before returning a pointer to an object. If the depth is -1 (the default), then all entities are searched regardless of depth. If the depth is 0 it searches at the highest level in the model (that is it will return a Group rather than an entity within the Group).</td></tr>
    <tr><td class="paramname">ignoreMapDataLayers</td><td>If true, then map data layers are ignored, even if detectable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> if found, NULL otherwise. </dd></dl>

</div>
</div>
<a id="a834b6cd5cd46e2e37d28f248cfa32e3f" name="a834b6cd5cd46e2e37d28f248cfa32e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a834b6cd5cd46e2e37d28f248cfa32e3f">&#9670;&#160;</a></span>findSelectedEntityUU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> * TSLDrawingSurface::findSelectedEntityUU </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>aperture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>ignoreMapDataLayers</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an entity at user unit position.</p>
<p>This method allows the user to retrieve an entity from any data layer attached to the drawing surface according to a location. Only data layers which are visible and detectable will be searched. Only entities which are not decluttered on the drawing surface will be examined.</p>
<p>The <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> returned may embedded within a map tile so should not be destroyed by the user unless it is not required. Note that an entity deleted from a MapDataLayer tile may be reloaded when the tile is removed from the cache.</p>
<p>The search algorithm is as follows:</p>
<ul>
<li>Iterate across visible, detectable data layers in reverse order (i.e. from topmost to bottommost)</li>
<li>For map layers, the currently display detail layer is used</li>
<li>In each layer, all entities whose last rendered extent overlaps the aperture extent are analysed further<ul>
<li>The analysis goes no deeper into the Entity Set hierarchy than specified below</li>
<li>These entities have the distance to the selection point calculated</li>
<li>The entities are analysed in reverse display order (i.e. from topmost to bottommost)<ul>
<li>If the point is within a polygon, the distance to the polygon is 0.</li>
<li>If the point is within the last rendered extent of a text or symbol entity, the distance to that entity is 0</li>
<li>Note that the extents may be bigger than they appear due to font sizing with text and hidden boundaries in symbols</li>
</ul>
</li>
<li>If the distance is within the aperture distance then the entity is considered a candidate</li>
<li>If the calculated distance is 0 and the object is a surface (polygon/ellipse/rectangle), then the closest entity previously found is returned. If none have been found, then the surface is returned. This allows for selection of objects within a polygon.</li>
<li>Apart from the special surface behaviour, the nearest visible candidate is the layer is returned</li>
<li>If no visible candidate entities are found in a layer, then the next layer is analysed</li>
</ul>
</li>
</ul>
<p>NOTE: When querying an Optimised map the query may return objects that can not be further analysed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,y</td><td>Co-ordinate of the location where to find the entity on the map. These co-ordinates are in user units.</td></tr>
    <tr><td class="paramname">aperture</td><td>This specifies an extent around the location co-ordinate in which to search for the entity. This is in user units.</td></tr>
    <tr><td class="paramname">depth</td><td>Specifies how deep to look before returning a pointer to an object. If the depth is -1 (the default), then all entities are searched regardless of depth. If the depth is 0 it searches at the highest level in the model (that is it will return a Group rather than an entity within the Group).</td></tr>
    <tr><td class="paramname">ignoreMapDataLayers</td><td>If true, then map data layers are ignored, even if detectable</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> if found, NULL otherwise. </dd></dl>

</div>
</div>
<a id="a088da526a941a7e8b89ce030f7809b2a" name="a088da526a941a7e8b89ce030f7809b2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088da526a941a7e8b89ce030f7809b2a">&#9670;&#160;</a></span>getColourIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::getColourIndices </td>
          <td>(</td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query colour indices.</p>
<p>Queries colour indices specified in the colour file last loaded using setupColours. These indices may be be converted to OS specific handles using the colourValue method. Note that the indices are not necessarily contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Storage for pointer to indices. Populated if successful. The buffer is owned by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> and should not be deleted.</td></tr>
    <tr><td class="paramname">num</td><td>Storage for number of indices in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the arguments were populated, false otherwise. </dd></dl>

</div>
</div>
<a id="a62280c4a00af92d96b697809a45a2ad3" name="a62280c4a00af92d96b697809a45a2ad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62280c4a00af92d96b697809a45a2ad3">&#9670;&#160;</a></span>getCoordinateProvidingLayer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> * TSLDrawingSurface::getCoordinateProvidingLayer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the data layer that defines the coordinate system for the drawing surface. The coordinate system of this layer is used when performing coordinate conversions through the drawing surface (e.g. latLongToMU, MUToTMC).</p>
<p>The coordinate providing layer is normally the first data layer added to the drawing surface that has a <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a>.</p>
<p>If no coordinate providing layer has been added to the drawing surface, this method returns NULL. </p>

</div>
</div>
<a id="a77a5c65d839aa420ceee2c397f629293" name="a77a5c65d839aa420ceee2c397f629293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a5c65d839aa420ceee2c397f629293">&#9670;&#160;</a></span>getCoordinateProvidingLayer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> * TSLDrawingSurface::getCoordinateProvidingLayer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the data layer that defines the coordinate system for the drawing surface. The coordinate system of this layer is used when performing coordinate conversions through the drawing surface (e.g. latLongToMU, MUToTMC).</p>
<p>The coordinate providing layer is normally the first data layer added to the drawing surface that has a <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a>.</p>
<p>If no coordinate providing layer has been added to the drawing surface, this method returns NULL. </p>

</div>
</div>
<a id="a24685986e62832473065717f5d85121b" name="a24685986e62832473065717f5d85121b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24685986e62832473065717f5d85121b">&#9670;&#160;</a></span>getDeclutterRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::getDeclutterRange </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>innerLimit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>outerLimit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dataLayerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>detailLayerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query automatic decluttering range.</p>
<p>This method retrieves the current visibility range for the named feature. This resolution range determines when a feature is visible. The resolution limits returned are valid only if the visibility status of this feature is set to automatic.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of the feature.</td></tr>
    <tr><td class="paramname">innerLimit</td><td>Minimum resolution at which the feature type is visible (user units per device unit), i.e. maximum zoom in.</td></tr>
    <tr><td class="paramname">outerLimit</td><td>Maximum resolution at which the feature type is visible (user units per device unit), i.e. maximum zoom out.</td></tr>
    <tr><td class="paramname">dataLayerName</td><td>The name of the data layer to query. Defaults to 0 i.e. get for all layers.</td></tr>
    <tr><td class="paramname">detailLayerName</td><td>the name of the detail layer to query. Defaults to 0 to query all detail layers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a0b7ca890687234f55c562a6b1cfe9605" name="a0b7ca890687234f55c562a6b1cfe9605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b7ca890687234f55c562a6b1cfe9605">&#9670;&#160;</a></span>getDeviceCapabilities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::getDeviceCapabilities </td>
          <td>(</td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>horizontalSizeMM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>verticalSizeMM</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>horizontalSizePixels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>verticalSizePixels</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the device capabilities as determined by the drawing surface, or as passed to setDeviceCapabilities. For more information on the meaning of these values refer to the documentation for setDeviceCapabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">horizontalSizeMM</td><td>horizontal size of the visible screen in mm.</td></tr>
    <tr><td class="paramname">verticalSizeMM</td><td>vertical size of the visible screen in mm.</td></tr>
    <tr><td class="paramname">horizontalSizePixels</td><td>horizontal size of the screen in pixels.</td></tr>
    <tr><td class="paramname">verticalSizePixels</td><td>vertical size of the screen in pixels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the values were populated, or false if the drawing surface is currently not attached to a device. </dd></dl>

</div>
</div>
<a id="ac16108f4d82547522e368cc6ab1194a7" name="ac16108f4d82547522e368cc6ab1194a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16108f4d82547522e368cc6ab1194a7">&#9670;&#160;</a></span>getDeviceCapabilities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::getDeviceCapabilities </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_device_capabilities.html">TSLDeviceCapabilities</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>capabilities</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the device capabilities as determined by the drawing surface, or as passed to setDeviceCapabilities. For more information on the meaning of these values refer to the documentation for setDeviceCapabilities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capabilities</td><td>Will be populated with the current device capabilities </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the values were populated, or false if the drawing surface is currently not attached to a device. </dd></dl>

</div>
</div>
<a id="a8f1db5a44878ac35f0aedb681000ccf3" name="a8f1db5a44878ac35f0aedb681000ccf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f1db5a44878ac35f0aedb681000ccf3">&#9670;&#160;</a></span>getDUExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurface::getDUExtent </td>
          <td>(</td>
          <td class="paramtype">TSLDeviceUnits *</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits *</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query extent of window.</p>
<p>This method allows the user to query the extent of the window handle currently displayed in terms of device units. This is the same extent that will have been passed in the last call to 'wndResize'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Storage for top left co-ordinate of the extent in device units.</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for bottom right co-ordinate of the extent in device units. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9bde97604179aa10b89500cfd543dd06" name="a9bde97604179aa10b89500cfd543dd06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bde97604179aa10b89500cfd543dd06">&#9670;&#160;</a></span>getFillStyleIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::getFillStyleIndices </td>
          <td>(</td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query fill style indices.</p>
<p>Queries fill style indices specified in the fill style file last loaded using setupFillStyles. These indices may be be converted to OS specific handles using the fillStyleValue method. Note that the indices are not necessarily contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Storage for pointer to indices. Populated if successful. The buffer is owned by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> and should not be deleted.</td></tr>
    <tr><td class="paramname">num</td><td>Storage for number of indices in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the arguments were populated, false otherwise. </dd></dl>

</div>
</div>
<a id="a56af95ebf21a45ca380a0ce42da51249" name="a56af95ebf21a45ca380a0ce42da51249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56af95ebf21a45ca380a0ce42da51249">&#9670;&#160;</a></span>getFontStyleIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::getFontStyleIndices </td>
          <td>(</td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query font style indices.</p>
<p>Queries font style indices specified in the font style file last loaded using setupFontStyles. These indices may be be converted to OS specific handles using the fontStyleValue method. Note that the indices are not necessarily contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Storage for pointer to indices. Populated if successful. The buffer is owned by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> and should not be deleted.</td></tr>
    <tr><td class="paramname">num</td><td>Storage for number of indices in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the arguments were populated, false otherwise. </dd></dl>

</div>
</div>
<a id="a1a964579c2078caf7fd785ae5ca59590" name="a1a964579c2078caf7fd785ae5ca59590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a964579c2078caf7fd785ae5ca59590">&#9670;&#160;</a></span>getIDOfNearestColour()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static TSLStyleID TSLDrawingSurface::getIDOfNearestColour </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Find the closest supported colour.</p>
<p>Finds the closest supported colour to the RGB value passed in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">r</td><td>red value (0-255)</td></tr>
    <tr><td class="paramname">g</td><td>green value (0-255)</td></tr>
    <tr><td class="paramname">b</td><td>blue value (0-255)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>index of nearest colour, -1 on error. </dd></dl>

</div>
</div>
<a id="a051cf30191f83100d566ea4b35700456" name="a051cf30191f83100d566ea4b35700456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051cf30191f83100d566ea4b35700456">&#9670;&#160;</a></span>getLineStyleIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::getLineStyleIndices </td>
          <td>(</td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query line style indices.</p>
<p>Queries line style indices specified in the line style file last loaded using setupLineStyles. These indices may be be converted to OS specific handles using the lineStyleValue method. Note that the indices are not necessarily contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Storage for pointer to indices. Populated if successful. The buffer is owned by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> and should not be deleted.</td></tr>
    <tr><td class="paramname">num</td><td>Storage for number of indices in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the arguments were populated, false otherwise. </dd></dl>

</div>
</div>
<a id="a65f256aabb5b59e80b88e08038effc5c" name="a65f256aabb5b59e80b88e08038effc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65f256aabb5b59e80b88e08038effc5c">&#9670;&#160;</a></span>getMUExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurface::getMUExtent </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query extent of data on <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</p>
<p>This method allows the user to query the extent of the MapLink map data currently displayed in terms of map units.</p>
<p>Note: If the user application maintains such extent, this method should be called to refresh them after any operation applied on the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> which will affect the area of Maplink map data displayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Storage for bottom left co-ordinate of the extent in map units.</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for top right co-ordinate of the extent in map units. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39c36e88a1ea95c97448f9d9bd41bcf4" name="a39c36e88a1ea95c97448f9d9bd41bcf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39c36e88a1ea95c97448f9d9bd41bcf4">&#9670;&#160;</a></span>getSymbolStyleIndices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::getSymbolStyleIndices </td>
          <td>(</td>
          <td class="paramtype">int **</td>          <td class="paramname"><span class="paramname"><em>indices</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>num</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query symbol style indices.</p>
<p>Queries symbol style indices specified in the symbol style file last loaded using setupSymbols. These indices may be be converted to OS specific handles using the symbolStyleValue method. Note that the indices are not necessarily contiguous.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indices</td><td>Storage for pointer to indices. Populated if successful. The buffer is owned by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> and should not be deleted.</td></tr>
    <tr><td class="paramname">num</td><td>Storage for number of indices in array.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the arguments were populated, false otherwise. </dd></dl>

</div>
</div>
<a id="af7a5044855e7098d3dfd31aeb50def3a" name="af7a5044855e7098d3dfd31aeb50def3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a5044855e7098d3dfd31aeb50def3a">&#9670;&#160;</a></span>getTiledBufferController()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_drawing_surface_tiled_buffer_control.html">TSLDrawingSurfaceTiledBufferControl</a> * TSLDrawingSurface::getTiledBufferController </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an object that an application can use to change settings for tiled buffered layers. Tiled buffered layers must first be enabled using the TSLOptionTileBufferedLayers drawing surface option.</p>
<p>See the class documentation for <a class="el" href="class_t_s_l_drawing_surface_tiled_buffer_control.html">TSLDrawingSurfaceTiledBufferControl</a> for more details. </p>

</div>
</div>
<a id="ab4858d5b71cf4b0e867b363cfec4be4d" name="ab4858d5b71cf4b0e867b363cfec4be4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4858d5b71cf4b0e867b363cfec4be4d">&#9670;&#160;</a></span>getTMCExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurface::getTMCExtent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query extent of data on <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</p>
<p>This method allows the user to query the extent of the MapLink map data currently displayed in terms of TMC units.</p>
<p>Note: If the user application maintains such extent, this method should be called to refresh them after any operation applied on the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> which will affect the area of Maplink map data displayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>Storage for the extent. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05a127c44f812974a35def9bf6670dcb" name="a05a127c44f812974a35def9bf6670dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a127c44f812974a35def9bf6670dcb">&#9670;&#160;</a></span>getUUExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurface::getUUExtent </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query extent of data on <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</p>
<p>This method allows the user to query the extent of the MapLink map data currently displayed in terms of user units, ignoring any rotation that has been applied to the drawing surface.</p>
<p>Note: If the user application maintains such extent, this method should be called to refresh them after any operation applied on the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> which will affect the area of Maplink map data displayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Storage for bottom left co-ordinate of the extent in user units.</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for top right co-ordinate of the extent in user units. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abeb2c6838847338edd95ea19dff318bc" name="abeb2c6838847338edd95ea19dff318bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb2c6838847338edd95ea19dff318bc">&#9670;&#160;</a></span>getViewedLatLongRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::getViewedLatLongRange </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>latitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>longitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>boundCheck</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the extent of data currently in view. Returns the centre of the area in latitude and longitude in degrees, and the minimum range visible horizontally or vertically in map units. NOTE: This function is not appropriate for use when Dynamic Arc Support is enabled, since the X/Y aspect adjustment results in non-square TMC per DU values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latitude</td><td>returns the latitude of the centre of the currently viewed area, in degrees</td></tr>
    <tr><td class="paramname">longitude</td><td>returns the longitude of the centre of the currently viewed area, in degrees</td></tr>
    <tr><td class="paramname">range</td><td>returns the minimum visible distance horizontally or vertically, in map units</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the lat/lon co-ordinate is in WGS84 or the local datum.</td></tr>
    <tr><td class="paramname">boundCheck</td><td>When the initial coordinates are outside of the map extent, the lat/lon returned could be invalid. When this flag is true, a check for invalid results is performed. This check will double the processing time required by the method, but return a validated status code. If the specified coordinate is guaranteed to be within the map extent, then this flag may be turned off.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="abad4b5bf36e222d864ee5db18a81054d" name="abad4b5bf36e222d864ee5db18a81054d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad4b5bf36e222d864ee5db18a81054d">&#9670;&#160;</a></span>latLongToDU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::latLongToDU </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>latitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>longitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits *</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from latitude/longitude to device unit co-ordinate.</p>
<p>This operation will use the current Coordinate System to perform the conversion. This will usually be defined only for TSLMapDataLayers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(latitude,longitude)</td><td>Point to convert.</td></tr>
    <tr><td class="paramname">(x,y)</td><td>Storage for device unit co-ordinate.</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the lat/lon co-ordinate is in WGS84 or the local datum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a396b86032a83c3a8b8eec53ca10dc10b" name="a396b86032a83c3a8b8eec53ca10dc10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a396b86032a83c3a8b8eec53ca10dc10b">&#9670;&#160;</a></span>latLongToMU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::latLongToMU </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>latitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>longitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from latitude/longitude to Map Unit co-ordinate.</p>
<p>This operation will use the current Coordinate System to perform the conversion. This will usually be defined only for TSLMapDataLayers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(latitude,longitude)</td><td>Point to convert.</td></tr>
    <tr><td class="paramname">(x,y)</td><td>Storage for Map Unit co-ordinate.</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the lat/lon co-ordinate is in WGS84 or the local datum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a8cba4efaf42d5cc263331f6031ab1a19" name="a8cba4efaf42d5cc263331f6031ab1a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cba4efaf42d5cc263331f6031ab1a19">&#9670;&#160;</a></span>latLongToTMC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::latLongToTMC </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>latitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>longitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from latitude/longitude to internal TMC co-ordinate.</p>
<p>This operation will use the current Coordinate System to perform the conversion. This will usually be defined only for TSLMapDataLayers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(latitude,longitude)</td><td>Point to convert.</td></tr>
    <tr><td class="paramname">(x,y)</td><td>Storage for internal TMC co-ordinate.</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the lat/lon co-ordinate is in WGS84 or the local datum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a24a585738cf746b7ba0fd07121f09d57" name="a24a585738cf746b7ba0fd07121f09d57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24a585738cf746b7ba0fd07121f09d57">&#9670;&#160;</a></span>latLongToUU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::latLongToUU </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>latitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>longitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from latitude/longitude to User Unit co-ordinate.</p>
<p>This operation will use the current Coordinate System to perform the conversion. This will usually be defined only for TSLMapDataLayers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(latitude,longitude)</td><td>Point to convert.</td></tr>
    <tr><td class="paramname">(x,y)</td><td>Storage for User Unit co-ordinate.</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the lat/lon co-ordinate is in WGS84 or the local datum.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="aa311653bc595b8f619483d097bc91fe2" name="aa311653bc595b8f619483d097bc91fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa311653bc595b8f619483d097bc91fe2">&#9670;&#160;</a></span>loadStandardConfig()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLDrawingSurface::loadStandardConfig </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>path</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>delayLoadIncludes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loads the tsl*.dat files with the default names into all drawing surfaces. This is equivalent to firstly adding a pathlist configured to find data files, fonts, symbols and so on in the default subdirectories (e.g. <code>addKeyedDirectory(root+"fonts", 0, ".thf", TSLCompressedDefault)</code> ),</p>
<p>and secondly calling: </p><pre class="fragment">setupColours( "tslcolours.dat" );
setupFonts( "tslfonts.dat" );
setupSymbols( "tslsymbols.dat" );
setupLineStyles( "tsllinestyles.dat" );
setupFillStyles( "tslfillstyles.dat" );
</pre><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>If supplied, this is the path from which the configuration files are to be loaded. If null, then the files are assumed to be present in the config subdirectory of the maplink installation on the local machine (whose location is found using <a class="el" href="class_t_s_l_utility_functions.html#a6072d870420a5f496c285cb3d11af678">TSLUtilityFunctions::getMapLinkHome()</a>). Note that using a relative path here will cause problems if the working directory changes as the path will no longer point to the correct directory, so it is recommended to use an absolute path.</td></tr>
    <tr><td class="paramname">delayLoadIncludes</td><td>If this flag is set to true the all referenced include files in each of the configuration lists will only be loaded when they are required rather than during this call. This should not be set to true if rendering or querying any fillstyles, fonts, linestyles or symbols in a multithreaded environment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a229a7af4f762a8b08fa85ec98c4a6216" name="a229a7af4f762a8b08fa85ec98c4a6216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a229a7af4f762a8b08fa85ec98c4a6216">&#9670;&#160;</a></span>MUToDU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::MUToDU </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert map unit co-ordinate to device units.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Map unit co-ordinate</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for device unit co-ordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a34e6d157fa0bc20f57c0ac472c2f89d1" name="a34e6d157fa0bc20f57c0ac472c2f89d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e6d157fa0bc20f57c0ac472c2f89d1">&#9670;&#160;</a></span>MUToLatLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::MUToLatLong </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>latitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>longitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>boundCheck</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert map unit co-ordinate to latitude/longitudes.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y)</td><td>Map unit co-ordinate</td></tr>
    <tr><td class="paramname">(latitude,longitude)</td><td>Storage for lat/lon co-ordinate.</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the lat/lon co-ordinate is in WGS84 or the local datum.</td></tr>
    <tr><td class="paramname">boundCheck</td><td>When the initial coordinates are outside of the map extent, the lat/lon returned could be invalid. When this flag is true, a check for invalid results is performed. This check will double the processing time required by the method, but return a validated status code. If the specified coordinate is guaranteed to be within the map extent, then this flag may be turned off.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a056dc5745b1ddb69eee0107691a6d156" name="a056dc5745b1ddb69eee0107691a6d156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056dc5745b1ddb69eee0107691a6d156">&#9670;&#160;</a></span>MUToTMC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::MUToTMC </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert map unit co-ordinate to internal units.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Map unit co-ordinate</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for internal TMC unit co-ordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a519dcb08d580a637d8e99a55ed71b8cf" name="a519dcb08d580a637d8e99a55ed71b8cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a519dcb08d580a637d8e99a55ed71b8cf">&#9670;&#160;</a></span>MUToUU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::MUToUU </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert map unit co-ordinate to user units.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Map unit co-ordinate</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for user unit co-ordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="af72dfae3357186a52e4cf5f33c7ff121" name="af72dfae3357186a52e4cf5f33c7ff121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72dfae3357186a52e4cf5f33c7ff121">&#9670;&#160;</a></span>pan() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::pan </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>auto_redraw</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make specified point centre of display.</p>
<p>This method will cause the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> to pan so that the input co-ordinates are at the centre of the display area. If 'auto_redraw' it true, then the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> will automatically draw the new requested area on the window handle to which the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> is attached.</p>
<p>Note: The pan may cause the extent of the MapLink map data to overflow the extent of TMC coordinate space. In this case, the pan operation is not applied and the function returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Point co-ordinates (in user units) to be set at the centre of the display.</td></tr>
    <tr><td class="paramname">auto_redraw</td><td>If true, the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> redraws automatically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a90e7ebe67614f96a87a04e8dfac6b2aa" name="a90e7ebe67614f96a87a04e8dfac6b2aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90e7ebe67614f96a87a04e8dfac6b2aa">&#9670;&#160;</a></span>pan() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::pan </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>xDU</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>yDU</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>auto_redraw</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make specified point in UU space, move to specified point in DU space.</p>
<p>This method is typically used for grab-style panning. It is necessary since any Dynamic Arc adjustments may affect the device unit positioning of a normal pan.</p>
<p>This method will cause the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> to pan so that the input coordinates are at the specified point in the display area. If 'auto_redraw' is true, then the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> will automatically draw the new requested area on the window handle to which the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> is attached.</p>
<p>Note: The pan may cause the extent of the MapLink map data to overflow the extent of TMC coordinate space. In this case, the pan operation is not applied and the function returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Point coordinates (in user units) to be set at the specified point in the display area.</td></tr>
    <tr><td class="paramname">(xDU,yDU)</td><td>Point coordinates (in device units) for (x1,y1) to move to.</td></tr>
    <tr><td class="paramname">auto_redraw</td><td>If true, the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> redraws automatically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a9491068819845644862267d6338fc263" name="a9491068819845644862267d6338fc263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9491068819845644862267d6338fc263">&#9670;&#160;</a></span>query() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> * TSLDrawingSurface::query </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>feature_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query for entities in extent.</p>
<p>The detail layer used is the layer for the current drawing surface extent.</p>
<p>This method requests the named layer to return a <a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> object which allows the user to access the data tiles required for the display of the specified area. The <a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> for a <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> is only valid for immediate use since the data tiles to which they refer may be removed from memory if the cache is flushed.</p>
<p>In the default case, all tiles whose extent intersects the specified extent will be returned. These will include all entities within those tiles, even though some individual entities may not be within the extent.</p>
<p>Alternatively, if a depth is specified, then the query recurses into the tiles and returns only those individual entities that whose extents intersect the region. An optional feature name may also be specified.</p>
<p>NOTE: When querying an Optimised map the query may return objects that can not be further analysed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerName</td><td>The name of the layer to query</td></tr>
    <tr><td class="paramname">(x1,y1)</td><td>The bottom left co-ordinate of the specified area (in internal TMC units)</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>the top right co-ordinate of the specified area (in internal TMC units)</td></tr>
    <tr><td class="paramname">depth</td><td>Specifies how deep to look before returning a pointer to an object. If the depth is -1 (the default), individual entities are returned. If the depth is 0 it searches at the highest level in the tile (that is it may return a Group rather than an entity within the Group).</td></tr>
    <tr><td class="paramname">feature_name</td><td>If not NULL, only entities of this feature name will be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a <a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> object. If NULL, it indicates that no tiles were found for the specified area. </dd></dl>

</div>
</div>
<a id="a5e56090a87893c5fb5f07cfe30835d8f" name="a5e56090a87893c5fb5f07cfe30835d8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e56090a87893c5fb5f07cfe30835d8f">&#9670;&#160;</a></span>query() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> * TSLDrawingSurface::query </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_selector.html">TSLSelector</a> *</td>          <td class="paramname"><span class="paramname"><em>selector</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query for entities in extent based on a client-supplied search criteria.</p>
<p>The detail layer used is the layer for the current drawing surface extent.</p>
<p>This method requests the named layer to return a <a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> object which allows the user to access the data tiles required for the display of the specified area, or entities within those tiles. The <a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> for a <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> is only valid for immediate use since the data tiles to which they refer may be removed from memory if the cache is flushed.</p>
<p>The client must specify the selection policy through a suitable TSLSelector-derived object.</p>
<p>NOTE: When querying an Optimised map the query may return objects that can not be further analysed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerName</td><td>The name of the layer to query</td></tr>
    <tr><td class="paramname">(x1,y1)</td><td>The bottom left co-ordinate of the specified area (in internal TMC units)</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>the top right co-ordinate of the specified area (in internal TMC units)</td></tr>
    <tr><td class="paramname">selector</td><td>Specifies the selection criteria. See <a class="el" href="class_t_s_l_selector.html">TSLSelector</a> and <a class="el" href="group__apigroup__api.html#ga3e56f53a5153d4b827e133fd41bd419a">TSLSelectorActionType</a> for further details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae85ac70f3315d04cf26c6a90025b4944" name="ae85ac70f3315d04cf26c6a90025b4944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae85ac70f3315d04cf26c6a90025b4944">&#9670;&#160;</a></span>redraw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::redraw </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears and redraws the entire visible extent of the surface (as specified to wndResize). </p>

</div>
</div>
<a id="acb6c56019d6190af127879ce48b6250a" name="acb6c56019d6190af127879ce48b6250a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6c56019d6190af127879ce48b6250a">&#9670;&#160;</a></span>removeFillStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::removeFillStyle </td>
          <td>(</td>
          <td class="paramtype">TSLStyleID</td>          <td class="paramname"><span class="paramname"><em>style</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a style from a Dynamic List - Future Enhancement </p>

</div>
</div>
<a id="a3f89f337edd9a76ca9d1fd2638b09106" name="a3f89f337edd9a76ca9d1fd2638b09106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f89f337edd9a76ca9d1fd2638b09106">&#9670;&#160;</a></span>removeFontStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::removeFontStyle </td>
          <td>(</td>
          <td class="paramtype">TSLStyleID</td>          <td class="paramname"><span class="paramname"><em>style</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a style from a Dynamic List - Future Enhancement </p>

</div>
</div>
<a id="a72941d15fa3abb4af65b41d2d3e0205d" name="a72941d15fa3abb4af65b41d2d3e0205d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72941d15fa3abb4af65b41d2d3e0205d">&#9670;&#160;</a></span>removeLineStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::removeLineStyle </td>
          <td>(</td>
          <td class="paramtype">TSLStyleID</td>          <td class="paramname"><span class="paramname"><em>style</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a style from a Dynamic List - Future Enhancement </p>

</div>
</div>
<a id="a4829860c91707d31cf426c4d63de5835" name="a4829860c91707d31cf426c4d63de5835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4829860c91707d31cf426c4d63de5835">&#9670;&#160;</a></span>removeSymbolStyle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::removeSymbolStyle </td>
          <td>(</td>
          <td class="paramtype">TSLStyleID</td>          <td class="paramname"><span class="paramname"><em>style</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove a style from a Dynamic List - Future Enhancement </p>

</div>
</div>
<a id="aed93ce6d7d56190ca1c06cf9701822dc" name="aed93ce6d7d56190ca1c06cf9701822dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed93ce6d7d56190ca1c06cf9701822dc">&#9670;&#160;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::reset </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>auto_redraw</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset to full view.</p>
<p>This method resets the current UU extent so that the maximum extent of the attached TSLDataLayers is displayed in the attached window extent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">auto_redraw</td><td>If true, automatically redraws the window.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ab7690d28806f4f49eefa448236c693ed" name="ab7690d28806f4f49eefa448236c693ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7690d28806f4f49eefa448236c693ed">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::resize </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>auto_redraw</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keep_aspect</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes displayed extent of map.</p>
<p>This method informs the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> of the map area that it is to be displayed. When the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> is first attached to the handle, it must be given the co-ordinates of the data area that it is to display.</p>
<p>Note: The resize may cause the extent of the MapLink map data to overflow the extent of TMC coordinate space. In this case, the resize operation is not applied and the function return false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Bottom left co-ordinate (in user-units) of the area to redraw.</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Top right co-ordinate (in user-units) of the area to redraw.</td></tr>
    <tr><td class="paramname">auto_redraw</td><td>If true, will result in the whole drawing surface area being redrawn. Defaults to true.</td></tr>
    <tr><td class="paramname">keep_aspect</td><td>If true, will attempt to maintain the aspect ratio according to the current window aspect ratio. Defaults to false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a800690766b84cce3a78c08bf1f81bf85" name="a800690766b84cce3a78c08bf1f81bf85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800690766b84cce3a78c08bf1f81bf85">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::rotate </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>angle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rotate the vector map display.</p>
<p>This method rotates the display of the MapLink map data. It does not affect the data in any way, only the display of the data. The data will rotate around the current extent centre.</p>
<p>Note: The rotation may cause the extent of the MapLink map data to overflow the internal TMC co-ordinate limits, in which case the rotation is not applied and the method returns false.</p>
<p>Note: If you need to rotate raster data, please consider using the <a class="el" href="class_t_s_l_open_g_l_surface.html">TSLOpenGLSurface</a>, or the Accelerator SDK. Samples exist for both of these approaches.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Angle of the rotation (in radians), +ve anti-clockwise from the +ve X axis.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the display has been rotated successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="a2ed652727aa64811d82939686f197953" name="a2ed652727aa64811d82939686f197953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed652727aa64811d82939686f197953">&#9670;&#160;</a></span>rotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TSLDrawingSurface::rotation </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the current rotation of the vector map display.</p>
<p>This method queries the current rotation the display of the MapLink map data.</p>
<p>Returns angle of the rotation (in radians), +ve anti-clockwise from the +ve X axis. </p>

</div>
</div>
<a id="aa48130aab4aea41eaacd059d307573e0" name="aa48130aab4aea41eaacd059d307573e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa48130aab4aea41eaacd059d307573e0">&#9670;&#160;</a></span>setDeclutterRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::setDeclutterRange </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>innerLimit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>outerLimit</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dataLayerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>detailLayerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set automatic decluttering range.</p>
<p>This method sets the resolution range for which the named feature type is visible. This is only applicable when the visibility mode is TSLDeclutterStatusAuto. The range values are given as the number of user units per device unit.</p>
<p>The declutter status is set to TSLDeclutterStatusAuto after this method is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of the feature type to set the visibility range for.</td></tr>
    <tr><td class="paramname">innerLimit</td><td>Minimum resolution at which the feature type is visible (user units per device unit), i.e. maximum zoom in.</td></tr>
    <tr><td class="paramname">outerLimit</td><td>Maximum resolution at which the feature type is visible (user units per device unit), i.e. maximum zoom out.</td></tr>
    <tr><td class="paramname">dataLayerName</td><td>The data layer to set the decluttering value for. Default is 0 i.e. set for all layers.</td></tr>
    <tr><td class="paramname">detailLayerName</td><td>the detail layer to set the cluttering value for. Default is 0 to set for all detail layers.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="ac3c1fbad2ef1ae403936f7d92b06ce29" name="ac3c1fbad2ef1ae403936f7d92b06ce29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c1fbad2ef1ae403936f7d92b06ce29">&#9670;&#160;</a></span>setDeviceCapabilities() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::setDeviceCapabilities </td>
          <td>(</td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>horizontalSizeMM</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>verticalSizeMM</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>horizontalSizePixels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>verticalSizePixels</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the device capabilities.</p>
<p>The set values are used when drawing items whose dimensions are defined as TSLDimensionUnitsPoints.</p>
<p>This method only needs to be called it the values need to be adjusted or reset to the default.</p>
<p>The set values will be discarded if attach is called.</p>
<p>The settings will not be used when a call is made to drawToHDC or drawToDrawable. The user will need to pass in the device capabilities to these methods (defaults for the device will be used otherwise).</p>
<p>Default values are obtained from the underlying drawing system.</p>
<p>On Windows the values can be obtained using the Windows SDK method: GetDeviceCaps.</p>
<p>On X11 targets the values can be obtained using the macros found in Xlib.h: DisplayWidthMM, DIsplayHeightMM, DisplayWidth, DisplayHeight.</p>
<p>If the parameters are all set to zero the method queries the System defaults and sets those values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">horizontalSizeMM</td><td>horizontal size of the visible screen in mm's.</td></tr>
    <tr><td class="paramname">verticalSizeMM</td><td>vertical size of the visible screen in mm's.</td></tr>
    <tr><td class="paramname">horizontalSizePixels</td><td>horizontal size of the screen in pixels.</td></tr>
    <tr><td class="paramname">verticalSizePixels</td><td>vertical size of the screen in pixels.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise.</dd></dl>
<p>See Also: <a class="el" href="class_t_s_l_n_t_surface.html#a8723369355747b08deddd574ec188aa6">TSLNTSurface::drawToHDC</a>, <a class="el" href="class_t_s_l_motif_surface.html#ab57470aa14c2cd386844ec185664a745">TSLMotifSurface::drawToDrawable</a> </p>

</div>
</div>
<a id="a164f432573707f6d4ee485bccf136f74" name="a164f432573707f6d4ee485bccf136f74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a164f432573707f6d4ee485bccf136f74">&#9670;&#160;</a></span>setDeviceCapabilities() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::setDeviceCapabilities </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_device_capabilities.html">TSLDeviceCapabilities</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>capabilities</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the device capabilities.</p>
<p>The set values are used when drawing items whose dimensions are defined as TSLDimensionUnitsPoints.</p>
<p>This method only needs to be called it the values need to be adjusted or reset to the default.</p>
<p>The set values will be discarded if attach is called.</p>
<p>The settings will not be used when a call is made to drawToHDC or drawToDrawable. The user will need to pass in the device capabilities to these methods (defaults for the device will be used otherwise).</p>
<p>Default values are obtained from the underlying drawing system.</p>
<p>On Windows the values can be obtained using the Windows SDK method: GetDeviceCaps.</p>
<p>On X11 targets the values can be obtained using the macros found in Xlib.h: DisplayWidthMM, DIsplayHeightMM, DisplayWidth, DisplayHeight.</p>
<p>If the parameters are all set to zero the method queries the System defaults and sets those values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">capabilities</td><td>The capabilities of the device. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise.</dd></dl>
<p>See Also: <a class="el" href="class_t_s_l_n_t_surface.html#a8723369355747b08deddd574ec188aa6">TSLNTSurface::drawToHDC</a>, <a class="el" href="class_t_s_l_motif_surface.html#ab57470aa14c2cd386844ec185664a745">TSLMotifSurface::drawToDrawable</a> </p>

</div>
</div>
<a id="ab98ffd5550409dab6aa56886979538b3" name="ab98ffd5550409dab6aa56886979538b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98ffd5550409dab6aa56886979538b3">&#9670;&#160;</a></span>setRedrawCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurface::setRedrawCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_drawing_surface_draw_callback.html">TSLDrawingSurfaceDrawCallback</a> *</td>          <td class="paramname"><span class="paramname"><em>callback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the callback object to use when the drawing surface needs to trigger a redraw. This is currently used by tiled buffered layers.</p>
<p>The user retains ownership of the callback object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback object to use. Passing NULL clears any existing callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36b9dd3cf9821d65515a1d23d3f9cecc" name="a36b9dd3cf9821d65515a1d23d3f9cecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b9dd3cf9821d65515a1d23d3f9cecc">&#9670;&#160;</a></span>setupColours()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLDrawingSurface::setupColours </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load colour definition file.</p>
<p>This method allows the user to set up a list of colours that will be used by all TSLDrawingSurfaces.</p>
<p>If addPathList or loadStandardConfig has been called then the pathlist is used to search for the file in suitable directories (using keying), if not then the system Path and the environment variable MAPLINK_PATH are used to search for the file, or alternatively the filename may be fully qualified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the colour file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a7f51404204385733cd71891f4dd7b6fc" name="a7f51404204385733cd71891f4dd7b6fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f51404204385733cd71891f4dd7b6fc">&#9670;&#160;</a></span>setupDynamicColours()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::setupDynamicColours </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load colour definition file into the surface dynamic colour list.</p>
<p>This method allows the user to set up a list of colours which are used only by this instance of the Drawing Surface.</p>
<p>The current dynamic colours are not cleared. The colours loaded will overwrite any colour index that already exist.</p>
<p>If addPathList or loadStandardConfig has been called then the pathlist is used to search for the file in suitable directories (using keying), if not then the system Path and the environment variable MAPLINK_PATH are used to search for the file, or alternatively the filename may be fully qualified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the colour file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="aa170198d571f4d15d556412e149a4080" name="aa170198d571f4d15d556412e149a4080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa170198d571f4d15d556412e149a4080">&#9670;&#160;</a></span>setupFillStyles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLDrawingSurface::setupFillStyles </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>delayLoadIncludes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load fill style definition file.</p>
<p>This method allows the user to set up the list of fill styles that will be used by all TSLDrawingSurfaces.</p>
<p>If addPathList or loadStandardConfig has been called then the pathlist is used to search for the file in suitable directories (using keying), if not then the system Path and the environment variable MAPLINK_PATH are used to search for the file, or alternatively the filename may be fully qualified.</p>
<dl class="section note"><dt>Note</dt><dd>This method should only be called once during an application's initialisation phase. Calling this method after the application has started rendering is not recommended.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the fill style file.</td></tr>
    <tr><td class="paramname">delayLoadIncludes</td><td>If this flag is set to true the all referenced include files in the fillstyle list will only be loaded when they are required rather than during this call. This should not be set to true if rendering or querying fillstyles in a multithreaded environment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a046b8114dfb56a9d09f85dcb7716479d" name="a046b8114dfb56a9d09f85dcb7716479d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a046b8114dfb56a9d09f85dcb7716479d">&#9670;&#160;</a></span>setupFonts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLDrawingSurface::setupFonts </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>delayLoadIncludes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load font definition file.</p>
<p>This method allows the user to set up the list of fonts that will be used by all <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> when rendering text.</p>
<p>If addPathList or loadStandardConfig has been called then the pathlist is used to search for the file in suitable directories (using keying), if not then the system Path and the environment variable MAPLINK_PATH are used to search for the file, or alternatively the filename may be fully qualified.</p>
<dl class="section note"><dt>Note</dt><dd>This method should only be called once during an application's initialisation phase. Calling this method after the application has started rendering is not recommended.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the font file.</td></tr>
    <tr><td class="paramname">delayLoadIncludes</td><td>If this flag is set to true the all referenced include files in the font list will only be loaded when they are required rather than during this call. This should not be set to true if rendering or querying fonts in a multithreaded environment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="afeda81868b934c3a05a71cfa3c5bc611" name="afeda81868b934c3a05a71cfa3c5bc611"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeda81868b934c3a05a71cfa3c5bc611">&#9670;&#160;</a></span>setupLineStyles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLDrawingSurface::setupLineStyles </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>delayLoadIncludes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load line style definition file.</p>
<p>This method allows the user to set up the list of line styles that will be used by all TSLDrawingSurfaces.</p>
<p>If addPathList or loadStandardConfig has been called then the pathlist is used to search for the file in suitable directories (using keying), if not then the system Path and the environment variable MAPLINK_PATH are used to search for the file, or alternatively the filename may be fully qualified.</p>
<dl class="section note"><dt>Note</dt><dd>This method should only be called once during an application's initialisation phase. Calling this method after the application has started rendering is not recommended.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the line style file.</td></tr>
    <tr><td class="paramname">delayLoadIncludes</td><td>If this flag is set to true the all referenced include files in the linestyle list will only be loaded when they are required rather than during this call. This should not be set to true if rendering or querying linestyles in a multithreaded environment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a98418e65bfd9026740db3c77abf260d0" name="a98418e65bfd9026740db3c77abf260d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98418e65bfd9026740db3c77abf260d0">&#9670;&#160;</a></span>setupSymbols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLDrawingSurface::setupSymbols </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>delayLoadIncludes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Load symbol definition file.</p>
<p>This method allows the user to set up the list of symbols that will be used by all TSLDrawingSurfaces.</p>
<p>If addPathList or loadStandardConfig has been called then the pathlist is used to search for the file in suitable directories (using keying), if not then the system Path and the environment variable MAPLINK_PATH are used to search for the file, or alternatively the filename may be fully qualified.</p>
<dl class="section note"><dt>Note</dt><dd>This method should only be called once during an application's initialisation phase. Calling this method after the application has started rendering is not recommended.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the symbol file.</td></tr>
    <tr><td class="paramname">delayLoadIncludes</td><td>If this flag is set to true the all referenced include files in the symbol list will only be loaded when they are required rather than during this call. This should not be set to true if rendering or querying symbols in a multithreaded environment.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="ae12ea6c2b80dc64f1c48041f8669455c" name="ae12ea6c2b80dc64f1c48041f8669455c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12ea6c2b80dc64f1c48041f8669455c">&#9670;&#160;</a></span>setViewedLatLongRange()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::setViewedLatLongRange </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>latitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>longitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>range</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>auto_redraw</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>keep_aspect</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the extent of data to view. Takes the centre of the area in latitude and longitude in degrees, and the minimum range to make visible horizontally or vertically in map units. NOTE: This function is not appropriate for use when Dynamic Arc Support is enabled, since the X/Y aspect adjustment results in non-square TMC per DU values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">latitude</td><td>the latitude to place at the centre of the viewed area, in degrees</td></tr>
    <tr><td class="paramname">longitude</td><td>the longitude to place at the centre of the viewed area, in degrees</td></tr>
    <tr><td class="paramname">range</td><td>the minimum distance to make visible horizontally or vertically, in map units</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the lat/lon co-ordinate is in WGS84 or the local datum.</td></tr>
    <tr><td class="paramname">auto_redraw</td><td>If true, will result in the whole drawing surface area being redrawn.</td></tr>
    <tr><td class="paramname">keep_aspect</td><td>If true, will attempt to maintain the aspect ratio according to the current window aspect ratio. If false, the aspect ratio will be changed to meet the given range in both directions.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a8e19f07cd5d254d552f72555af9a8c3b" name="a8e19f07cd5d254d552f72555af9a8c3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e19f07cd5d254d552f72555af9a8c3b">&#9670;&#160;</a></span>TMCperDU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurface::TMCperDU </td>
          <td>(</td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>xr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>yr</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query current screen resolution, varying in X and Y axis. These are usually the same, but may differ - e.g. Dynamic Arc projections.</p>
<p>This method gives the current resolution of the screen. This value is in internal TMC co-ordinates per device unit (pixel).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xr</td><td>Storage for X axis resolution</td></tr>
    <tr><td class="paramname">yr</td><td>Storage for Y axis resolution </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8ce349a3c79510c6e24e2dabdc7ecfc8" name="a8ce349a3c79510c6e24e2dabdc7ecfc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ce349a3c79510c6e24e2dabdc7ecfc8">&#9670;&#160;</a></span>TMCperUU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TSLDrawingSurface::TMCperUU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query number of TMC units per user unit.</p>
<p>This value is the number of internal TMC co-ordinates per user unit. These is based upon the last map data layer added to the drawing surface.</p>
<p>Returns the TMC units per user unit, 0.0 on error. </p>

</div>
</div>
<a id="a0b8e6605f56df449e17d44e200e36d4c" name="a0b8e6605f56df449e17d44e200e36d4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b8e6605f56df449e17d44e200e36d4c">&#9670;&#160;</a></span>TMCToDU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::TMCToDU </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts internal co-ordinate to device co-ordinate.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Internal co-ordinate</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for device co-ordinate .</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a4f4f2031604fd46d50acbc2df498decf" name="a4f4f2031604fd46d50acbc2df498decf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4f2031604fd46d50acbc2df498decf">&#9670;&#160;</a></span>TMCToLatLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::TMCToLatLong </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>latitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>longitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>boundCheck</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from internal TMC co-ordinate to latitude/longitude.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y)</td><td>Internal TMC co-ordinate.</td></tr>
    <tr><td class="paramname">(latitude,longitude)</td><td>Storage for lat/lon co-ordinate.</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the lat/lon co-ordinate is in WGS84 or the local datum.</td></tr>
    <tr><td class="paramname">boundCheck</td><td>When the initial coordinates are outside of the map extent, the lat/lon returned could be invalid. When this flag is true, a check for invalid results is performed. This check will double the processing time required by the method, but return a validated status code. If the specified coordinate is guaranteed to be within the map extent, then this flag may be turned off.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="afd800e36b15f4eed4777d08d1d522410" name="afd800e36b15f4eed4777d08d1d522410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd800e36b15f4eed4777d08d1d522410">&#9670;&#160;</a></span>TMCToMU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::TMCToMU </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts from internal co-ordinate to user unit co-ordinate.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>X TMC co-ordinate </td></tr>
    <tr><td class="paramname">y1</td><td>Y TMC co-ordinate</td></tr>
    <tr><td class="paramname">x2</td><td>Storage for X map unit co-ordinate. </td></tr>
    <tr><td class="paramname">y2</td><td>Storage for Y map unit co-ordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="ae7992c07cb5d68bc4721823711a11e8e" name="ae7992c07cb5d68bc4721823711a11e8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7992c07cb5d68bc4721823711a11e8e">&#9670;&#160;</a></span>TMCToUU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::TMCToUU </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts from internal co-ordinate to user unit co-ordinate.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Internal co-ordinate</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for user unit co-ordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a7e24f4cf626a0e8c4b092f12f9a94dff" name="a7e24f4cf626a0e8c4b092f12f9a94dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e24f4cf626a0e8c4b092f12f9a94dff">&#9670;&#160;</a></span>updateEntityExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::updateEntityExtent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>entity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recalculates last rendered extent of a point on the drawingsurface using the currently loaded rendition, without actually rendering it.</p>
<p>After changing attributes of some objects, such as symbol style and text font, their extent may change. Since the extent of text and some symbol objects can only be know at rendering time (due to raster fonts etc), their extent may need to be updated by performing a dummy render. This is also necessary after a text objects string has been changed. This is only necessary for text and symbol entities.</p>
<p>If the entity was retrieved from a data layer (e.g. a <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a>), then the name given to the layer when it was added to this drawing surface should be specified in order to ensure the extent is updated correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entity</td><td>Entity whose extent to update.</td></tr>
    <tr><td class="paramname">layerName</td><td>The name of the data layer in this drawing surface that contains the entity.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a941815a45e93b11238a630e068ea10cf" name="a941815a45e93b11238a630e068ea10cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941815a45e93b11238a630e068ea10cf">&#9670;&#160;</a></span>userUnitOrigin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurface::userUnitOrigin </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x_origin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y_origin</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set origin of user unit coordinate system.</p>
<p>This method defines the position of the user units origin in the map output co-ordinate space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x_origin,y_origin)</td><td>Co-ordinate of the user units origin in map units. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7e943708c846dbecc4585ac7ef926e39" name="a7e943708c846dbecc4585ac7ef926e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e943708c846dbecc4585ac7ef926e39">&#9670;&#160;</a></span>userUnitOrigin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurface::userUnitOrigin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#gaea852777270e6ad45b6398b684f03fb5">TSLUUEnum</a></td>          <td class="paramname"><span class="paramname"><em>origin_enum</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the position of the user units origin.</p>
<p>This method allows the origin to be set to some typical standard values which are calculated according to the current map loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">origin_enum</td><td>Point in the map to be set for the user unit origin. The value can be:<ul>
<li>TSLUUBottomLeft to set the bottom left corner of the map as the centre of the user unit co-ordinate space,</li>
<li>TSLUUCentre to set the centre of the map as the centre of the user unit co-ordinate space,</li>
<li>TSLUUTopRight to set the top right corner of the map as the centre of the user unit co-ordinate space. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7eb89e0d8eb0bb0311a36bb60a4b9fb" name="ad7eb89e0d8eb0bb0311a36bb60a4b9fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7eb89e0d8eb0bb0311a36bb60a4b9fb">&#9670;&#160;</a></span>userUnits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TSLDrawingSurface::userUnits </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query number of map units per user unit.</p>
<p>This method returns the number of map units equating to the a single user unit. </p>

</div>
</div>
<a id="aee5c4a9338fc9a7f7c19020a2f3cf2ee" name="aee5c4a9338fc9a7f7c19020a2f3cf2ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee5c4a9338fc9a7f7c19020a2f3cf2ee">&#9670;&#160;</a></span>userUnits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurface::userUnits </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>factor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set number of map units per user unit.</p>
<p>This method allows the user to inform the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> of how many map units equate to a single user unit. Co-ordinate information sent to the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> is normally in user units.</p>
<p>This method should be called at the initialisation phase of your application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">factor</td><td>Number of map output co-ordinates for a single user unit. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a17c636fd6c2727611dde71d21546dfb6" name="a17c636fd6c2727611dde71d21546dfb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c636fd6c2727611dde71d21546dfb6">&#9670;&#160;</a></span>UUToDU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::UUToDU </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from user co-ordinate to device co-ordinate.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>User unit co-ordinate</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for device co-ordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a1874cf113c30ee0fd2523a673968aecc" name="a1874cf113c30ee0fd2523a673968aecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1874cf113c30ee0fd2523a673968aecc">&#9670;&#160;</a></span>UUToLatLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::UUToLatLong </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>latitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>longitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>boundCheck</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert user unit co-ordinate to latitude/longitude</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y)</td><td>User unit co-ordinate</td></tr>
    <tr><td class="paramname">(latitude,longitude)</td><td>Storage for lat/lon co-ordinate.</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the lat/lon co-ordinate is in WGS84 or the local datum.</td></tr>
    <tr><td class="paramname">boundCheck</td><td>When the initial coordinates are outside of the map extent, the lat/lon returned could be invalid. When this flag is true, a check for invalid results is performed. This check will double the processing time required by the method, but return a validated status code. If the specified coordinate is guaranteed to be within the map extent, then this flag may be turned off.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="ad3708fb917b3f5d376322fb4aeee38ee" name="ad3708fb917b3f5d376322fb4aeee38ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3708fb917b3f5d376322fb4aeee38ee">&#9670;&#160;</a></span>UUToMU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::UUToMU </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert user unit co-ordinate to map units.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>User unit co-ordinate</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for map unit co-ordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a381ad674e87bbb437ad98b75ebb52a9e" name="a381ad674e87bbb437ad98b75ebb52a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381ad674e87bbb437ad98b75ebb52a9e">&#9670;&#160;</a></span>UUToTMC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::UUToTMC </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from user unit co-ordinate to an internal co-ordinate.</p>
<p>This method uses the currently loaded transformations for the last <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> that was added to the Drawing Surface. If this is invalid, then the method returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>User unit co-ordinate.</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for internal co-ordinate.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="ab82700ea425c05e6350ecb8a3f66db1d" name="ab82700ea425c05e6350ecb8a3f66db1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82700ea425c05e6350ecb8a3f66db1d">&#9670;&#160;</a></span>wndResize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::wndResize </td>
          <td>(</td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>auto_redraw</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#gac1205ab450d747428b9d32017d80d9ad">TSLResizeActionEnum</a></td>          <td class="paramname"><span class="paramname"><em>action</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__apigroup__api.html#ggac1205ab450d747428b9d32017d80d9adac27a24e79765e5ca34941717c2173eed">TSLResizeActionNone</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The user application should call this function on a window resize.</p>
<p>This methods informs the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> of a change in size of the attached window handle. If the handle is resized and the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> is not informed then the displayed area will remain the same though it may be clipped if the attached handle is reduced in size. All input co-ordinates are given in device units; this is typically in pixels.</p>
<p>Optionally, the uuExtent may be adjusted to fit the new window size. The action parameter determines what should happen to the uuExtent. This is the recommended way to handle this situation since the user unit extent and window extent are not independent.</p>
<p>Note: when the Drawing Surface is first attached to a handle it must be given the co-ordinates of the area that it is to display. This is not necessarily the full area of the handle.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Top left co-ordinate (in device units) of the area to draw. For the OpenGL surface 0,0 is the bottom left corner, y positive upwards. For all other drawing surfaces 0,0 is the top-left corner, y positive downwards.</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Bottom right co-ordinate (in device units) of the area to draw. For the OpenGL surface 0,0 is the bottom left corner, y positive upwards. For all other drawing surfaces 0,0 is the top-left corner, y positive downwards.</td></tr>
    <tr><td class="paramname">auto_redraw</td><td>If true, will result in the whole drawing surface area being redrawn.</td></tr>
    <tr><td class="paramname">action</td><td>One of <a class="el" href="group__apigroup__api.html#gac1205ab450d747428b9d32017d80d9ad">TSLResizeActionEnum</a> values. Determines if the uuExtent is adjusted automatically. Typically, this is set to TSLResizeActionMaintainTopLeft. The default value, for compatibility is TSLResizeActionNone. A map using the Dynamic Arc coordinate system, with the TSLOptionAdjustForDynamicArc option set on the Drawing Surface, causes the action argument to behave differently than for other configurations:<ul>
<li>TSLResizeActionNone behaves similarly to TSLResizeActionMaintainCentre.</li>
<li>TSLResizeActionMaintainTopLeft, TSLResizeActionMaintainTopRight, TSLResizeActionMaintainBottomLeft, TSLResizeActionMaintainBottomRight may not maintain the corner absolutely when resizing on the y axis.</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="aac788a5c33da53c07951fc0ce7de2d17" name="aac788a5c33da53c07951fc0ce7de2d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac788a5c33da53c07951fc0ce7de2d17">&#9670;&#160;</a></span>zoom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurface::zoom </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>percent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>zoom_in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>auto_redraw</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Zoom current view in or out.</p>
<p>This method will cause the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> to zoom based on the percentage value 'percent'. If 'auto_redraw' it true, then the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> will automatically draw the new requested area on the window handle to which the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> is attached.</p>
<p>Note: The zoom may cause the extent of the MapLink map data to overflow the extent of TMC coordinate space. In this case, the zoom operation is not applied and the function returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">percent</td><td>The factor given is a percentage of the current amount of map displayed. Any value greater than 0 is valid.</td></tr>
    <tr><td class="paramname">zoom_in</td><td>The method will apply a zoom in if this argument is equal to true, or a zoom out if it is equal to false.</td></tr>
    <tr><td class="paramname">auto_redraw</td><td>If true, the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> redraws automatically.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.1 | Documentation created Thu Feb 6 2025 11:09:33 | Generated with <a href="http://www.doxygen.org/index.html">Doxygen 1.13.2</a> | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
