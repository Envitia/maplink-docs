<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLClientUserGeometryEntity Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.2</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_client_user_geometry_entity.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_t_s_l_client_user_geometry_entity-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLClientUserGeometryEntity Class Reference<span class="mlabels"><span class="mlabel abstract">abstract</span></span><div class="ingroups"><a class="el" href="group__apigroup__maplink__pro__developers__toolkit.html">MapLink Pro Developer Toolkit</a> &raquo; <a class="el" href="group__apigroup__geometry__api.html">Geometry API</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Specialist user defined geometry entity.</p>
<p>The developer should derive a new class from this class and implement the draw method as a minimum.</p>
<p>The save method should be implemented if you wish to persist your object when save is called on a layer. You will need to provide callbacks for loading (see <a class="el" href="class_t_s_l_user_geometry_entity.html">TSLUserGeometryEntity</a>).</p>
<p>It is suggested that you write out a header that clearly identifies the object type uniquely within your application or company.</p>
<p>It is the developer's responsibility to ensure thread safety. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa49763a0fab5a457f47fbc459b0c4221" id="r_aa49763a0fab5a457f47fbc459b0c4221"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa49763a0fab5a457f47fbc459b0c4221">~TSLClientUserGeometryEntity</a> ()</td></tr>
<tr class="separator:aa49763a0fab5a457f47fbc459b0c4221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a4ddb2e4f14aecb0b40409ea79b186" id="r_a22a4ddb2e4f14aecb0b40409ea79b186"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22a4ddb2e4f14aecb0b40409ea79b186">contains</a> (const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *anotherEntity) const</td></tr>
<tr class="separator:a22a4ddb2e4f14aecb0b40409ea79b186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2712c5754c859d7d01b6a42ec6b8322d" id="r_a2712c5754c859d7d01b6a42ec6b8322d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2712c5754c859d7d01b6a42ec6b8322d">crosses</a> (const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *anotherEntity) const</td></tr>
<tr class="separator:a2712c5754c859d7d01b6a42ec6b8322d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c54532882a658db1453236fafde340" id="r_a21c54532882a658db1453236fafde340"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_t_s_l_entity_set.html">TSLEntitySet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21c54532882a658db1453236fafde340">difference</a> (const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *other) const</td></tr>
<tr class="separator:a21c54532882a658db1453236fafde340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9c59ce0669ae129bbc77b1d85dde24" id="r_a1a9c59ce0669ae129bbc77b1d85dde24"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a9c59ce0669ae129bbc77b1d85dde24">draw</a> (int uniqueSurfaceID, <a class="el" href="class_t_s_l_rendering_interface.html">TSLRenderingInterface</a> *renderingInterface, const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent, <a class="el" href="group__apigroup__geometry__api.html#ga7d3bacfc1969785828923139c1cb10d1">TSLRenderLevel</a> renderLevel, double screenResolution)=0</td></tr>
<tr class="separator:a1a9c59ce0669ae129bbc77b1d85dde24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc5455429edf725b8a42b44f184f6aa" id="r_abcc5455429edf725b8a42b44f184f6aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abcc5455429edf725b8a42b44f184f6aa">envelope</a> (int uniqueSurfaceID)</td></tr>
<tr class="separator:abcc5455429edf725b8a42b44f184f6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab545a16bbe351f24539fe582ba6f69fc" id="r_ab545a16bbe351f24539fe582ba6f69fc"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab545a16bbe351f24539fe582ba6f69fc">equals</a> (const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *anotherEntity) const</td></tr>
<tr class="separator:ab545a16bbe351f24539fe582ba6f69fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a797c12f3658faa5ddf7ad1bd2da33c49" id="r_a797c12f3658faa5ddf7ad1bd2da33c49"><td class="memItemLeft" align="right" valign="top">virtual unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a797c12f3658faa5ddf7ad1bd2da33c49">inMemorySize</a> ()</td></tr>
<tr class="separator:a797c12f3658faa5ddf7ad1bd2da33c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679a24c36ebb000452ba82fa1667defc" id="r_a679a24c36ebb000452ba82fa1667defc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_t_s_l_entity_set.html">TSLEntitySet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a679a24c36ebb000452ba82fa1667defc">intersection</a> (const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *anotherEntity) const</td></tr>
<tr class="separator:a679a24c36ebb000452ba82fa1667defc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b27274f509f68e9821902047ad7229f" id="r_a5b27274f509f68e9821902047ad7229f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b27274f509f68e9821902047ad7229f">intersects</a> (const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *anotherEntity) const</td></tr>
<tr class="separator:a5b27274f509f68e9821902047ad7229f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a781ff4c0296f89e8261a5fd0fa69edaa" id="r_a781ff4c0296f89e8261a5fd0fa69edaa"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a781ff4c0296f89e8261a5fd0fa69edaa">overlaps</a> (const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *anotherEntity) const</td></tr>
<tr class="separator:a781ff4c0296f89e8261a5fd0fa69edaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91ab2c043751e868844fc5a06ba06cf4" id="r_a91ab2c043751e868844fc5a06ba06cf4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91ab2c043751e868844fc5a06ba06cf4">releaseResources</a> (int surfaceID)</td></tr>
<tr class="separator:a91ab2c043751e868844fc5a06ba06cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a41a5073e4017aa6d975e8da99b5038" id="r_a5a41a5073e4017aa6d975e8da99b5038"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a41a5073e4017aa6d975e8da99b5038">rotate</a> (double angle, const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> *origin=NULL)</td></tr>
<tr class="separator:a5a41a5073e4017aa6d975e8da99b5038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d1c623b7a73f590e9d9ba3129577c5" id="r_a64d1c623b7a73f590e9d9ba3129577c5"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a64d1c623b7a73f590e9d9ba3129577c5">save</a> (<a class="el" href="class_t_s_lofstream.html">TSLofstream</a> &amp;stream)</td></tr>
<tr class="separator:a64d1c623b7a73f590e9d9ba3129577c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa47f9a2b02ec2a831f04ccb513152eac" id="r_aa47f9a2b02ec2a831f04ccb513152eac"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa47f9a2b02ec2a831f04ccb513152eac">scale</a> (double scaleOnX, double scaleOnY, const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> *origin=NULL)</td></tr>
<tr class="separator:aa47f9a2b02ec2a831f04ccb513152eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb12e02144cf6bf0e7262ffb445a52b" id="r_a5fb12e02144cf6bf0e7262ffb445a52b"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb12e02144cf6bf0e7262ffb445a52b">squareDistance</a> (const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;point, const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> *aperture=NULL, bool useRenderedExtent=true, int drawingSurfaceID=-1) const</td></tr>
<tr class="separator:a5fb12e02144cf6bf0e7262ffb445a52b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03693c8b01bbcf439497965aea4b6bef" id="r_a03693c8b01bbcf439497965aea4b6bef"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03693c8b01bbcf439497965aea4b6bef">squareDistance</a> (const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *otherEntity) const</td></tr>
<tr class="separator:a03693c8b01bbcf439497965aea4b6bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbef8db2a387f18ec564791316d6329f" id="r_adbef8db2a387f18ec564791316d6329f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbef8db2a387f18ec564791316d6329f">touches</a> (const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *anotherEntity) const</td></tr>
<tr class="separator:adbef8db2a387f18ec564791316d6329f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5944157d32466a28f617894216888ae" id="r_ac5944157d32466a28f617894216888ae"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5944157d32466a28f617894216888ae">translate</a> (TSLTMC xoffset, TSLTMC yoffset)</td></tr>
<tr class="separator:ac5944157d32466a28f617894216888ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1b3f88417e48b1e6b5704019b96f5f" id="r_a3f1b3f88417e48b1e6b5704019b96f5f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_t_s_l_entity_set.html">TSLEntitySet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f1b3f88417e48b1e6b5704019b96f5f">unionWith</a> (const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *anotherEntity) const</td></tr>
<tr class="separator:a3f1b3f88417e48b1e6b5704019b96f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4b72c67da0588bc05baf4648fa3f3c" id="r_aae4b72c67da0588bc05baf4648fa3f3c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae4b72c67da0588bc05baf4648fa3f3c">valid</a> ()</td></tr>
<tr class="separator:aae4b72c67da0588bc05baf4648fa3f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73e3387371ed408645a973cf153c4ae4" id="r_a73e3387371ed408645a973cf153c4ae4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_t_s_l_coord.html">TSLCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a73e3387371ed408645a973cf153c4ae4">adjustedWeightedCentroid</a> ()</td></tr>
<tr class="memdesc:a73e3387371ed408645a973cf153c4ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserved for future use  <br /></td></tr>
<tr class="separator:a73e3387371ed408645a973cf153c4ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b52476efd5489fc4e9fb91680e9939a" id="r_a2b52476efd5489fc4e9fb91680e9939a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_t_s_l_coord.html">TSLCoord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b52476efd5489fc4e9fb91680e9939a">centreOfGravity</a> ()</td></tr>
<tr class="memdesc:a2b52476efd5489fc4e9fb91680e9939a"><td class="mdescLeft">&#160;</td><td class="mdescRight">reserved for future use  <br /></td></tr>
<tr class="separator:a2b52476efd5489fc4e9fb91680e9939a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4f37ecca0e01c22ba3380dab893b16c0" id="r_a4f37ecca0e01c22ba3380dab893b16c0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f37ecca0e01c22ba3380dab893b16c0">TSLClientUserGeometryEntity</a> ()</td></tr>
<tr class="separator:a4f37ecca0e01c22ba3380dab893b16c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa49763a0fab5a457f47fbc459b0c4221" name="aa49763a0fab5a457f47fbc459b0c4221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49763a0fab5a457f47fbc459b0c4221">&#9670;&#160;</a></span>~TSLClientUserGeometryEntity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TSLClientUserGeometryEntity::~TSLClientUserGeometryEntity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default destructor for ~TSLClientUserGeometryEntity </p>

</div>
</div>
<a id="a4f37ecca0e01c22ba3380dab893b16c0" name="a4f37ecca0e01c22ba3380dab893b16c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f37ecca0e01c22ba3380dab893b16c0">&#9670;&#160;</a></span>TSLClientUserGeometryEntity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TSLClientUserGeometryEntity::TSLClientUserGeometryEntity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor for <a class="el" href="class_t_s_l_client_user_geometry_entity.html">TSLClientUserGeometryEntity</a></p>
<p>Declared protected to prevent non-derived classes from accessing this class. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a73e3387371ed408645a973cf153c4ae4" name="a73e3387371ed408645a973cf153c4ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73e3387371ed408645a973cf153c4ae4">&#9670;&#160;</a></span>adjustedWeightedCentroid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> TSLClientUserGeometryEntity::adjustedWeightedCentroid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reserved for future use </p>

</div>
</div>
<a id="a2b52476efd5489fc4e9fb91680e9939a" name="a2b52476efd5489fc4e9fb91680e9939a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b52476efd5489fc4e9fb91680e9939a">&#9670;&#160;</a></span>centreOfGravity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> TSLClientUserGeometryEntity::centreOfGravity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reserved for future use </p>

</div>
</div>
<a id="a22a4ddb2e4f14aecb0b40409ea79b186" name="a22a4ddb2e4f14aecb0b40409ea79b186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22a4ddb2e4f14aecb0b40409ea79b186">&#9670;&#160;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLClientUserGeometryEntity::contains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>anotherEntity</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>Tests if this entity 'spatially contains' another entity.</p>
<p>The base implementation returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anotherEntity</td><td>Another entity to perform test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the other entity is contained, false otherwise. </dd></dl>

</div>
</div>
<a id="a2712c5754c859d7d01b6a42ec6b8322d" name="a2712c5754c859d7d01b6a42ec6b8322d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2712c5754c859d7d01b6a42ec6b8322d">&#9670;&#160;</a></span>crosses()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLClientUserGeometryEntity::crosses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>anotherEntity</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>Tests if this entity 'spatially crosses' another entity.</p>
<p>The base implementation returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anotherEntity</td><td>Another entity to perform test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entities cross, false otherwise. </dd></dl>

</div>
</div>
<a id="a21c54532882a658db1453236fafde340" name="a21c54532882a658db1453236fafde340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21c54532882a658db1453236fafde340">&#9670;&#160;</a></span>difference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_t_s_l_entity_set.html">TSLEntitySet</a> * TSLClientUserGeometryEntity::difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>Creates the spatial difference between the two entities.</p>
<p>The base implementation returns NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Another entity to perform test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entity that represents the difference of the source TSLentity and another <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>. If no geometric difference is possible, then a NULL entity is returned. </dd></dl>

</div>
</div>
<a id="a1a9c59ce0669ae129bbc77b1d85dde24" name="a1a9c59ce0669ae129bbc77b1d85dde24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9c59ce0669ae129bbc77b1d85dde24">&#9670;&#160;</a></span>draw()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLClientUserGeometryEntity::draw </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>uniqueSurfaceID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_rendering_interface.html">TSLRenderingInterface</a> *</td>          <td class="paramname"><span class="paramname"><em>renderingInterface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#ga7d3bacfc1969785828923139c1cb10d1">TSLRenderLevel</a></td>          <td class="paramname"><span class="paramname"><em>renderLevel</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>screenResolution</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel pure-virtual">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class.</p>
<p>This method is called to draw the entity.</p>
<p>The user is responsible for setting up the rendering and drawing of the object. MapLink will not set up any rendering or apply any feature rendering to this object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uniqueSurfaceID</td><td>A unique surface number. Can be used for caching data as this will be unique to the calling surface.</td></tr>
    <tr><td class="paramname">renderingInterface</td><td>Rendering Interface. Allows the developer to draw using the MapLink Rendering Engine.</td></tr>
    <tr><td class="paramname">extent</td><td>Display drawing extent only.</td></tr>
    <tr><td class="paramname">renderLevel</td><td>The render level that the draw is being called for. The values passed are TSLRenderLevelMinusFive..TSLRenderLevelPlusFive. Most drawing occurs at TSLRenderLevelZero only.</td></tr>
    <tr><td class="paramname">screenResolution</td><td>The screen resolution (TMCs per Device Unit)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if an object is drawn, false otherwise. </dd></dl>

</div>
</div>
<a id="abcc5455429edf725b8a42b44f184f6aa" name="abcc5455429edf725b8a42b44f184f6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc5455429edf725b8a42b44f184f6aa">&#9670;&#160;</a></span>envelope()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> TSLClientUserGeometryEntity::envelope </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>uniqueSurfaceID</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>It is advised that this method is implemented as the returned envelope is used to decide if to call the drawing method. The default implementation returns a full TMC extent.</p>
<p>Query the minimum bounding box of the entity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uniqueSurfaceID</td><td>an id for a drawing surface. This is unique to a surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the minimum bounding box of the entity. </dd></dl>

</div>
</div>
<a id="ab545a16bbe351f24539fe582ba6f69fc" name="ab545a16bbe351f24539fe582ba6f69fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab545a16bbe351f24539fe582ba6f69fc">&#9670;&#160;</a></span>equals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLClientUserGeometryEntity::equals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>anotherEntity</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>Test for spatial equality with another entity.</p>
<p>The base implementation returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anotherEntity</td><td>Another entity to perform test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entities are the same, false otherwise. </dd></dl>

</div>
</div>
<a id="a797c12f3658faa5ddf7ad1bd2da33c49" name="a797c12f3658faa5ddf7ad1bd2da33c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a797c12f3658faa5ddf7ad1bd2da33c49">&#9670;&#160;</a></span>inMemorySize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual unsigned int TSLClientUserGeometryEntity::inMemorySize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>The base implementation returns the memory size for this class only.</p>
<dl class="section return"><dt>Returns</dt><dd>an estimate of the in memory size in bytes for the class. </dd></dl>

</div>
</div>
<a id="a679a24c36ebb000452ba82fa1667defc" name="a679a24c36ebb000452ba82fa1667defc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679a24c36ebb000452ba82fa1667defc">&#9670;&#160;</a></span>intersection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_t_s_l_entity_set.html">TSLEntitySet</a> * TSLClientUserGeometryEntity::intersection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>anotherEntity</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>Creates a spatial intersection between the two entities.</p>
<p>The base implementation returns NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anotherEntity</td><td>Another entity to perform test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An entity that represents the intersection of the source <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> with another <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>. </dd></dl>

</div>
</div>
<a id="a5b27274f509f68e9821902047ad7229f" name="a5b27274f509f68e9821902047ad7229f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b27274f509f68e9821902047ad7229f">&#9670;&#160;</a></span>intersects()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLClientUserGeometryEntity::intersects </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>anotherEntity</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>Test for spatial intersection between the two entities.</p>
<p>The base implementation returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anotherEntity</td><td>Another entity to perform test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entities intersect, false otherwise. </dd></dl>

</div>
</div>
<a id="a781ff4c0296f89e8261a5fd0fa69edaa" name="a781ff4c0296f89e8261a5fd0fa69edaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a781ff4c0296f89e8261a5fd0fa69edaa">&#9670;&#160;</a></span>overlaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLClientUserGeometryEntity::overlaps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>anotherEntity</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>Tests if this entity 'spatially overlaps' another entity.</p>
<p>The base implementation returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anotherEntity</td><td>Another entity to perform test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entities overlap, false otherwise. </dd></dl>

</div>
</div>
<a id="a91ab2c043751e868844fc5a06ba06cf4" name="a91ab2c043751e868844fc5a06ba06cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91ab2c043751e868844fc5a06ba06cf4">&#9670;&#160;</a></span>releaseResources()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TSLClientUserGeometryEntity::releaseResources </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>surfaceID</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method is called when the Drawing Surface invalidates its native drawing resources.</p>
<p>The user will need to release any surface specific resources.</p>
<p>The use of this method is very dependent upon the Drawing Surface technology.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceID</td><td>A unique surface number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a41a5073e4017aa6d975e8da99b5038" name="a5a41a5073e4017aa6d975e8da99b5038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a41a5073e4017aa6d975e8da99b5038">&#9670;&#160;</a></span>rotate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLClientUserGeometryEntity::rotate </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>angle</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>The base implementation returns false.</p>
<p>Rotates the entity.</p>
<p>Rotates the <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> anti-clockwise by angle, about specified origin. Uses centroid as the reference of the rotation if origin is NULL.</p>
<p>Angle is given in radians.</p>
<p>For entities that have an internal rotation, such as text or symbols, this adds to the rotation angle, and possibly changes the position of the entity.</p>
<p>For entities that contain a CoordSet, the coordinates are changed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angle</td><td>Angle to rotate by, in radians, anti-clockwise +ve.</td></tr>
    <tr><td class="paramname">origin</td><td>Point to rotate about. NULL origin uses centroid.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the rotate occurred, false if the rotate could not be applied. If the rotate can not be applied then the entity is not changed. The only reason for the rotate not being applied is if an attempt is made to rotate the entity fully or partially outside TMC space. </dd></dl>

</div>
</div>
<a id="a64d1c623b7a73f590e9d9ba3129577c5" name="a64d1c623b7a73f590e9d9ba3129577c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d1c623b7a73f590e9d9ba3129577c5">&#9670;&#160;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int TSLClientUserGeometryEntity::save </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_lofstream.html">TSLofstream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>stream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is called to save the User Geometry object.</p>
<p>The save method should be implemented if you wish to persist your object when save is called on a layer.</p>
<p>It is suggested that you write out a header that clearly identifies the object type uniquely within your application or company. The value returned from this method is used when re-creating the object.</p>
<p>Notes:</p>
<ol type="1">
<li>The returned value is passed to any registered callback functions to identify the geometry object type saved. It is therefore suggested that you publish and track the use of these IDs in your application or SDK (OEM users) as the values must be unique.</li>
<li>The value returned will be passed to the load callback when the entity is being loaded.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The output file stream to store the User Geometry object data to.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a positive integer value that is unique to your application or company for this object type. Negative numbers are reserved for internal use only. </dd></dl>

</div>
</div>
<a id="aa47f9a2b02ec2a831f04ccb513152eac" name="aa47f9a2b02ec2a831f04ccb513152eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa47f9a2b02ec2a831f04ccb513152eac">&#9670;&#160;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLClientUserGeometryEntity::scale </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scaleOnX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scaleOnY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> *</td>          <td class="paramname"><span class="paramname"><em>origin</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>Scales this entity, equally in both directions.</p>
<p>The base implementation returns false.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scaleOnX,scaleOnY</td><td>Scaling factors to apply in the X and Y axes. 0 is invalid.</td></tr>
    <tr><td class="paramname">origin</td><td>Origin to scale about. If origin is NULL, the origin of the scale is the centroid of the <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the scale occurred, false if the scale could not be applied. If the scale can not be applied then the entity is not changed. The possible reasons for the scale not being applied are if an attempt is made to scale the entity fully or partially outside TMC space or scaling the entity too small. </dd></dl>

</div>
</div>
<a id="a5fb12e02144cf6bf0e7262ffb445a52b" name="a5fb12e02144cf6bf0e7262ffb445a52b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb12e02144cf6bf0e7262ffb445a52b">&#9670;&#160;</a></span>squareDistance() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double TSLClientUserGeometryEntity::squareDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> *</td>          <td class="paramname"><span class="paramname"><em>aperture</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useRenderedExtent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>drawingSurfaceID</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>This method calculates the shortest square distance between an entity and a point.</p>
<p>Depending upon the reason for this method being invoked, an aperture parameter maybe provided to reduce the calculations required, so that anything that falls outside the aperture envelope can be disregarded. If the entity does fall completely outside the aperture, DBL_MAX should be returned.</p>
<p>As entities may have a different extent when rendered, for instance due to scale based rendering attributes, a flag is provided to describe whether the rendered extent should be used to make this calculation. The drawing surface id of the drawing surface upon which the entity's rendered extent is take from is also provided.</p>
<p>The base implementation returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point to which the square distance should be calculated.</td></tr>
    <tr><td class="paramname">aperture</td><td>The aperture around the point, usually an equal distance in all directions, that may optionally be provided to reduce calculations.</td></tr>
    <tr><td class="paramname">useRenderedExtent</td><td>Flag to indicate whether the rendered extent of the entity should be used.</td></tr>
    <tr><td class="paramname">drawingSurfaceID</td><td>The ID the drawing surface that drew the entity. This is only relevant when the useRenderedExtent is set to true.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shortest square distance to the point, or -1 to indicate that an error occurred. </dd></dl>

</div>
</div>
<a id="a03693c8b01bbcf439497965aea4b6bef" name="a03693c8b01bbcf439497965aea4b6bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03693c8b01bbcf439497965aea4b6bef">&#9670;&#160;</a></span>squareDistance() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double TSLClientUserGeometryEntity::squareDistance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>otherEntity</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>This method calculates the shortest square distance between entities.</p>
<p>The otherEntity may be a group or series of groups. In this case the square distance returned is to the closest non-group entity.</p>
<p>The base implementation returns -1.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">otherEntity</td><td>entity to query the shortest distance too.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the shortest square distance to the otherEntity. Return -1 to indicate an error. </dd></dl>

</div>
</div>
<a id="adbef8db2a387f18ec564791316d6329f" name="adbef8db2a387f18ec564791316d6329f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbef8db2a387f18ec564791316d6329f">&#9670;&#160;</a></span>touches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLClientUserGeometryEntity::touches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>anotherEntity</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>The base implementation returns false.</p>
<p>Tests if this entity 'spatially touches' another entity.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anotherEntity</td><td>Another entity to perform test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the entities touch, false otherwise. </dd></dl>

</div>
</div>
<a id="ac5944157d32466a28f617894216888ae" name="ac5944157d32466a28f617894216888ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5944157d32466a28f617894216888ae">&#9670;&#160;</a></span>translate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLClientUserGeometryEntity::translate </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>xoffset</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>yoffset</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>The base implementation returns false.</p>
<p>Translates this entity by delta.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xoffset</td><td>delta applied to X coordinates. </td></tr>
    <tr><td class="paramname">yoffset</td><td>delta applied to Y coordinates.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the translate occurred, false if the translate could not be applied. If the translate can not be applied then the entity is not changed. The only reason for the translate not being applied is if an attempt is made to translate the entity fully or partially outside TMC space. </dd></dl>

</div>
</div>
<a id="a3f1b3f88417e48b1e6b5704019b96f5f" name="a3f1b3f88417e48b1e6b5704019b96f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1b3f88417e48b1e6b5704019b96f5f">&#9670;&#160;</a></span>unionWith()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_t_s_l_entity_set.html">TSLEntitySet</a> * TSLClientUserGeometryEntity::unionWith </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>anotherEntity</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>The base implementation returns NULL.</p>
<p>Creates a spatial union between the two entities.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">anotherEntity</td><td>Another entity to perform test against.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an entity that represents the union of the source <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> with another <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>. If no geometric union is possible, then a group containing the entities is returned. </dd></dl>

</div>
</div>
<a id="aae4b72c67da0588bc05baf4648fa3f3c" name="aae4b72c67da0588bc05baf4648fa3f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4b72c67da0588bc05baf4648fa3f3c">&#9670;&#160;</a></span>valid()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool TSLClientUserGeometryEntity::valid </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The developer needs to implement this method in their derived class if the functionality is required.</p>
<p>The base implementation returns true.</p>
<dl class="section return"><dt>Returns</dt><dd>true if valid false otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_client_user_geometry_entity.html">TSLClientUserGeometryEntity</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.2 | Documentation created Wed Jul 23 2025 17:42:38 | Generated with <a href="http://www.doxygen.org/index.html">Doxygen 1.13.2</a> | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
