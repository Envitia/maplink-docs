<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLOpenGLSurface Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.1.2.0.</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_open_g_l_surface.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_t_s_l_open_g_l_surface-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLOpenGLSurface Class Reference<div class="ingroups"><a class="el" href="group__apigroup__maplink__pro__developers__toolkit.html">MapLink Pro Developer Toolkit</a> &raquo; <a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html">MapLink OpenGL Drawing Surface API</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for TSLOpenGLSurface:</div>
<div class="dyncontent">
<div class="center"><img src="class_t_s_l_open_g_l_surface__inherit__graph.png" border="0" usemap="#a_t_s_l_open_g_l_surface_inherit__map" alt="Inheritance graph"/></div>
<map name="a_t_s_l_open_g_l_surface_inherit__map" id="a_t_s_l_open_g_l_surface_inherit__map">
<area shape="rect" title=" " alt="" coords="133,155,254,181"/>
<area shape="rect" href="class_t_s_l_e_g_l_surface.html" title=" " alt="" coords="22,229,120,256"/>
<area shape="poly" title=" " alt="" coords="161,192,94,231,91,226,158,187"/>
<area shape="rect" href="class_t_s_l_g_l_x_surface.html" title=" " alt="" coords="144,229,243,256"/>
<area shape="poly" title=" " alt="" coords="196,197,196,229,191,229,191,197"/>
<area shape="rect" href="class_t_s_l_w_g_l_surface.html" title=" " alt="" coords="268,229,370,256"/>
<area shape="poly" title=" " alt="" coords="230,187,298,226,296,231,227,192"/>
<area shape="rect" href="class_t_s_l_drawing_surface.html" title=" " alt="" coords="132,80,256,107"/>
<area shape="poly" title=" " alt="" coords="196,122,196,154,191,154,191,122"/>
<area shape="rect" href="class_t_s_l_drawing_surface_base.html" title=" " alt="" coords="118,5,269,32"/>
<area shape="poly" title=" " alt="" coords="196,48,196,80,191,80,191,48"/>
<area shape="rect" href="class_t_s_l_native_e_g_l_surface.html" title=" " alt="" coords="5,304,137,331"/>
<area shape="poly" title=" " alt="" coords="74,272,74,304,68,304,68,272"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Common class for functionality shared between all platform drawing surfaces that draw using OpenGL.</p>
<p>Only one OpenGL context per thread is allowed. Therefore there is a one to one relationship between the drawing surface and a thread. If an application wishes to migrate a context and the associated drawing surface to a different thread it must call the makeContextCurrent method on the derived drawing surface class from that thread.</p>
<p>Additionally this means that any function calls that result in draws occurring (such as drawDU or any methods which have a redraw parameter) must originate in the thread associated with the OpenGL context.</p>
<p>The drawing surface internally tracks the OpenGL state for performance reasons. This means that applications that modify the OpenGL state may cause incorrect rendering if the drawing surface is not notified of the change. Access to the internal state tracker is provided through the <a class="el" href="#a005d2645e416e78abf3321ef206849c9">stateTracker()</a> method - applications can use this class to ensure the drawing surface maintains a consistent view of the current OpenGL state.</p>
<p>Rendering inside custom data layers can normally only be performed using Open GL or the <a class="el" href="class_t_s_l_rendering_interface.html">TSLRenderingInterface</a>. Any drawing performed using GDI or X11 will not display correctly. To use GDI or X11 in conjunction with the OpenGL drawing surface the layer must be marked as a non-native layer using the TSLPropertyNonNativeDrawing data layer property. Specific information on using non-native layers can be found in the class documentation for each of the drawing surface platform interface classes and the MapLink developer's guide.</p>
<p>Note that the TSLOptionDoubleBuffered drawing surface option has no effect on the drawing surface. Any OpenGL contexts created by the surface will automatically be double buffered.</p>
<h1><a class="anchor" id="opengl_ds_gpu_drivers"></a>
GPU and device drivers</h1>
<p>The MapLink Pro <a class="el" href="class_t_s_l_open_g_l_surface.html">TSLOpenGLSurface</a> works best with either NVIDIA or AMD GPUs.</p>
<p>The following should force the selection of either on Windows if the machine has multiple GPUs and the device drivers are sufficiently new enough.</p>
<div class="fragment"><div class="line"><span class="keyword">extern</span> <span class="stringliteral">&quot;C&quot;</span> {</div>
<div class="line">  __declspec(dllexport) <span class="keywordtype">int</span> AmdPowerXpressRequestHighPerformance = 1;</div>
<div class="line">  __declspec(dllexport) DWORD NvOptimusEnablement = 0x00000001;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The MapLink Pro <a class="el" href="class_t_s_l_open_g_l_surface.html">TSLOpenGLSurface</a> will work with Intel GPUs however you need the latest drivers directly from Intel on Windows and the latest Mesa drivers on Linux (potentially with patches for Haswell and older, ideally you should use newer GPUs from Intel).</p>
<p>If an application crashes inside of the OpenGL drivers then we would highly recommend you first upgrade with drivers directly from the GPU manufacturer and retest your application.</p>
<h1><a class="anchor" id="realtime_reprojection_details"></a>
Realtime Reprojection</h1>
<p>The OpenGL Drawing Surface supports the concept of reprojecting vector and raster at runtime on the GPU.</p>
<p>The following projections are currently supported:</p>
<ul>
<li>Mercator</li>
<li>Transverse Mercator</li>
<li>Stereographic</li>
<li>Gnomonic</li>
</ul>
<p>Additional projections can be added if necessary, please contact <a href="#" onclick="location.href='mai'+'lto:'+'sal'+'es'+'@en'+'vi'+'tia'+'.c'+'om'; return false;">sales<span class="obfuscator">.nosp@m.</span>@env<span class="obfuscator">.nosp@m.</span>itia.<span class="obfuscator">.nosp@m.</span>com</a> to discuss.</p>
<p>This functionality relies upon OpenGL extensions that require an up-to-date OpenGL driver and fairly modern hardware.</p>
<p>This extension has been implemented for the Haswell 4600 GPU on Linux. Extensive testing has been done with this GPU and a number of issues have been found and work-arounds were implemented. A number of issues were resolved at the driver or lower level. As such we would recommend that the developer tests the target hardware early enough to ensure that the GPU and drivers are sufficiently capable and robust for this extension. If necessary we can provide consultancy to help with this assessment or any necessary tailoring in MapLink to support a particular GPU.</p>
<p>OpenGL 3.3 is required with the following OpenGL extensions:</p>
<ul>
<li>ARB_transform_feedback2</li>
<li>ARB_shading_language_420pack</li>
<li>ARB_draw_indirect</li>
<li>ARB_gpu_shader_fp64 (FP64)</li>
<li>ARB_shader_subroutine</li>
</ul>
<p>There are fallback mechanisms for all the above extensions, however the fallbacks have an impact on performance and complexity of the shaders.</p>
<p>The FP64 extension is one of the more critical extensions. Only a small number of the projections are supported if this extension is not present as we have to emulate the 64bit double maths. This significantly complicates the shader code.</p>
<p>The following extensions are used if present:</p>
<ul>
<li>ARB_texture_storage</li>
<li>ARB_shader_image_load_store</li>
</ul>
<h2><a class="anchor" id="realtime_reprojection_layers_supported"></a>
DataLayers Supported</h2>
<p>The following DataLayers are supported when this extension is enabled:</p>
<ul>
<li><a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a></li>
<li><a class="el" href="class_t_s_l_static_map_data_layer.html">TSLStaticMapDataLayer</a></li>
<li><a class="el" href="class_t_s_l_k_m_l_data_layer.html">TSLKMLDataLayer</a></li>
<li><a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a></li>
<li><a class="el" href="class_t_s_l_custom_data_layer.html">TSLCustomDataLayer</a></li>
</ul>
<p>The following layers should work but have not been validated:</p>
<ul>
<li><a class="el" href="class_t_s_l_raster_data_layer.html">TSLRasterDataLayer</a></li>
<li><a class="el" href="class_t_s_l_filter_data_layer.html">TSLFilterDataLayer</a> and associated layers</li>
<li><a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> - please use the Static version.</li>
</ul>
<p>The following layers will not work:</p>
<ul>
<li>Any grid layer. This limitation is being looked at.</li>
<li><a class="el" href="class_t_s_l_s63_data_layer.html">TSLS63DataLayer</a>. Some of the issues will be addressed when the grid layers are dealt with.</li>
</ul>
<p>The <a class="el" href="class_t_s_l_custom_data_layer.html">TSLCustomDataLayer</a> is known to work however there are limitations with how you can use a custom data-layer.</p>
<p>The <a class="el" href="class_t_s_l_rendering_interface.html">TSLRenderingInterface</a> does not support the drawing of all geometry. Only symbols and text can be drawn.</p>
<p>Layers can be drawn from a Custom data-layer. The contents of the layers can be automatically reprojected.</p>
<h2><a class="anchor" id="realtime_reprojection_data_conditioning"></a>
Data Conditioning</h2>
<p>All data that is to be reprojected at runtime has to be in a Scaled WGS84 Latitude/Longitude coordinate system.</p>
<p>The data should have sufficent points to ensure that lines are projected correctly and as expected. Very long lines will not have additional points added. Only the points present in the data will be reprojected.</p>
<h2><a class="anchor" id="realtime_reprojection_limitations"></a>
Limitations</h2>
<p>Realtime reprojection has a number of limitations that limit how the data is drawn and have an impact on performance. Please contact <a href="#" onclick="location.href='mai'+'lto:'+'sup'+'po'+'rt@'+'en'+'vit'+'ia'+'.co'+'m'; return false;">suppo<span class="obfuscator">.nosp@m.</span>rt@e<span class="obfuscator">.nosp@m.</span>nviti<span class="obfuscator">.nosp@m.</span>a.co<span class="obfuscator">.nosp@m.</span>m</a> for additional information or guidance.</p>
<ul>
<li>Custom datalayers can only draw text and symbols via the <a class="el" href="class_t_s_l_rendering_interface.html">TSLRenderingInterface</a>. Drawing with X11 or GDI is not supported when realtime reprojection is enabled for a Custom datalayer.</li>
<li>Text and symbols are positioned on the CPU. This is an expensive operation and care should be given to minimise the amount displayed are each detail level.</li>
<li>Text and symbol rotation is not currently corrected for the display projection.</li>
<li>Arc and Ellipses are not drawn correctly when displayed with multi-pass linestyles.</li>
<li>User geometry is not supported.</li>
<li>The Geometry Rendering has to be Feature based. Geometry based rendering is ignored.</li>
<li>If the Geometry is modified then you have to call notifyChanged() on the data-layer. This instructs MapLink to re-process the whole layer.</li>
<li>Rendering attributes can change but can result in re-batching.</li>
<li>Changing the FeatureID on a Geometry object (entity) will require notifyChanged() to be called.</li>
<li>Changing the Feature rendering require notifyChanged() to be called.</li>
<li>Decluttering on/off works TBC. Range decluttering is only evaluated on first draw.</li>
<li>Custom linestyles are expensive to draw (Pen Up/Down style). The linestyles may be drawn stretched or compressed. This occurs due to the reprojection of the line segments such that they may be stretched or compressed.</li>
<li>Lines will be drawn as single segments. Joins and end-caps will be square.</li>
<li>Data should be prepared to ensure that sufficent points are present so that the lines/polygons are correctly warped. The term is densified. This is particularly important for overlay geometry. Geodetic primitives should be considered as additional points are added between the control points.</li>
<li>Dynamic Renderers are excluded because this modifies the Tile contents. Please contact <a href="#" onclick="location.href='mai'+'lto:'+'sal'+'es'+'@en'+'vi'+'tia'+'.c'+'om'; return false;">sales<span class="obfuscator">.nosp@m.</span>@env<span class="obfuscator">.nosp@m.</span>itia.<span class="obfuscator">.nosp@m.</span>com</a> if you require this functionality as this will require additional development.</li>
<li>You can not share layers that are realtime reprojected between instances of <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</li>
</ul>
<h2><a class="anchor" id="realtime_reprojection_howto_setup_a_map_datalayer"></a>
Howto setup a Map DataLater</h2>
<p>A <a class="el" href="class_t_s_l_static_map_data_layer.html">TSLStaticMapDataLayer</a> is required to be added to the Drawing Surface. This is the coordinate providing layer.</p>
<p>Only a <a class="el" href="class_t_s_l_static_map_data_layer.html">TSLStaticMapDataLayer</a> can provide the data <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> and the Drawing <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a>.</p>
<p><a class="el" href="class_t_s_l_static_map_data_layer.html">TSLStaticMapDataLayer</a>'s need to be marked as Realtime Reprojection layer as follows:</p>
<div class="fragment"><div class="line">m_mapLayer = <span class="keyword">new</span> <a class="code hl_class" href="class_t_s_l_static_map_data_layer.html">TSLStaticMapDataLayer</a>();</div>
<div class="line"> </div>
<div class="line">m_mapLayer-&gt;addLoader( m_mapLayerLoader1, NULL, NULL, NULL, NULL );</div>
<div class="line">m_mapLayer-&gt;drawCacheSize( cacheSize );</div>
<div class="line"><span class="keywordflow">if</span>( !m_mapLayer-&gt;loadData( path.c_str() ) )</div>
<div class="line">{</div>
<div class="line">  <a class="code hl_class" href="class_t_s_l_simple_string.html">TSLSimpleString</a> message;</div>
<div class="line">  <a class="code hl_function" href="class_t_s_l_threaded_error_stack.html#a870191db0da07a3e4a8eb203e5f7d661">TSLThreadedErrorStack::errorString</a>( message );</div>
<div class="line">  QMessageBox::critical( NULL, <span class="stringliteral">&quot;Failed to load .map data&quot;</span>, message.<a class="code hl_function" href="class_t_s_l_simple_string.html#aa0267eef09d1d6b3a184617505be6bf3">c_str</a>(), QMessageBox::Ok );</div>
<div class="line">  <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">}</div>
<div class="line">surface-&gt;addDataLayer( m_mapLayer, name.c_str() );</div>
<div class="line">surface-&gt;setDataLayerProps( name.c_str(), <a class="code hl_enumvalue" href="group__apigroup__api.html#gga1c467581ddf31341ac6acf6baa297a9aa11081de5f8b4efc789043534dfebdd1c">TSLPropertyRealtimeReprojection</a>, <span class="keyword">true</span> );</div>
<div class="ttc" id="aclass_t_s_l_simple_string_html"><div class="ttname"><a href="class_t_s_l_simple_string.html">TSLSimpleString</a></div><div class="ttdef"><b>Definition</b> tslsimplestring.h:43</div></div>
<div class="ttc" id="aclass_t_s_l_simple_string_html_aa0267eef09d1d6b3a184617505be6bf3"><div class="ttname"><a href="class_t_s_l_simple_string.html#aa0267eef09d1d6b3a184617505be6bf3">TSLSimpleString::c_str</a></div><div class="ttdeci">const char * c_str() const</div><div class="ttdef"><b>Definition</b> tslsimplestring.h:509</div></div>
<div class="ttc" id="aclass_t_s_l_static_map_data_layer_html"><div class="ttname"><a href="class_t_s_l_static_map_data_layer.html">TSLStaticMapDataLayer</a></div><div class="ttdef"><b>Definition</b> tslstaticmapdatalayer.h:97</div></div>
<div class="ttc" id="aclass_t_s_l_threaded_error_stack_html_a870191db0da07a3e4a8eb203e5f7d661"><div class="ttname"><a href="class_t_s_l_threaded_error_stack.html#a870191db0da07a3e4a8eb203e5f7d661">TSLThreadedErrorStack::errorString</a></div><div class="ttdeci">static bool errorString(TSLSimpleString &amp;result, const char *hdr=&quot;&quot;, const int category=TSLErrorCategoryError|TSLErrorCategoryFatal)</div></div>
<div class="ttc" id="agroup__apigroup__api_html_gga1c467581ddf31341ac6acf6baa297a9aa11081de5f8b4efc789043534dfebdd1c"><div class="ttname"><a href="group__apigroup__api.html#gga1c467581ddf31341ac6acf6baa297a9aa11081de5f8b4efc789043534dfebdd1c">TSLPropertyRealtimeReprojection</a></div><div class="ttdeci">@ TSLPropertyRealtimeReprojection</div><div class="ttdef"><b>Definition</b> tslpropertyenum.h:148</div></div>
</div><!-- fragment --><p>The order shown above of the method calls is significant.</p>
<p>Reprojected layers must not be buffered (TSLPropertyBuffered). Reprojected layers can have an opacity value.</p>
<p>All other layers should use the coordinate providing layers 'data' coordinate system. This can be queried as follows:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *cs = NULL;</div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="class_t_s_l_data_layer.html">TSLDataLayer</a>* csLayer( m_surface-&gt;getCoordinateProvidingLayer() );</div>
<div class="line"><span class="keywordflow">if</span>( csLayer &amp;&amp; csLayer-&gt;layerType() == <a class="code hl_enumvalue" href="group__apigroup__api.html#ggaf8bedcb6358f6ef60075d2bbca8fe118a66570b4bb77d4b18f8721c02675a06a1">TSLDataLayerTypeStaticMapDataLayer</a> )</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="class_t_s_l_static_map_data_layer.html">TSLStaticMapDataLayer</a>* csLayerMap( <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code hl_class" href="class_t_s_l_static_map_data_layer.html">TSLStaticMapDataLayer</a>*<span class="keyword">&gt;</span>( csLayer ) );</div>
<div class="line">  cs = csLayerMap-&gt;queryMapCoordinateSystem();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_t_s_l_coordinate_system_html"><div class="ttname"><a href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a></div><div class="ttdef"><b>Definition</b> tslcoordinatesystem.h:95</div></div>
<div class="ttc" id="aclass_t_s_l_data_layer_html"><div class="ttname"><a href="class_t_s_l_data_layer.html">TSLDataLayer</a></div><div class="ttdef"><b>Definition</b> tsldatalayer.h:82</div></div>
<div class="ttc" id="agroup__apigroup__api_html_ggaf8bedcb6358f6ef60075d2bbca8fe118a66570b4bb77d4b18f8721c02675a06a1"><div class="ttname"><a href="group__apigroup__api.html#ggaf8bedcb6358f6ef60075d2bbca8fe118a66570b4bb77d4b18f8721c02675a06a1">TSLDataLayerTypeStaticMapDataLayer</a></div><div class="ttdeci">@ TSLDataLayerTypeStaticMapDataLayer</div><div class="ttdef"><b>Definition</b> tsldatalayertypeenum.h:96</div></div>
</div><!-- fragment --><p>'cs' if not NULL will be the <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> to use. If it is NULL then you do not have a <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a>.</p>
<p>The display projection is set using the following:</p>
<div class="fragment"><div class="line">m_currentCoordinteSystem = <a class="code hl_function" href="class_t_s_l_coordinate_system.html#aba4f9689ad049e53611b836d2997433b">TSLCoordinateSystem::createByDatumName</a>( 10005, <span class="stringliteral">&quot;CS&quot;</span>, <span class="stringliteral">&quot;World Geodetic System 1984&quot;</span> );</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span>( m_currentCoordinteSystem )</div>
<div class="line">{</div>
<div class="line">  setOK = m_currentCoordinteSystem-&gt;setProjectionMercator( newProjectionCentreLon, 0.0 );</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//Minimum Map Unit width the surface will zoom to</span></div>
<div class="line">minimumRange = 25000000;</div>
<div class="line">greatCircleDistance = 9704000.0;</div>
<div class="line"> </div>
<div class="line">m_mapLayer-&gt;clearRuntimeProjection();</div>
<div class="line">m_mapLayer-&gt;setRuntimeProjection( m_currentCoordinteSystem, greatCircleDistance, NULL, NULL );</div>
<div class="ttc" id="aclass_t_s_l_coordinate_system_html_aba4f9689ad049e53611b836d2997433b"><div class="ttname"><a href="class_t_s_l_coordinate_system.html#aba4f9689ad049e53611b836d2997433b">TSLCoordinateSystem::createByDatumName</a></div><div class="ttdeci">static TSLCoordinateSystem * createByDatumName(int id, const char *name, const char *datumName)</div></div>
</div><!-- fragment --><p>The projection centre is set using the following:</p>
<div class="fragment"><div class="line">m_mapLayer-&gt;setRuntimeProjectionOrigin( newProjectionCentreLat, newProjectionCentreLon, NULL, NULL );</div>
</div><!-- fragment --><p>When a projection is changed there will be a stall while the shaders are switched and the GPU data buffers are updated.</p>
<dl class="section note"><dt>Note</dt><dd>The drawing surface will make all map-layer runtime coordinate system TMC per MU and offsets match. The TMC per MU will be the smallest value from all the layers. </dd>
<dd>
The runtime coordinate system origins must all match.</dd></dl>
<h2><a class="anchor" id="realtime_reprojection_picking"></a>
Picking</h2>
<p>The geometry that is displayed on the screen uses the Display <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> from the coordinate providing layer.</p>
<p>The pixel position should be converted to latitude and longitude using the Display <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a>.</p>
<p>This latitude and longitude should then be converted to the TMC coordinate system of the layer that needs to be queried.</p>
<p>If the methods on the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> are used then the conversions occur internally using the coordinate providing layer.</p>
<h2><a class="anchor" id="realtime_reprojeciton_setting_up_a_standarddatalayer"></a>
Setting up a TSLStandardDataLayer</h2>
<p>The geometry inside of a <a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> must be in the Coordinate Providing layers TMC coordinate system.</p>
<p>Geodetic Primitives will automatically reproject and the positions of non-geodetic primitives will also be reprojected.</p>
<p>The <a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> has to be marked to be included as part of the reprojection as follows:</p>
<div class="fragment"><div class="line">surface-&gt;addDataLayer( m_stdDataLayer, layerName );</div>
<div class="line">surface-&gt;setDataLayerProps( layerName, <a class="code hl_enumvalue" href="group__apigroup__api.html#gga1c467581ddf31341ac6acf6baa297a9aa11081de5f8b4efc789043534dfebdd1c">TSLPropertyRealtimeReprojection</a>, <span class="keyword">true</span> );</div>
</div><!-- fragment --><h2><a class="anchor" id="realtime_reprojection_coordinate_provifing_layer"></a>
Coordinate Providing Layer and Coordinate Systems</h2>
<p>The coordinate providing layer may be obtained using the following:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *cs = NULL;  <span class="comment">// TSLCoordinateSystem to use for conversions</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="class_t_s_l_data_layer.html">TSLDataLayer</a> *layer = m_surface-&gt;getCoordinateProvidingLayer();</div>
<div class="line"><span class="keywordflow">if</span>( csLayer &amp;&amp; csLayer-&gt;layerType() == <a class="code hl_enumvalue" href="group__apigroup__api.html#ggaf8bedcb6358f6ef60075d2bbca8fe118a66570b4bb77d4b18f8721c02675a06a1">TSLDataLayerTypeStaticMapDataLayer</a> )</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="class_t_s_l_static_map_data_layer.html">TSLStaticMapDataLayer</a>* csLayerMap( <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code hl_class" href="class_t_s_l_static_map_data_layer.html">TSLStaticMapDataLayer</a>*<span class="keyword">&gt;</span>( csLayer ) );</div>
<div class="line">  cs = csLayerMap-&gt;queryMapCoordinateSystem();</div>
<div class="line">}</div>
</div><!-- fragment --><p>The two types of <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> can be obtained via:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *dataCoordinateSystem = csLayerMap-&gt;queryMapCoordinateSystem();</div>
<div class="line"><a class="code hl_class" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *displayCoordinateSystem = csLayerMap-&gt;queryRuntimeCoordinateSystem();</div>
</div><!-- fragment --><p>The 'dataCoordinateSystem' is the the coordinate system that the data is in. Any non-coordinate providing layer should use this to position the geometry correctly.</p>
<p>the 'displayCoordinateSystem' is used by the GPU for drawing the geometry. This should be used for converting positions on the screen to latitude and longitude.</p>
<h2><a class="anchor" id="realtime_reprojection_using_a_tslcustomdatalayer"></a>
Using a TSLCustomDataLayer</h2>
<p>There are a number of limitations around using a custom datalayer. However custom datalayers are still a very powerful concept. The <a class="el" href="class_t_s_l_k_m_l_data_layer.html">TSLKMLDataLayer</a> has been implemented as a custom datalayer. The data is actually stored in a set of <a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> and <a class="el" href="class_t_s_l_raster_data_layer.html">TSLRasterDataLayer</a> which are drawn via the <a class="el" href="class_t_s_l_rendering_interface.html">TSLRenderingInterface</a>.</p>
<p>There are essentially three ways of drawing when using Realtime Reprojection:</p>
<ul>
<li>Draw symbols and text only via the <a class="el" href="class_t_s_l_rendering_interface.html">TSLRenderingInterface</a></li>
<li>Draw using OpenGL or <a class="el" href="class_t_s_l_open_g_l_track_helper.html">TSLOpenGLTrackHelper</a>.</li>
<li>Draw using a datalayer.</li>
</ul>
<p>The AdvancedSample shows how to draw using the first two uses of a <a class="el" href="class_t_s_l_custom_data_layer.html">TSLCustomDataLayer</a>.</p>
<p>The <a class="el" href="class_t_s_l_k_m_l_data_layer.html">TSLKMLDataLayer</a> uses the third. Please refer to the <a class="el" href="class_t_s_l_client_custom_data_layer.html">TSLClientCustomDataLayer</a> and <a class="el" href="class_t_s_l_custom_data_layer_handler.html">TSLCustomDataLayerHandler</a> documentation.</p>
<p>In essence if you are drawing using OpenGL, Text/Symbols, or a datalayer you need to position the geometry using the coordinate providing layers data coordinate system, not the display coordinate system.</p>
<h2><a class="anchor" id="realtime_reprojecton_using_a_tslkmldatalayer"></a>
Using a TSLKMLDataLayer</h2>
<p>The <a class="el" href="class_t_s_l_k_m_l_data_layer.html">TSLKMLDataLayer</a> needs to be told what <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> to use before loading the KML data.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code hl_class" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *cs = NULL;  <span class="comment">// TSLCoordinateSystem to use for conversions</span></div>
<div class="line"><span class="keyword">const</span> <a class="code hl_class" href="class_t_s_l_data_layer.html">TSLDataLayer</a> *layer = m_surface-&gt;getCoordinateProvidingLayer();</div>
<div class="line"><span class="keywordflow">if</span>( csLayer &amp;&amp; csLayer-&gt;layerType() == <a class="code hl_enumvalue" href="group__apigroup__api.html#ggaf8bedcb6358f6ef60075d2bbca8fe118a66570b4bb77d4b18f8721c02675a06a1">TSLDataLayerTypeStaticMapDataLayer</a> )</div>
<div class="line">{</div>
<div class="line">  <span class="keyword">const</span> <a class="code hl_class" href="class_t_s_l_static_map_data_layer.html">TSLStaticMapDataLayer</a>* csLayerMap( <span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span><a class="code hl_class" href="class_t_s_l_static_map_data_layer.html">TSLStaticMapDataLayer</a>*<span class="keyword">&gt;</span>( csLayer ) );</div>
<div class="line">  cs = csLayerMap-&gt;queryMapCoordinateSystem();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">kmlDataLayer-&gt;<a class="code hl_function" href="class_t_s_l_data_layer.html#a8c58b8475acb63c5a3f031e0cac28449">setCoordinateSystem</a>( cs );</div>
<div class="ttc" id="aclass_t_s_l_data_layer_html_a8c58b8475acb63c5a3f031e0cac28449"><div class="ttname"><a href="class_t_s_l_data_layer.html#a8c58b8475acb63c5a3f031e0cac28449">TSLDataLayer::setCoordinateSystem</a></div><div class="ttdeci">bool setCoordinateSystem(const TSLCoordinateSystem *coordinateSystem)</div></div>
</div><!-- fragment --><h2><a class="anchor" id="realtime_reprojection_maplink_studio"></a>
MapLink Studio Map Creation requirements</h2>
<p>The following settings are guidelines for a Realtime reprojection map.</p>
<ul>
<li>Map Coordinate System - Realtime Reprojection</li>
<li>TMC Per MU : 5 Million</li>
<li>TMC offset : 0, 0</li>
<li>Tiling : Manual, at least 4 tiles at the top-level (least detailed).</li>
<li>Tiling Strategy : Range Based</li>
<li>Perceptual Filter : Optional</li>
<li>Raster Pyramid settings<ul>
<li>Nugget Size 1024x1024</li>
<li>Optimise Pyramid off</li>
<li>'Tiling only' should be checked if the map will only be displayed with the OpenGL drawing surface.</li>
<li>'Maximum Pyramid depth' should be set to 4 if the map will also be displayed with other surfaces.</li>
<li>Raster format: TIFF (quickest) / PNG (next quickest) / JPEG (slowest)</li>
</ul>
</li>
<li>Number of Layers<ul>
<li>The number of layers should be sufficent to ensure too much data is not displayed at each display range.</li>
</ul>
</li>
<li>Tile on Disk Size<ul>
<li>The vector tiles on disk should not exceed 1Mb. The main impact is on load and display performance so you may be able to adjust the size based upon your application and hardware.</li>
<li>Raster tile size you have less control about.</li>
</ul>
</li>
<li>Optimisations<ul>
<li>Map Generation Dialog - turn on Remove all unused features</li>
<li>Convert Colour index values to RGB</li>
</ul>
</li>
</ul>
<p>The realtime reprojection code will also use Optimised tile data. This will save time on loading data as we will have one less processing stage.</p>
<h2><a class="anchor" id="realtime_reprojection_cache_sizing"></a>
Cache Sizing</h2>
<p>The cache size allocated to a layer needs to be at least double what you would normally assign. This is because there will be two copies of the data, one un-projected and the second projected.</p>
<h2><a class="anchor" id="realtime_reprojection_potential_gpu_issues"></a>
Potential GPU issues</h2>
<p>GPU FP64 support may not be present. We can implement the projections using FP65 emulation. Please contact <a href="#" onclick="location.href='mai'+'lto:'+'sal'+'es'+'@en'+'vi'+'tia'+'.c'+'om'; return false;">sales<span class="obfuscator">.nosp@m.</span>@env<span class="obfuscator">.nosp@m.</span>itia.<span class="obfuscator">.nosp@m.</span>com</a> to discuss.</p>
<p>GPU sin and cos may not be accurate or there may be issues with particular values or quadrants. This seems to be very dependent on GPU and may require specific work arounds in the shader. Please contact <a href="#" onclick="location.href='mai'+'lto:'+'sal'+'es'+'@en'+'vi'+'tia'+'.c'+'om'; return false;">sales<span class="obfuscator">.nosp@m.</span>@env<span class="obfuscator">.nosp@m.</span>itia.<span class="obfuscator">.nosp@m.</span>com</a> to discuss if you find a problem with the GPU you are using.</p>
<p>GPU atan2 and atan may have problems with particular values or quadrants. This seems to be a general issue and the work around is implemented generically.</p>
<p>Shader sub-routines may cause register spill warnings. You will need to update your drivers. On Linux this may require the building of Mesa with a set of specific patches or from a development branch. Please contact <a href="#" onclick="location.href='mai'+'lto:'+'sup'+'po'+'rt@'+'en'+'vit'+'ia'+'.co'+'m'; return false;">suppo<span class="obfuscator">.nosp@m.</span>rt@e<span class="obfuscator">.nosp@m.</span>nviti<span class="obfuscator">.nosp@m.</span>a.co<span class="obfuscator">.nosp@m.</span>m</a> for more information.</p>
<h2><a class="anchor" id="realtime_reprojection_display_issues"></a>
Mercator display issues near the poles</h2>
<p>The Mercator projection currently exhibits some display artifacts near the north and south poles, specifically missing fills in the displayed polygons. This is due to the tiling setup in the shipped maps, and the amount the data is warped near the poles.</p>
<p>Until these issues are fixed there are 2 workarounds. For more information please contact <a href="#" onclick="location.href='mai'+'lto:'+'sup'+'po'+'rt@'+'en'+'vit'+'ia'+'.co'+'m'; return false;">suppo<span class="obfuscator">.nosp@m.</span>rt@e<span class="obfuscator">.nosp@m.</span>nviti<span class="obfuscator">.nosp@m.</span>a.co<span class="obfuscator">.nosp@m.</span>m</a>.</p>
<p>The first workaround is to increase the number of (vertical) tiles within the map. This will reduce the visible artifacts by inserting a tile border near the poles. This will not eliminate the artifacts, however will maintain compatibility with the other supported projections. For this workaround the recommended minimum tiling is 4 x 16. Note that the increased number of tiles will cause a performance reduction when viewing data near the poles.</p>
<p>The second workaround is to apply output clipping to the valid range of the Mercator projection (-80 to 84 degrees latitude). This will eliminate the artifacts when displaying Mercator, however will cause missing data over the poles for other projections. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a41b4c4e88762628170d56976a25ba4d6" id="r_a41b4c4e88762628170d56976a25ba4d6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41b4c4e88762628170d56976a25ba4d6">~TSLOpenGLSurface</a> ()</td></tr>
<tr class="separator:a41b4c4e88762628170d56976a25ba4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3506c0601af61c3163dee0f67936a67f" id="r_a3506c0601af61c3163dee0f67936a67f"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3506c0601af61c3163dee0f67936a67f">acquireDepthSlice</a> ()</td></tr>
<tr class="separator:a3506c0601af61c3163dee0f67936a67f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f323a8671c859ea87dd71b66e44be6" id="r_a66f323a8671c859ea87dd71b66e44be6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66f323a8671c859ea87dd71b66e44be6">clone</a> (bool copyUserData=false)</td></tr>
<tr class="separator:a66f323a8671c859ea87dd71b66e44be6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabe02b0e04ad6577d4697cb6343dbddd" id="r_aabe02b0e04ad6577d4697cb6343dbddd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aabe02b0e04ad6577d4697cb6343dbddd">coordinateCentreX</a> () const</td></tr>
<tr class="separator:aabe02b0e04ad6577d4697cb6343dbddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d02d7fd0e882153b3753146fde2ec79" id="r_a4d02d7fd0e882153b3753146fde2ec79"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4d02d7fd0e882153b3753146fde2ec79">coordinateCentreY</a> () const</td></tr>
<tr class="separator:a4d02d7fd0e882153b3753146fde2ec79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8934d8e210f322de9ce93c5eeb5f9469" id="r_a8934d8e210f322de9ce93c5eeb5f9469"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_open_g_l_surface.html">TSLOpenGLSurface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8934d8e210f322de9ce93c5eeb5f9469">createChildSurface</a> ()</td></tr>
<tr class="separator:a8934d8e210f322de9ce93c5eeb5f9469"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52609d927120349229968498a49bcfa7" id="r_a52609d927120349229968498a49bcfa7"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52609d927120349229968498a49bcfa7">currentDepthSlice</a> () const</td></tr>
<tr class="separator:a52609d927120349229968498a49bcfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2517935e510fb391144ad272f8ad2fb2" id="r_a2517935e510fb391144ad272f8ad2fb2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2517935e510fb391144ad272f8ad2fb2">depthSliceIncrement</a> () const</td></tr>
<tr class="separator:a2517935e510fb391144ad272f8ad2fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6f16f01de584b6c2021169792fa264" id="r_abf6f16f01de584b6c2021169792fa264"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf6f16f01de584b6c2021169792fa264">flushPendingDraws</a> ()</td></tr>
<tr class="separator:abf6f16f01de584b6c2021169792fa264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e6b0788faf8743ff23a265923b15a0" id="r_ac4e6b0788faf8743ff23a265923b15a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4e6b0788faf8743ff23a265923b15a0">enableRealtimeReprojection</a> (const char *name, bool enable)</td></tr>
<tr class="separator:ac4e6b0788faf8743ff23a265923b15a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf3bab5c2e8e44c07e278faa6f9c16da" id="r_adf3bab5c2e8e44c07e278faa6f9c16da"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf3bab5c2e8e44c07e278faa6f9c16da">getSwitchRangeForFP64</a> () const</td></tr>
<tr class="separator:adf3bab5c2e8e44c07e278faa6f9c16da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1656726e7b9a9d1ce0001a4b2fca1f0d" id="r_a1656726e7b9a9d1ce0001a4b2fca1f0d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1656726e7b9a9d1ce0001a4b2fca1f0d">getLayerStorageStrategy</a> (const char *layerName, <a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga5a179736bbaa6140780153039419128f">TSLOpenGLStorageStrategyEnum</a> &amp;strategy) const</td></tr>
<tr class="separator:a1656726e7b9a9d1ce0001a4b2fca1f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87483718d40f8424d852464ff4f4521c" id="r_a87483718d40f8424d852464ff4f4521c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87483718d40f8424d852464ff4f4521c">getLayerTransparencyHint</a> (const char *layerName, <a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga38981acc5b361a3b59eede68ba2021a4">TSLOpenGLTransparencyHintEnum</a> &amp;hint) const</td></tr>
<tr class="separator:a87483718d40f8424d852464ff4f4521c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5118651f8e45e88b96e8d20c2fc5560e" id="r_a5118651f8e45e88b96e8d20c2fc5560e"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5118651f8e45e88b96e8d20c2fc5560e">incrementDepthSlice</a> (uint32_t numDrawItems)</td></tr>
<tr class="separator:a5118651f8e45e88b96e8d20c2fc5560e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b6dd338e013a8f23cf55b90e8bd577" id="r_af4b6dd338e013a8f23cf55b90e8bd577"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af4b6dd338e013a8f23cf55b90e8bd577">modelViewMatrix</a> () const</td></tr>
<tr class="separator:af4b6dd338e013a8f23cf55b90e8bd577"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6281b7c2a5b0cc7230ef4800e90450" id="r_a4a6281b7c2a5b0cc7230ef4800e90450"><td class="memItemLeft" align="right" valign="top">const float *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a6281b7c2a5b0cc7230ef4800e90450">projectionMatrix</a> () const</td></tr>
<tr class="separator:a4a6281b7c2a5b0cc7230ef4800e90450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc9d44735c93c48302be5a84aad58aa" id="r_a8dc9d44735c93c48302be5a84aad58aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dc9d44735c93c48302be5a84aad58aa">setAntialiasingMode</a> (<a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga673d8ea7fa2e34b2883e1f0506bcdc8c">TSLOpenGLAntialiasModeEnum</a> mode)</td></tr>
<tr class="separator:a8dc9d44735c93c48302be5a84aad58aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53d93f56835ee6f98203a20d498654e" id="r_aa53d93f56835ee6f98203a20d498654e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa53d93f56835ee6f98203a20d498654e">targetFrameBuffer</a> (GLuint fbo)</td></tr>
<tr class="separator:aa53d93f56835ee6f98203a20d498654e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e6c241c81e776d972f9ea4077454bf" id="r_ac1e6c241c81e776d972f9ea4077454bf"><td class="memItemLeft" align="right" valign="top">GLuint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac1e6c241c81e776d972f9ea4077454bf">targetFrameBuffer</a> () const</td></tr>
<tr class="separator:ac1e6c241c81e776d972f9ea4077454bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8bb0e88cd7a12cf095e62f3ba4d2114" id="r_af8bb0e88cd7a12cf095e62f3ba4d2114"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8bb0e88cd7a12cf095e62f3ba4d2114">setDepthSlice</a> (uint32_t numDrawItems)</td></tr>
<tr class="separator:af8bb0e88cd7a12cf095e62f3ba4d2114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f18667f9a1526390a29f94221b21d86" id="r_a9f18667f9a1526390a29f94221b21d86"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f18667f9a1526390a29f94221b21d86">setDisplayMetrics</a> (double dpiX, double dpiY, int horizontalSizePixels, int verticalSizePixels)</td></tr>
<tr class="separator:a9f18667f9a1526390a29f94221b21d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5932411f19711eb3d6af4a5b8787195" id="r_ac5932411f19711eb3d6af4a5b8787195"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac5932411f19711eb3d6af4a5b8787195">setSwitchRangeForFP64</a> (double range)</td></tr>
<tr class="separator:ac5932411f19711eb3d6af4a5b8787195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dfe93b13f983b586dcc7b9a56a35a29" id="r_a0dfe93b13f983b586dcc7b9a56a35a29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0dfe93b13f983b586dcc7b9a56a35a29">setLayerStorageStrategy</a> (const char *layerName, <a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga5a179736bbaa6140780153039419128f">TSLOpenGLStorageStrategyEnum</a> strategy)</td></tr>
<tr class="separator:a0dfe93b13f983b586dcc7b9a56a35a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d411a70bce77cf1a5abf85ea2df29a" id="r_a45d411a70bce77cf1a5abf85ea2df29a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45d411a70bce77cf1a5abf85ea2df29a">setLayerTransparencyHint</a> (const char *layerName, <a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga38981acc5b361a3b59eede68ba2021a4">TSLOpenGLTransparencyHintEnum</a> hint)</td></tr>
<tr class="separator:a45d411a70bce77cf1a5abf85ea2df29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09e7576eb4226bf32dfa2b6cef4145b" id="r_ab09e7576eb4226bf32dfa2b6cef4145b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab09e7576eb4226bf32dfa2b6cef4145b">setRGBABackgroundColour</a> (unsigned char r, unsigned char g, unsigned char b, unsigned char a)</td></tr>
<tr class="separator:ab09e7576eb4226bf32dfa2b6cef4145b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a005d2645e416e78abf3321ef206849c9" id="r_a005d2645e416e78abf3321ef206849c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_open_g_l_state_tracker.html">TSLOpenGLStateTracker</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a005d2645e416e78abf3321ef206849c9">stateTracker</a> ()</td></tr>
<tr class="separator:a005d2645e416e78abf3321ef206849c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b883dd87243d69e7df3545ab54e94cb" id="r_a0b883dd87243d69e7df3545ab54e94cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b883dd87243d69e7df3545ab54e94cb">shaderPreloadEnabled</a> (bool enabled)</td></tr>
<tr class="separator:a0b883dd87243d69e7df3545ab54e94cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77230d0d6604c7bb9eb09bb6f23d26aa" id="r_a77230d0d6604c7bb9eb09bb6f23d26aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77230d0d6604c7bb9eb09bb6f23d26aa">shaderPreloadEnabled</a> () const</td></tr>
<tr class="separator:a77230d0d6604c7bb9eb09bb6f23d26aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eeb8f2b1166991cc967d3361a1085f9" id="r_a9eeb8f2b1166991cc967d3361a1085f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9eeb8f2b1166991cc967d3361a1085f9">preloadProjectionShaders</a> (const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *cs, bool loadfp64Variant)</td></tr>
<tr class="separator:a9eeb8f2b1166991cc967d3361a1085f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8100d0ca50de786d6fff11a5cf58294" id="r_ae8100d0ca50de786d6fff11a5cf58294"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8100d0ca50de786d6fff11a5cf58294">flushLoadedShaders</a> ()</td></tr>
<tr class="separator:ae8100d0ca50de786d6fff11a5cf58294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028b33106544171d6c3685c9c3b710be" id="r_a028b33106544171d6c3685c9c3b710be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a028b33106544171d6c3685c9c3b710be">rasterProjectionControlPointParameters</a> (unsigned int minPointsPerRaster, unsigned int maxPointsPerRaster, unsigned int gridSizePixels)</td></tr>
<tr class="separator:a028b33106544171d6c3685c9c3b710be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab301106ee62dc5482f4f65619a6c5dfa" id="r_ab301106ee62dc5482f4f65619a6c5dfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab301106ee62dc5482f4f65619a6c5dfa">textRoundingEnabled</a> (bool enabled)</td></tr>
<tr class="separator:ab301106ee62dc5482f4f65619a6c5dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70fbc36211784d2d59258305a35d09d" id="r_ab70fbc36211784d2d59258305a35d09d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab70fbc36211784d2d59258305a35d09d">textRoundingEnabled</a> () const</td></tr>
<tr class="separator:ab70fbc36211784d2d59258305a35d09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce6501aafd7bb4eb374f912c3267813" id="r_a2ce6501aafd7bb4eb374f912c3267813"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ce6501aafd7bb4eb374f912c3267813">textRoundingAmount</a> (unsigned int px)</td></tr>
<tr class="separator:a2ce6501aafd7bb4eb374f912c3267813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae116e68568ad88530021f4fe7d1c3a73" id="r_ae116e68568ad88530021f4fe7d1c3a73"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae116e68568ad88530021f4fe7d1c3a73">textRoundingAmount</a> () const</td></tr>
<tr class="separator:ae116e68568ad88530021f4fe7d1c3a73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_t_s_l_drawing_surface"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_t_s_l_drawing_surface')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a></td></tr>
<tr class="memitem:a0265147d1b95af2e58dba9044794e7ad inherit pub_methods_class_t_s_l_drawing_surface" id="r_a0265147d1b95af2e58dba9044794e7ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a0265147d1b95af2e58dba9044794e7ad">clearAllRendering</a> ()</td></tr>
<tr class="separator:a0265147d1b95af2e58dba9044794e7ad inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaf31e090d3f2a5d7fd9f009b19c53fe inherit pub_methods_class_t_s_l_drawing_surface" id="r_aeaf31e090d3f2a5d7fd9f009b19c53fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#aeaf31e090d3f2a5d7fd9f009b19c53fe">clearDynamicColours</a> ()</td></tr>
<tr class="separator:aeaf31e090d3f2a5d7fd9f009b19c53fe inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a471fe3d0a6601709cb7add89ce78c8a8 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a471fe3d0a6601709cb7add89ce78c8a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_raster_buffer.html">TSLRasterBuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a471fe3d0a6601709cb7add89ce78c8a8">createRasterBuffer</a> (unsigned int width, unsigned int height, <a class="el" href="class_t_s_l_raster_buffer.html#a1fafd2ab8f125b29ddceb5a2aaa91f7e">TSLRasterBuffer::Format</a> format, <a class="el" href="class_t_s_l_raster_buffer.html#a02b2cc2b1da9b354c4a40466d650cf24">TSLRasterBuffer::FilterMode</a> filterMode=<a class="el" href="class_t_s_l_raster_buffer.html#a02b2cc2b1da9b354c4a40466d650cf24a91eaf68f9a0200a02757022d9d863dae">TSLRasterBuffer::Linear</a>)</td></tr>
<tr class="separator:a471fe3d0a6601709cb7add89ce78c8a8 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a206fed500549fb011a7e64d391273899 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a206fed500549fb011a7e64d391273899"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a206fed500549fb011a7e64d391273899">declutterIsVisible</a> (const char *feature_name, double resolution=0.0, const char *layer_name=0) const</td></tr>
<tr class="separator:a206fed500549fb011a7e64d391273899 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dbaf1905aaff87cfb59d77caa722e34 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a9dbaf1905aaff87cfb59d77caa722e34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a9dbaf1905aaff87cfb59d77caa722e34">drawDU</a> (TSLDeviceUnits x1, TSLDeviceUnits y1, TSLDeviceUnits x2, TSLDeviceUnits y2, bool clear, bool updateExtentOnly=false)</td></tr>
<tr class="separator:a9dbaf1905aaff87cfb59d77caa722e34 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c53e5790d1eb3b0b01672050d655d7 inherit pub_methods_class_t_s_l_drawing_surface" id="r_af6c53e5790d1eb3b0b01672050d655d7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#af6c53e5790d1eb3b0b01672050d655d7">drawUU</a> (double x1, double y1, double x2, double y2, bool clear, bool updateExtentOnly=false)</td></tr>
<tr class="separator:af6c53e5790d1eb3b0b01672050d655d7 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55958d05038aa959c54f21a03a95a017 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a55958d05038aa959c54f21a03a95a017"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a55958d05038aa959c54f21a03a95a017">DUToLatLong</a> (TSLDeviceUnits x, TSLDeviceUnits y, double *latitude, double *longitude, bool local=false, bool boundCheck=true) const</td></tr>
<tr class="separator:a55958d05038aa959c54f21a03a95a017 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5ccbb0dbce745dc1b1352285013e11 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a9c5ccbb0dbce745dc1b1352285013e11"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a9c5ccbb0dbce745dc1b1352285013e11">DUToMU</a> (TSLDeviceUnits x1, TSLDeviceUnits y1, double *x2, double *y2) const</td></tr>
<tr class="separator:a9c5ccbb0dbce745dc1b1352285013e11 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92256bdb7597267758967a8889c10189 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a92256bdb7597267758967a8889c10189"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a92256bdb7597267758967a8889c10189">DUToTMC</a> (TSLDeviceUnits x1, TSLDeviceUnits y1, TSLTMC *x2, TSLTMC *y2) const</td></tr>
<tr class="separator:a92256bdb7597267758967a8889c10189 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb8bfb6a862d236426427dcc7bb7de7 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a9bb8bfb6a862d236426427dcc7bb7de7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a9bb8bfb6a862d236426427dcc7bb7de7">DUToUU</a> (TSLDeviceUnits x1, TSLDeviceUnits y1, double *x2, double *y2) const</td></tr>
<tr class="separator:a9bb8bfb6a862d236426427dcc7bb7de7 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26fee92015216e73a978cbed135a5771 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a26fee92015216e73a978cbed135a5771"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a26fee92015216e73a978cbed135a5771">findEntityDU</a> (TSLDeviceUnits x, TSLDeviceUnits y, TSLDeviceUnits aperture, int depth, const char *feature_name=NULL)</td></tr>
<tr class="separator:a26fee92015216e73a978cbed135a5771 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c864c485c3eaffa69cccc51fef7711d inherit pub_methods_class_t_s_l_drawing_surface" id="r_a1c864c485c3eaffa69cccc51fef7711d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a1c864c485c3eaffa69cccc51fef7711d">findEntityUU</a> (double x, double y, double aperture, int depth, const char *feature_name=NULL)</td></tr>
<tr class="separator:a1c864c485c3eaffa69cccc51fef7711d inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa12f7671255ef058944cb4e2b0d32063 inherit pub_methods_class_t_s_l_drawing_surface" id="r_aa12f7671255ef058944cb4e2b0d32063"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#aa12f7671255ef058944cb4e2b0d32063">findSelectedEntityDU</a> (TSLDeviceUnits x, TSLDeviceUnits y, TSLDeviceUnits aperture, int depth=-1, bool ignoreMapDataLayers=false)</td></tr>
<tr class="separator:aa12f7671255ef058944cb4e2b0d32063 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a834b6cd5cd46e2e37d28f248cfa32e3f inherit pub_methods_class_t_s_l_drawing_surface" id="r_a834b6cd5cd46e2e37d28f248cfa32e3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a834b6cd5cd46e2e37d28f248cfa32e3f">findSelectedEntityUU</a> (double x, double y, double aperture, int depth=-1, bool ignoreMapDataLayers=false)</td></tr>
<tr class="separator:a834b6cd5cd46e2e37d28f248cfa32e3f inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088da526a941a7e8b89ce030f7809b2a inherit pub_methods_class_t_s_l_drawing_surface" id="r_a088da526a941a7e8b89ce030f7809b2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a088da526a941a7e8b89ce030f7809b2a">getColourIndices</a> (int **indices, int *num)</td></tr>
<tr class="separator:a088da526a941a7e8b89ce030f7809b2a inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62280c4a00af92d96b697809a45a2ad3 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a62280c4a00af92d96b697809a45a2ad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a62280c4a00af92d96b697809a45a2ad3">getCoordinateProvidingLayer</a> ()</td></tr>
<tr class="separator:a62280c4a00af92d96b697809a45a2ad3 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a5c65d839aa420ceee2c397f629293 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a77a5c65d839aa420ceee2c397f629293"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a77a5c65d839aa420ceee2c397f629293">getCoordinateProvidingLayer</a> () const</td></tr>
<tr class="separator:a77a5c65d839aa420ceee2c397f629293 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24685986e62832473065717f5d85121b inherit pub_methods_class_t_s_l_drawing_surface" id="r_a24685986e62832473065717f5d85121b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a24685986e62832473065717f5d85121b">getDeclutterRange</a> (const char *featureName, double *innerLimit, double *outerLimit, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:a24685986e62832473065717f5d85121b inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b7ca890687234f55c562a6b1cfe9605 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a0b7ca890687234f55c562a6b1cfe9605"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a0b7ca890687234f55c562a6b1cfe9605">getDeviceCapabilities</a> (int &amp;horizontalSizeMM, int &amp;verticalSizeMM, int &amp;horizontalSizePixels, int &amp;verticalSizePixels) const</td></tr>
<tr class="separator:a0b7ca890687234f55c562a6b1cfe9605 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16108f4d82547522e368cc6ab1194a7 inherit pub_methods_class_t_s_l_drawing_surface" id="r_ac16108f4d82547522e368cc6ab1194a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#ac16108f4d82547522e368cc6ab1194a7">getDeviceCapabilities</a> (<a class="el" href="class_t_s_l_device_capabilities.html">TSLDeviceCapabilities</a> &amp;capabilities) const</td></tr>
<tr class="separator:ac16108f4d82547522e368cc6ab1194a7 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f1db5a44878ac35f0aedb681000ccf3 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a8f1db5a44878ac35f0aedb681000ccf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a8f1db5a44878ac35f0aedb681000ccf3">getDUExtent</a> (TSLDeviceUnits *x1, TSLDeviceUnits *y1, TSLDeviceUnits *x2, TSLDeviceUnits *y2) const</td></tr>
<tr class="separator:a8f1db5a44878ac35f0aedb681000ccf3 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bde97604179aa10b89500cfd543dd06 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a9bde97604179aa10b89500cfd543dd06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a9bde97604179aa10b89500cfd543dd06">getFillStyleIndices</a> (int **indices, int *num)</td></tr>
<tr class="separator:a9bde97604179aa10b89500cfd543dd06 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56af95ebf21a45ca380a0ce42da51249 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a56af95ebf21a45ca380a0ce42da51249"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a56af95ebf21a45ca380a0ce42da51249">getFontStyleIndices</a> (int **indices, int *num)</td></tr>
<tr class="separator:a56af95ebf21a45ca380a0ce42da51249 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051cf30191f83100d566ea4b35700456 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a051cf30191f83100d566ea4b35700456"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a051cf30191f83100d566ea4b35700456">getLineStyleIndices</a> (int **indices, int *num)</td></tr>
<tr class="separator:a051cf30191f83100d566ea4b35700456 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65f256aabb5b59e80b88e08038effc5c inherit pub_methods_class_t_s_l_drawing_surface" id="r_a65f256aabb5b59e80b88e08038effc5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a65f256aabb5b59e80b88e08038effc5c">getMUExtent</a> (double *x1, double *y1, double *x2, double *y2) const</td></tr>
<tr class="separator:a65f256aabb5b59e80b88e08038effc5c inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39c36e88a1ea95c97448f9d9bd41bcf4 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a39c36e88a1ea95c97448f9d9bd41bcf4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a39c36e88a1ea95c97448f9d9bd41bcf4">getSymbolStyleIndices</a> (int **indices, int *num)</td></tr>
<tr class="separator:a39c36e88a1ea95c97448f9d9bd41bcf4 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a5044855e7098d3dfd31aeb50def3a inherit pub_methods_class_t_s_l_drawing_surface" id="r_af7a5044855e7098d3dfd31aeb50def3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_drawing_surface_tiled_buffer_control.html">TSLDrawingSurfaceTiledBufferControl</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#af7a5044855e7098d3dfd31aeb50def3a">getTiledBufferController</a> ()</td></tr>
<tr class="separator:af7a5044855e7098d3dfd31aeb50def3a inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4858d5b71cf4b0e867b363cfec4be4d inherit pub_methods_class_t_s_l_drawing_surface" id="r_ab4858d5b71cf4b0e867b363cfec4be4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#ab4858d5b71cf4b0e867b363cfec4be4d">getTMCExtent</a> (<a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent) const</td></tr>
<tr class="separator:ab4858d5b71cf4b0e867b363cfec4be4d inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a127c44f812974a35def9bf6670dcb inherit pub_methods_class_t_s_l_drawing_surface" id="r_a05a127c44f812974a35def9bf6670dcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a05a127c44f812974a35def9bf6670dcb">getUUExtent</a> (double *x1, double *y1, double *x2, double *y2) const</td></tr>
<tr class="separator:a05a127c44f812974a35def9bf6670dcb inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb2c6838847338edd95ea19dff318bc inherit pub_methods_class_t_s_l_drawing_surface" id="r_abeb2c6838847338edd95ea19dff318bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#abeb2c6838847338edd95ea19dff318bc">getViewedLatLongRange</a> (double *latitude, double *longitude, double *range, bool local=false, bool boundCheck=true) const</td></tr>
<tr class="separator:abeb2c6838847338edd95ea19dff318bc inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad4b5bf36e222d864ee5db18a81054d inherit pub_methods_class_t_s_l_drawing_surface" id="r_abad4b5bf36e222d864ee5db18a81054d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#abad4b5bf36e222d864ee5db18a81054d">latLongToDU</a> (double latitude, double longitude, TSLDeviceUnits *x, TSLDeviceUnits *y, bool local=false) const</td></tr>
<tr class="separator:abad4b5bf36e222d864ee5db18a81054d inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396b86032a83c3a8b8eec53ca10dc10b inherit pub_methods_class_t_s_l_drawing_surface" id="r_a396b86032a83c3a8b8eec53ca10dc10b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a396b86032a83c3a8b8eec53ca10dc10b">latLongToMU</a> (double latitude, double longitude, double *x, double *y, bool local=false) const</td></tr>
<tr class="separator:a396b86032a83c3a8b8eec53ca10dc10b inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cba4efaf42d5cc263331f6031ab1a19 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a8cba4efaf42d5cc263331f6031ab1a19"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a8cba4efaf42d5cc263331f6031ab1a19">latLongToTMC</a> (double latitude, double longitude, TSLTMC *x, TSLTMC *y, bool local=false) const</td></tr>
<tr class="separator:a8cba4efaf42d5cc263331f6031ab1a19 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24a585738cf746b7ba0fd07121f09d57 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a24a585738cf746b7ba0fd07121f09d57"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a24a585738cf746b7ba0fd07121f09d57">latLongToUU</a> (double latitude, double longitude, double *x, double *y, bool local=false) const</td></tr>
<tr class="separator:a24a585738cf746b7ba0fd07121f09d57 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a229a7af4f762a8b08fa85ec98c4a6216 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a229a7af4f762a8b08fa85ec98c4a6216"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a229a7af4f762a8b08fa85ec98c4a6216">MUToDU</a> (double x1, double y1, TSLDeviceUnits *x2, TSLDeviceUnits *y2) const</td></tr>
<tr class="separator:a229a7af4f762a8b08fa85ec98c4a6216 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e6d157fa0bc20f57c0ac472c2f89d1 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a34e6d157fa0bc20f57c0ac472c2f89d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a34e6d157fa0bc20f57c0ac472c2f89d1">MUToLatLong</a> (double x, double y, double *latitude, double *longitude, bool local=false, bool boundCheck=true) const</td></tr>
<tr class="separator:a34e6d157fa0bc20f57c0ac472c2f89d1 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056dc5745b1ddb69eee0107691a6d156 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a056dc5745b1ddb69eee0107691a6d156"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a056dc5745b1ddb69eee0107691a6d156">MUToTMC</a> (double x1, double y1, TSLTMC *x2, TSLTMC *y2) const</td></tr>
<tr class="separator:a056dc5745b1ddb69eee0107691a6d156 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a519dcb08d580a637d8e99a55ed71b8cf inherit pub_methods_class_t_s_l_drawing_surface" id="r_a519dcb08d580a637d8e99a55ed71b8cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a519dcb08d580a637d8e99a55ed71b8cf">MUToUU</a> (double x1, double y1, double *x2, double *y2) const</td></tr>
<tr class="separator:a519dcb08d580a637d8e99a55ed71b8cf inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72dfae3357186a52e4cf5f33c7ff121 inherit pub_methods_class_t_s_l_drawing_surface" id="r_af72dfae3357186a52e4cf5f33c7ff121"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#af72dfae3357186a52e4cf5f33c7ff121">pan</a> (double x1, double y1, bool auto_redraw=true)</td></tr>
<tr class="separator:af72dfae3357186a52e4cf5f33c7ff121 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90e7ebe67614f96a87a04e8dfac6b2aa inherit pub_methods_class_t_s_l_drawing_surface" id="r_a90e7ebe67614f96a87a04e8dfac6b2aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a90e7ebe67614f96a87a04e8dfac6b2aa">pan</a> (double x1, double y1, TSLDeviceUnits xDU, TSLDeviceUnits yDU, bool auto_redraw=true)</td></tr>
<tr class="separator:a90e7ebe67614f96a87a04e8dfac6b2aa inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9491068819845644862267d6338fc263 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a9491068819845644862267d6338fc263"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a9491068819845644862267d6338fc263">query</a> (const char *layerName, TSLTMC x1, TSLTMC y1, TSLTMC x2, TSLTMC y2, int depth=-1, const char *feature_name=NULL) const</td></tr>
<tr class="separator:a9491068819845644862267d6338fc263 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e56090a87893c5fb5f07cfe30835d8f inherit pub_methods_class_t_s_l_drawing_surface" id="r_a5e56090a87893c5fb5f07cfe30835d8f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a5e56090a87893c5fb5f07cfe30835d8f">query</a> (const char *layerName, TSLTMC x1, TSLTMC y1, TSLTMC x2, TSLTMC y2, <a class="el" href="class_t_s_l_selector.html">TSLSelector</a> *selector) const</td></tr>
<tr class="separator:a5e56090a87893c5fb5f07cfe30835d8f inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae85ac70f3315d04cf26c6a90025b4944 inherit pub_methods_class_t_s_l_drawing_surface" id="r_ae85ac70f3315d04cf26c6a90025b4944"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#ae85ac70f3315d04cf26c6a90025b4944">redraw</a> ()</td></tr>
<tr class="separator:ae85ac70f3315d04cf26c6a90025b4944 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed93ce6d7d56190ca1c06cf9701822dc inherit pub_methods_class_t_s_l_drawing_surface" id="r_aed93ce6d7d56190ca1c06cf9701822dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#aed93ce6d7d56190ca1c06cf9701822dc">reset</a> (bool auto_redraw=true)</td></tr>
<tr class="separator:aed93ce6d7d56190ca1c06cf9701822dc inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7690d28806f4f49eefa448236c693ed inherit pub_methods_class_t_s_l_drawing_surface" id="r_ab7690d28806f4f49eefa448236c693ed"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#ab7690d28806f4f49eefa448236c693ed">resize</a> (double x1, double y1, double x2, double y2, bool auto_redraw=true, bool keep_aspect=false)</td></tr>
<tr class="separator:ab7690d28806f4f49eefa448236c693ed inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800690766b84cce3a78c08bf1f81bf85 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a800690766b84cce3a78c08bf1f81bf85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a800690766b84cce3a78c08bf1f81bf85">rotate</a> (double angle)</td></tr>
<tr class="separator:a800690766b84cce3a78c08bf1f81bf85 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed652727aa64811d82939686f197953 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a2ed652727aa64811d82939686f197953"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a2ed652727aa64811d82939686f197953">rotation</a> () const</td></tr>
<tr class="separator:a2ed652727aa64811d82939686f197953 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa48130aab4aea41eaacd059d307573e0 inherit pub_methods_class_t_s_l_drawing_surface" id="r_aa48130aab4aea41eaacd059d307573e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#aa48130aab4aea41eaacd059d307573e0">setDeclutterRange</a> (const char *featureName, double innerLimit, double outerLimit, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:aa48130aab4aea41eaacd059d307573e0 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c1fbad2ef1ae403936f7d92b06ce29 inherit pub_methods_class_t_s_l_drawing_surface" id="r_ac3c1fbad2ef1ae403936f7d92b06ce29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#ac3c1fbad2ef1ae403936f7d92b06ce29">setDeviceCapabilities</a> (const int horizontalSizeMM=0, const int verticalSizeMM=0, const int horizontalSizePixels=0, const int verticalSizePixels=0)</td></tr>
<tr class="separator:ac3c1fbad2ef1ae403936f7d92b06ce29 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a164f432573707f6d4ee485bccf136f74 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a164f432573707f6d4ee485bccf136f74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a164f432573707f6d4ee485bccf136f74">setDeviceCapabilities</a> (const <a class="el" href="class_t_s_l_device_capabilities.html">TSLDeviceCapabilities</a> &amp;capabilities)</td></tr>
<tr class="separator:a164f432573707f6d4ee485bccf136f74 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98ffd5550409dab6aa56886979538b3 inherit pub_methods_class_t_s_l_drawing_surface" id="r_ab98ffd5550409dab6aa56886979538b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#ab98ffd5550409dab6aa56886979538b3">setRedrawCallback</a> (<a class="el" href="class_t_s_l_drawing_surface_draw_callback.html">TSLDrawingSurfaceDrawCallback</a> *callback)</td></tr>
<tr class="separator:ab98ffd5550409dab6aa56886979538b3 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f51404204385733cd71891f4dd7b6fc inherit pub_methods_class_t_s_l_drawing_surface" id="r_a7f51404204385733cd71891f4dd7b6fc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a7f51404204385733cd71891f4dd7b6fc">setupDynamicColours</a> (const char *filename)</td></tr>
<tr class="separator:a7f51404204385733cd71891f4dd7b6fc inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12ea6c2b80dc64f1c48041f8669455c inherit pub_methods_class_t_s_l_drawing_surface" id="r_ae12ea6c2b80dc64f1c48041f8669455c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#ae12ea6c2b80dc64f1c48041f8669455c">setViewedLatLongRange</a> (double latitude, double longitude, double range, bool local=false, bool auto_redraw=true, bool keep_aspect=false)</td></tr>
<tr class="separator:ae12ea6c2b80dc64f1c48041f8669455c inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e19f07cd5d254d552f72555af9a8c3b inherit pub_methods_class_t_s_l_drawing_surface" id="r_a8e19f07cd5d254d552f72555af9a8c3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a8e19f07cd5d254d552f72555af9a8c3b">TMCperDU</a> (double &amp;xr, double &amp;yr)</td></tr>
<tr class="separator:a8e19f07cd5d254d552f72555af9a8c3b inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ce349a3c79510c6e24e2dabdc7ecfc8 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a8ce349a3c79510c6e24e2dabdc7ecfc8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a8ce349a3c79510c6e24e2dabdc7ecfc8">TMCperUU</a> ()</td></tr>
<tr class="separator:a8ce349a3c79510c6e24e2dabdc7ecfc8 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b8e6605f56df449e17d44e200e36d4c inherit pub_methods_class_t_s_l_drawing_surface" id="r_a0b8e6605f56df449e17d44e200e36d4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a0b8e6605f56df449e17d44e200e36d4c">TMCToDU</a> (TSLTMC x1, TSLTMC y1, TSLDeviceUnits *x2, TSLDeviceUnits *y2) const</td></tr>
<tr class="separator:a0b8e6605f56df449e17d44e200e36d4c inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4f2031604fd46d50acbc2df498decf inherit pub_methods_class_t_s_l_drawing_surface" id="r_a4f4f2031604fd46d50acbc2df498decf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a4f4f2031604fd46d50acbc2df498decf">TMCToLatLong</a> (TSLTMC x, TSLTMC y, double *latitude, double *longitude, bool local=false, bool boundCheck=true) const</td></tr>
<tr class="separator:a4f4f2031604fd46d50acbc2df498decf inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd800e36b15f4eed4777d08d1d522410 inherit pub_methods_class_t_s_l_drawing_surface" id="r_afd800e36b15f4eed4777d08d1d522410"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#afd800e36b15f4eed4777d08d1d522410">TMCToMU</a> (TSLTMC x1, TSLTMC y1, double *x2, double *y2) const</td></tr>
<tr class="separator:afd800e36b15f4eed4777d08d1d522410 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7992c07cb5d68bc4721823711a11e8e inherit pub_methods_class_t_s_l_drawing_surface" id="r_ae7992c07cb5d68bc4721823711a11e8e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#ae7992c07cb5d68bc4721823711a11e8e">TMCToUU</a> (TSLTMC x1, TSLTMC y1, double *x2, double *y2) const</td></tr>
<tr class="separator:ae7992c07cb5d68bc4721823711a11e8e inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e24f4cf626a0e8c4b092f12f9a94dff inherit pub_methods_class_t_s_l_drawing_surface" id="r_a7e24f4cf626a0e8c4b092f12f9a94dff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a7e24f4cf626a0e8c4b092f12f9a94dff">updateEntityExtent</a> (<a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *entity, const char *layerName)</td></tr>
<tr class="separator:a7e24f4cf626a0e8c4b092f12f9a94dff inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941815a45e93b11238a630e068ea10cf inherit pub_methods_class_t_s_l_drawing_surface" id="r_a941815a45e93b11238a630e068ea10cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a941815a45e93b11238a630e068ea10cf">userUnitOrigin</a> (double x_origin, double y_origin)</td></tr>
<tr class="separator:a941815a45e93b11238a630e068ea10cf inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e943708c846dbecc4585ac7ef926e39 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a7e943708c846dbecc4585ac7ef926e39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a7e943708c846dbecc4585ac7ef926e39">userUnitOrigin</a> (<a class="el" href="group__apigroup__api.html#gaea852777270e6ad45b6398b684f03fb5">TSLUUEnum</a> origin_enum)</td></tr>
<tr class="separator:a7e943708c846dbecc4585ac7ef926e39 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee5c4a9338fc9a7f7c19020a2f3cf2ee inherit pub_methods_class_t_s_l_drawing_surface" id="r_aee5c4a9338fc9a7f7c19020a2f3cf2ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#aee5c4a9338fc9a7f7c19020a2f3cf2ee">userUnits</a> (double factor)</td></tr>
<tr class="separator:aee5c4a9338fc9a7f7c19020a2f3cf2ee inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7eb89e0d8eb0bb0311a36bb60a4b9fb inherit pub_methods_class_t_s_l_drawing_surface" id="r_ad7eb89e0d8eb0bb0311a36bb60a4b9fb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#ad7eb89e0d8eb0bb0311a36bb60a4b9fb">userUnits</a> ()</td></tr>
<tr class="separator:ad7eb89e0d8eb0bb0311a36bb60a4b9fb inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c636fd6c2727611dde71d21546dfb6 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a17c636fd6c2727611dde71d21546dfb6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a17c636fd6c2727611dde71d21546dfb6">UUToDU</a> (double x1, double y1, TSLDeviceUnits *x2, TSLDeviceUnits *y2) const</td></tr>
<tr class="separator:a17c636fd6c2727611dde71d21546dfb6 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1874cf113c30ee0fd2523a673968aecc inherit pub_methods_class_t_s_l_drawing_surface" id="r_a1874cf113c30ee0fd2523a673968aecc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a1874cf113c30ee0fd2523a673968aecc">UUToLatLong</a> (double x, double y, double *latitude, double *longitude, bool local=false, bool boundCheck=true) const</td></tr>
<tr class="separator:a1874cf113c30ee0fd2523a673968aecc inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3708fb917b3f5d376322fb4aeee38ee inherit pub_methods_class_t_s_l_drawing_surface" id="r_ad3708fb917b3f5d376322fb4aeee38ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#ad3708fb917b3f5d376322fb4aeee38ee">UUToMU</a> (double x1, double y1, double *x2, double *y2) const</td></tr>
<tr class="separator:ad3708fb917b3f5d376322fb4aeee38ee inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381ad674e87bbb437ad98b75ebb52a9e inherit pub_methods_class_t_s_l_drawing_surface" id="r_a381ad674e87bbb437ad98b75ebb52a9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a381ad674e87bbb437ad98b75ebb52a9e">UUToTMC</a> (double x1, double y1, TSLTMC *x2, TSLTMC *y2) const</td></tr>
<tr class="separator:a381ad674e87bbb437ad98b75ebb52a9e inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82700ea425c05e6350ecb8a3f66db1d inherit pub_methods_class_t_s_l_drawing_surface" id="r_ab82700ea425c05e6350ecb8a3f66db1d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#ab82700ea425c05e6350ecb8a3f66db1d">wndResize</a> (TSLDeviceUnits x1, TSLDeviceUnits y1, TSLDeviceUnits x2, TSLDeviceUnits y2, bool auto_redraw=true, <a class="el" href="group__apigroup__api.html#gac1205ab450d747428b9d32017d80d9ad">TSLResizeActionEnum</a> action=<a class="el" href="group__apigroup__api.html#ggac1205ab450d747428b9d32017d80d9adac27a24e79765e5ca34941717c2173eed">TSLResizeActionNone</a>)</td></tr>
<tr class="separator:ab82700ea425c05e6350ecb8a3f66db1d inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac788a5c33da53c07951fc0ce7de2d17 inherit pub_methods_class_t_s_l_drawing_surface" id="r_aac788a5c33da53c07951fc0ce7de2d17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#aac788a5c33da53c07951fc0ce7de2d17">zoom</a> (double percent, bool zoom_in, bool auto_redraw=true)</td></tr>
<tr class="separator:aac788a5c33da53c07951fc0ce7de2d17 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30e410f6da8fb2f7c1b1c3ac570c0b7 inherit pub_methods_class_t_s_l_drawing_surface" id="r_af30e410f6da8fb2f7c1b1c3ac570c0b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#af30e410f6da8fb2f7c1b1c3ac570c0b7">TSLDrawingSurface</a> ()</td></tr>
<tr class="separator:af30e410f6da8fb2f7c1b1c3ac570c0b7 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a5f72960f6f6184d429ae5cbbc99f0 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a19a5f72960f6f6184d429ae5cbbc99f0"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a19a5f72960f6f6184d429ae5cbbc99f0">~TSLDrawingSurface</a> ()</td></tr>
<tr class="separator:a19a5f72960f6f6184d429ae5cbbc99f0 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01a09056395ae216959f9cdab30d7744 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a01a09056395ae216959f9cdab30d7744"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a01a09056395ae216959f9cdab30d7744">clearSymbolList</a> ()</td></tr>
<tr class="separator:a01a09056395ae216959f9cdab30d7744 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824eeb7f498f27ee606cf6858d0c8b3b inherit pub_methods_class_t_s_l_drawing_surface" id="r_a824eeb7f498f27ee606cf6858d0c8b3b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a824eeb7f498f27ee606cf6858d0c8b3b">clearFontList</a> ()</td></tr>
<tr class="separator:a824eeb7f498f27ee606cf6858d0c8b3b inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a396aa24cca72491d62ec7b6f379da219 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a396aa24cca72491d62ec7b6f379da219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a396aa24cca72491d62ec7b6f379da219">clearLineList</a> ()</td></tr>
<tr class="separator:a396aa24cca72491d62ec7b6f379da219 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fdbce18a41087bc8240fcf807050ce inherit pub_methods_class_t_s_l_drawing_surface" id="r_a15fdbce18a41087bc8240fcf807050ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a15fdbce18a41087bc8240fcf807050ce">clearFillList</a> ()</td></tr>
<tr class="separator:a15fdbce18a41087bc8240fcf807050ce inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6c56019d6190af127879ce48b6250a inherit pub_methods_class_t_s_l_drawing_surface" id="r_acb6c56019d6190af127879ce48b6250a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#acb6c56019d6190af127879ce48b6250a">removeFillStyle</a> (TSLStyleID style)</td></tr>
<tr class="separator:acb6c56019d6190af127879ce48b6250a inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72941d15fa3abb4af65b41d2d3e0205d inherit pub_methods_class_t_s_l_drawing_surface" id="r_a72941d15fa3abb4af65b41d2d3e0205d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a72941d15fa3abb4af65b41d2d3e0205d">removeLineStyle</a> (TSLStyleID style)</td></tr>
<tr class="separator:a72941d15fa3abb4af65b41d2d3e0205d inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4829860c91707d31cf426c4d63de5835 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a4829860c91707d31cf426c4d63de5835"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a4829860c91707d31cf426c4d63de5835">removeSymbolStyle</a> (TSLStyleID style)</td></tr>
<tr class="separator:a4829860c91707d31cf426c4d63de5835 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f89f337edd9a76ca9d1fd2638b09106 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a3f89f337edd9a76ca9d1fd2638b09106"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a3f89f337edd9a76ca9d1fd2638b09106">removeFontStyle</a> (TSLStyleID style)</td></tr>
<tr class="separator:a3f89f337edd9a76ca9d1fd2638b09106 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a946c15e83276c2a5d308efb701062c18 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a946c15e83276c2a5d308efb701062c18"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a946c15e83276c2a5d308efb701062c18">createFontID</a> (const <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;name, TSLFontType meaningOfName, int fontWeight, bool italic=false, bool underline=false, bool antiAliased=false, const unsigned char *memoryBlock=NULL, TSLSize memoryBlockSize=0)</td></tr>
<tr class="separator:a946c15e83276c2a5d308efb701062c18 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e5fda0f85949120c75f961c35be4b3 inherit pub_methods_class_t_s_l_drawing_surface" id="r_af5e5fda0f85949120c75f961c35be4b3"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#af5e5fda0f85949120c75f961c35be4b3">createStandardLineID</a> (const unsigned char *pattern, TSLSize patternLength, int initialOffset, TSLLineScalingType scaleType)</td></tr>
<tr class="separator:af5e5fda0f85949120c75f961c35be4b3 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b86b6973e62cdd0a1ca4a244328c32 inherit pub_methods_class_t_s_l_drawing_surface" id="r_ad0b86b6973e62cdd0a1ca4a244328c32"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#ad0b86b6973e62cdd0a1ca4a244328c32">createSymbolLineID</a> (int symbolID, double size=0.0, <a class="el" href="group__apigroup__geometry__api.html#ga575681bd39e0be106648609e4958788c">TSLDimensionUnits</a> sizeUnits=<a class="el" href="group__apigroup__geometry__api.html#gga575681bd39e0be106648609e4958788cae841a878e751716330b78e01d1f7b0b1">TSLDimensionUnitsUndefined</a>, float <a class="el" href="class_t_s_l_drawing_surface.html#a2ed652727aa64811d82939686f197953">rotation</a>=0.0f, double anchorPointX=0.0, double anchorPointY=0.0, <a class="el" href="group__apigroup__geometry__api.html#ga575681bd39e0be106648609e4958788c">TSLDimensionUnits</a> anchorPointUnits=<a class="el" href="group__apigroup__geometry__api.html#gga575681bd39e0be106648609e4958788cae841a878e751716330b78e01d1f7b0b1">TSLDimensionUnitsUndefined</a>)</td></tr>
<tr class="separator:ad0b86b6973e62cdd0a1ca4a244328c32 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a2d9eed2a9376eeca1d7ee7c1d6d2f inherit pub_methods_class_t_s_l_drawing_surface" id="r_a69a2d9eed2a9376eeca1d7ee7c1d6d2f"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a69a2d9eed2a9376eeca1d7ee7c1d6d2f">createStandardFillID</a> (const unsigned char *pattern=NULL, TSLSize patternSizeInBytes=0, int patternXSize=0, int patternYSize=0)</td></tr>
<tr class="separator:a69a2d9eed2a9376eeca1d7ee7c1d6d2f inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c125151569f85aa2d1dd3eb4cb6d893 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a3c125151569f85aa2d1dd3eb4cb6d893"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a3c125151569f85aa2d1dd3eb4cb6d893">createSymbolFillID</a> (int symbolID, double size=0.0, <a class="el" href="group__apigroup__geometry__api.html#ga575681bd39e0be106648609e4958788c">TSLDimensionUnits</a> sizeUnits=<a class="el" href="group__apigroup__geometry__api.html#gga575681bd39e0be106648609e4958788cae841a878e751716330b78e01d1f7b0b1">TSLDimensionUnitsUndefined</a>, float <a class="el" href="class_t_s_l_drawing_surface.html#a2ed652727aa64811d82939686f197953">rotation</a>=0.0f, double anchorPointX=0.0, double anchorPointY=0.0, <a class="el" href="group__apigroup__geometry__api.html#ga575681bd39e0be106648609e4958788c">TSLDimensionUnits</a> anchorPointUnits=<a class="el" href="group__apigroup__geometry__api.html#gga575681bd39e0be106648609e4958788cae841a878e751716330b78e01d1f7b0b1">TSLDimensionUnitsUndefined</a>)</td></tr>
<tr class="separator:a3c125151569f85aa2d1dd3eb4cb6d893 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbce81dc062e8f57bbeed7f994499421 inherit pub_methods_class_t_s_l_drawing_surface" id="r_adbce81dc062e8f57bbeed7f994499421"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#adbce81dc062e8f57bbeed7f994499421">createSVGSymbolID</a> (const <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;name, const unsigned char *memoryBlock=NULL, TSLSize memoryBlockSize=0)</td></tr>
<tr class="separator:adbce81dc062e8f57bbeed7f994499421 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb63ecf6e6e4c00abaf2136b1ccb79c inherit pub_methods_class_t_s_l_drawing_surface" id="r_a5fb63ecf6e6e4c00abaf2136b1ccb79c"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a5fb63ecf6e6e4c00abaf2136b1ccb79c">createFontSymbolID</a> (const <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;name, TSLFontType meaningOfName, const unsigned char *memoryBlock=NULL, TSLSize memoryBlockSize=0)</td></tr>
<tr class="separator:a5fb63ecf6e6e4c00abaf2136b1ccb79c inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72399f3239a3b10e121069a0dbed6bb2 inherit pub_methods_class_t_s_l_drawing_surface" id="r_a72399f3239a3b10e121069a0dbed6bb2"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a72399f3239a3b10e121069a0dbed6bb2">createRasterSymbolID</a> (const <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;name, int xorigin, int yorigin, bool scaleable, const unsigned char *memoryBlock=NULL, TSLSize memoryBlockSize=0)</td></tr>
<tr class="separator:a72399f3239a3b10e121069a0dbed6bb2 inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab0a60b674c19e504b6e85e04f7937a inherit pub_methods_class_t_s_l_drawing_surface" id="r_a6ab0a60b674c19e504b6e85e04f7937a"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a6ab0a60b674c19e504b6e85e04f7937a">createSymbolIDFromSymbol</a> (TSLStyleID symbolID, int numberofColourPairs, const int *colourFrom, const int *colourTo)</td></tr>
<tr class="separator:a6ab0a60b674c19e504b6e85e04f7937a inherit pub_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_t_s_l_drawing_surface_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_t_s_l_drawing_surface_base')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a></td></tr>
<tr class="memitem:adf2508e14060aa37e3f64d3d4daedb83 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_adf2508e14060aa37e3f64d3d4daedb83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#adf2508e14060aa37e3f64d3d4daedb83">addDataLayer</a> (<a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> *data_layer_interface, const char *data_id)</td></tr>
<tr class="separator:adf2508e14060aa37e3f64d3d4daedb83 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756782b5ecf3f00c22d8a20c40096453 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a756782b5ecf3f00c22d8a20c40096453"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a756782b5ecf3f00c22d8a20c40096453">addDynamicRenderer</a> (<a class="el" href="class_t_s_l_dynamic_renderer.html">TSLDynamicRenderer</a> *renderer, TSLFeatureID featureID=-1, const char *layerName=0)</td></tr>
<tr class="separator:a756782b5ecf3f00c22d8a20c40096453 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28c609ffd861cc7e0f1de9a4e3ffff9 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ab28c609ffd861cc7e0f1de9a4e3ffff9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ab28c609ffd861cc7e0f1de9a4e3ffff9">addFeatureRendering</a> (const char *featureName, TSLFeatureID featureID)</td></tr>
<tr class="separator:ab28c609ffd861cc7e0f1de9a4e3ffff9 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad695674703054f6dde4f8f472160ca82 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ad695674703054f6dde4f8f472160ca82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ad695674703054f6dde4f8f472160ca82">attach</a> (TSLDeviceContext handle)</td></tr>
<tr class="separator:ad695674703054f6dde4f8f472160ca82 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac268beaaf3462b6d6a1845bebb3fb113 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ac268beaaf3462b6d6a1845bebb3fb113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ac268beaaf3462b6d6a1845bebb3fb113">attach</a> (TSLWindowHandle handle)</td></tr>
<tr class="separator:ac268beaaf3462b6d6a1845bebb3fb113 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab367bb38ef5a8e3ce9df1b17fe665fbd inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ab367bb38ef5a8e3ce9df1b17fe665fbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ab367bb38ef5a8e3ce9df1b17fe665fbd">attach</a> (TSLDrawableHandle handle)</td></tr>
<tr class="separator:ab367bb38ef5a8e3ce9df1b17fe665fbd inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa764a7e039e56f2489a1f62d238701 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a5fa764a7e039e56f2489a1f62d238701"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a5fa764a7e039e56f2489a1f62d238701">bringInFrontof</a> (const char *move_data_layer, const char *target_data_layer)</td></tr>
<tr class="separator:a5fa764a7e039e56f2489a1f62d238701 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccd258d58e99d15c4bcae1b4c1170f7 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_aeccd258d58e99d15c4bcae1b4c1170f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#aeccd258d58e99d15c4bcae1b4c1170f7">bringToFront</a> (const char *move_data_layer)</td></tr>
<tr class="separator:aeccd258d58e99d15c4bcae1b4c1170f7 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171387fcf2304549fffe4982562ca4c2 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a171387fcf2304549fffe4982562ca4c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a171387fcf2304549fffe4982562ca4c2">clearAllDeclutterData</a> (const char *layer_name=0)</td></tr>
<tr class="separator:a171387fcf2304549fffe4982562ca4c2 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bdcd971140c6640265b2acc4457eb5 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a55bdcd971140c6640265b2acc4457eb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a55bdcd971140c6640265b2acc4457eb5">clearAllDynamicRenderers</a> ()</td></tr>
<tr class="separator:a55bdcd971140c6640265b2acc4457eb5 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdabfe424ab268061573eafed87ffb04 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_afdabfe424ab268061573eafed87ffb04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#afdabfe424ab268061573eafed87ffb04">clearBackgroundColour</a> ()</td></tr>
<tr class="separator:afdabfe424ab268061573eafed87ffb04 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e94baf9c65b8079c543b7945365d07 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a59e94baf9c65b8079c543b7945365d07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a59e94baf9c65b8079c543b7945365d07">clearDeclutterData</a> (const char *feature_name, const char *layer_name=0)</td></tr>
<tr class="separator:a59e94baf9c65b8079c543b7945365d07 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7373de95bfb938c2226e8f294280a3a inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_af7373de95bfb938c2226e8f294280a3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#af7373de95bfb938c2226e8f294280a3a">clearDynamicRenderer</a> (TSLFeatureID featureID=-1, const char *layerName=0)</td></tr>
<tr class="separator:af7373de95bfb938c2226e8f294280a3a inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a6a56d2729aa0a1fafe37b6aa04f52 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a25a6a56d2729aa0a1fafe37b6aa04f52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a25a6a56d2729aa0a1fafe37b6aa04f52">clearFeatureRendering</a> (const char *featureName, TSLFeatureID featureID)</td></tr>
<tr class="separator:a25a6a56d2729aa0a1fafe37b6aa04f52 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b812d3c132366b9f20b92110c8dad6f inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a7b812d3c132366b9f20b92110c8dad6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a7b812d3c132366b9f20b92110c8dad6f">clearFrame</a> ()</td></tr>
<tr class="separator:a7b812d3c132366b9f20b92110c8dad6f inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e62109d1d6673dc37cbb79f0d13cef inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ab3e62109d1d6673dc37cbb79f0d13cef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ab3e62109d1d6673dc37cbb79f0d13cef">copyDeclutterData</a> (const char *src_feature_name, const char *dest_feature_name, const char *src_layer_name=0, const char *dest_layer_name=0)</td></tr>
<tr class="separator:ab3e62109d1d6673dc37cbb79f0d13cef inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b35a14f96de605f73191cbb04b86cf inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a27b35a14f96de605f73191cbb04b86cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a27b35a14f96de605f73191cbb04b86cf">detach</a> ()</td></tr>
<tr class="separator:a27b35a14f96de605f73191cbb04b86cf inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f3ab638243f6016c21bdffb6f28a44 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_aa6f3ab638243f6016c21bdffb6f28a44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#aa6f3ab638243f6016c21bdffb6f28a44">detachAllDynamicRenderers</a> ()</td></tr>
<tr class="separator:aa6f3ab638243f6016c21bdffb6f28a44 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc62268d7293cc9fac136200e6aed62 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a0fc62268d7293cc9fac136200e6aed62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a0fc62268d7293cc9fac136200e6aed62">detachDynamicRenderer</a> (TSLFeatureID featureID=-1, const char *layerName=0)</td></tr>
<tr class="separator:a0fc62268d7293cc9fac136200e6aed62 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da02a3dca66e350f188cc66d49b95d5 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a0da02a3dca66e350f188cc66d49b95d5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a0da02a3dca66e350f188cc66d49b95d5">featureClass</a> (TSLFeatureID feature_id)</td></tr>
<tr class="separator:a0da02a3dca66e350f188cc66d49b95d5 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f617343c50c8f907c05a895adc0f710 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a5f617343c50c8f907c05a895adc0f710"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a5f617343c50c8f907c05a895adc0f710">forceLayer</a> (const char *data_id, const char *detail_layer_name)</td></tr>
<tr class="separator:a5f617343c50c8f907c05a895adc0f710 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3f571b473fae1be0e3fda757f8a84a inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_aef3f571b473fae1be0e3fda757f8a84a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#aef3f571b473fae1be0e3fda757f8a84a">getBackgroundColour</a> (TSLStyleID *value)</td></tr>
<tr class="separator:aef3f571b473fae1be0e3fda757f8a84a inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff44ab7558d9044846c390b9c69b43c7 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_aff44ab7558d9044846c390b9c69b43c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#aff44ab7558d9044846c390b9c69b43c7">getColourValue</a> (int colour, unsigned char &amp;r, unsigned char &amp;g, unsigned char &amp;b)</td></tr>
<tr class="separator:aff44ab7558d9044846c390b9c69b43c7 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008b6ccaa73f5e7dedf2c09cc7feeb64 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a008b6ccaa73f5e7dedf2c09cc7feeb64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a008b6ccaa73f5e7dedf2c09cc7feeb64">getDataLayer</a> (const char *data_id)</td></tr>
<tr class="separator:a008b6ccaa73f5e7dedf2c09cc7feeb64 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ab91eba6e19889be3e4bb041cf023 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a630ab91eba6e19889be3e4bb041cf023"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a630ab91eba6e19889be3e4bb041cf023">getDataLayerInfo</a> (int N, <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> **dataLayer, const char **layerName) const</td></tr>
<tr class="separator:a630ab91eba6e19889be3e4bb041cf023 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319f8ac2a9cd7254e95120afe0c1ecfa inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a319f8ac2a9cd7254e95120afe0c1ecfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a319f8ac2a9cd7254e95120afe0c1ecfa">getDataLayerProps</a> (const char *data_id, <a class="el" href="group__apigroup__api.html#ga1c467581ddf31341ac6acf6baa297a9a">TSLPropertyEnum</a> property_id, TSLPropertyValue *old_value)</td></tr>
<tr class="separator:a319f8ac2a9cd7254e95120afe0c1ecfa inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d9532d2f61896824476e912db4efff inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ad2d9532d2f61896824476e912db4efff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ad2d9532d2f61896824476e912db4efff">getDeclutterStatus</a> (const char *feature_name, <a class="el" href="group__apigroup__api.html#gadd64c2d584f0cab2498c784c9451d85e">TSLDeclutterStatusResultEnum</a> *value, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:ad2d9532d2f61896824476e912db4efff inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61d832cd81e2c7a0ea2fa9744aec16a inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ae61d832cd81e2c7a0ea2fa9744aec16a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ae61d832cd81e2c7a0ea2fa9744aec16a">getDeclutterStatus</a> (TSLFeatureID feature_id, <a class="el" href="group__apigroup__api.html#gadd64c2d584f0cab2498c784c9451d85e">TSLDeclutterStatusResultEnum</a> *value, const char *dataLayerName, const char *detailLayerName=0)</td></tr>
<tr class="separator:ae61d832cd81e2c7a0ea2fa9744aec16a inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d31320e6500e887e85cc4a95e19c198 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a0d31320e6500e887e85cc4a95e19c198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_dynamic_renderer.html">TSLDynamicRenderer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a0d31320e6500e887e85cc4a95e19c198">getDynamicRenderer</a> (TSLFeatureID featureID=-1, const char *layerName=0)</td></tr>
<tr class="separator:a0d31320e6500e887e85cc4a95e19c198 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b26948542c04c89ed561e953ba0e3a inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a80b26948542c04c89ed561e953ba0e3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a80b26948542c04c89ed561e953ba0e3a">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a> attribute, int *result) const</td></tr>
<tr class="separator:a80b26948542c04c89ed561e953ba0e3a inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4df913acb00ac825e165e5c71fdf73 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a8c4df913acb00ac825e165e5c71fdf73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a8c4df913acb00ac825e165e5c71fdf73">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a> attribute, double *result) const</td></tr>
<tr class="separator:a8c4df913acb00ac825e165e5c71fdf73 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4248cc44247ca3696199db1b2913b5 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a0b4248cc44247ca3696199db1b2913b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a0b4248cc44247ca3696199db1b2913b5">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a> attribute, bool *result) const</td></tr>
<tr class="separator:a0b4248cc44247ca3696199db1b2913b5 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13420230fd95cafe4f7829a49ffa2b07 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a13420230fd95cafe4f7829a49ffa2b07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a13420230fd95cafe4f7829a49ffa2b07">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *result) const</td></tr>
<tr class="separator:a13420230fd95cafe4f7829a49ffa2b07 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef0f78c36be8c30078671de5f56e2a1 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_acef0f78c36be8c30078671de5f56e2a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#acef0f78c36be8c30078671de5f56e2a1">getNumDataLayers</a> () const</td></tr>
<tr class="separator:acef0f78c36be8c30078671de5f56e2a1 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a03a127eeee2f9c9a8fed466a7e5edd inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a0a03a127eeee2f9c9a8fed466a7e5edd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a0a03a127eeee2f9c9a8fed466a7e5edd">getOption</a> (<a class="el" href="group__apigroup__api.html#ga28a256688c01415721a7700d84fa55bd">TSLOptionEnum</a> option)</td></tr>
<tr class="separator:a0a03a127eeee2f9c9a8fed466a7e5edd inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a0fb6b5f0ac7270b4f321822897192 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a07a0fb6b5f0ac7270b4f321822897192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a07a0fb6b5f0ac7270b4f321822897192">id</a> (int id_)</td></tr>
<tr class="separator:a07a0fb6b5f0ac7270b4f321822897192 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41229ebf8a2a4e0e1639616d7a8efffd inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a41229ebf8a2a4e0e1639616d7a8efffd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a41229ebf8a2a4e0e1639616d7a8efffd">id</a> () const</td></tr>
<tr class="separator:a41229ebf8a2a4e0e1639616d7a8efffd inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fb9812a2e699c06d1aa787787f9ad6 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a18fb9812a2e699c06d1aa787787f9ad6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a18fb9812a2e699c06d1aa787787f9ad6">idleProcess</a> ()</td></tr>
<tr class="separator:a18fb9812a2e699c06d1aa787787f9ad6 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8e4094017e7699433efa30fdbbde9b inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a5f8e4094017e7699433efa30fdbbde9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a5f8e4094017e7699433efa30fdbbde9b">loadDeclutter</a> (const char *filename)</td></tr>
<tr class="separator:a5f8e4094017e7699433efa30fdbbde9b inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337cadfa02f94128a8f90a82083292fa inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a337cadfa02f94128a8f90a82083292fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a337cadfa02f94128a8f90a82083292fa">loadRendering</a> (const char *filename)</td></tr>
<tr class="separator:a337cadfa02f94128a8f90a82083292fa inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4585d14f142c6517ddbe21c72cca8f7 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ac4585d14f142c6517ddbe21c72cca8f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_pick_result_set.html">TSLPickResultSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ac4585d14f142c6517ddbe21c72cca8f7">pick</a> (TSLDeviceUnits x, TSLDeviceUnits y, TSLDeviceUnits aperture, int depth, <a class="el" href="class_t_s_l_pick_selector.html">TSLPickSelector</a> *selector=0)</td></tr>
<tr class="separator:ac4585d14f142c6517ddbe21c72cca8f7 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ab561be1f46b9cc34cdd5d9fc42664 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ad0ab561be1f46b9cc34cdd5d9fc42664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_pick_result_set.html">TSLPickResultSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ad0ab561be1f46b9cc34cdd5d9fc42664">pick</a> (const char *data_id, TSLDeviceUnits x, TSLDeviceUnits y, TSLDeviceUnits aperture, int depth=-1, <a class="el" href="class_t_s_l_pick_selector.html">TSLPickSelector</a> *selector=0)</td></tr>
<tr class="separator:ad0ab561be1f46b9cc34cdd5d9fc42664 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b56d4ff2cebea8e1606d4554d9c18c4 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a4b56d4ff2cebea8e1606d4554d9c18c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a4b56d4ff2cebea8e1606d4554d9c18c4">queryActiveLayer</a> (const char *data_id, char *detail_layer_name, int detail_layer_name_size)</td></tr>
<tr class="separator:a4b56d4ff2cebea8e1606d4554d9c18c4 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035ee62299073d81104620eb96ee8d58 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a035ee62299073d81104620eb96ee8d58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a035ee62299073d81104620eb96ee8d58">removeDataLayer</a> (const char *data_id)</td></tr>
<tr class="separator:a035ee62299073d81104620eb96ee8d58 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dda3044708be3978cb05fb57bf23b4 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a82dda3044708be3978cb05fb57bf23b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a82dda3044708be3978cb05fb57bf23b4">saveDeclutter</a> (const char *filename, <a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a> ver=<a class="el" href="group__apigroup__common.html#gga8141b1e165228e088c49024076e13758a0ecdea6c91f1d3104d6166d69b57c88d">TSL_CURRENT_MAPLINK_VERSION</a>)</td></tr>
<tr class="separator:a82dda3044708be3978cb05fb57bf23b4 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b70a8a01f666ecd5fa6ebe04feed246 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a4b70a8a01f666ecd5fa6ebe04feed246"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a4b70a8a01f666ecd5fa6ebe04feed246">saveRendering</a> (const char *filename, <a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a> ver=<a class="el" href="group__apigroup__common.html#gga8141b1e165228e088c49024076e13758a0ecdea6c91f1d3104d6166d69b57c88d">TSL_CURRENT_MAPLINK_VERSION</a>)</td></tr>
<tr class="separator:a4b70a8a01f666ecd5fa6ebe04feed246 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12641ebccfa6b934b66b47dacf0d6e4f inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a12641ebccfa6b934b66b47dacf0d6e4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a12641ebccfa6b934b66b47dacf0d6e4f">sendToBack</a> (const char *move_data_layer)</td></tr>
<tr class="separator:a12641ebccfa6b934b66b47dacf0d6e4f inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4862277014463d564f9b3a64bb1f32e9 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a4862277014463d564f9b3a64bb1f32e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a4862277014463d564f9b3a64bb1f32e9">sendToBackOf</a> (const char *move_data_layer, const char *target_data_layer)</td></tr>
<tr class="separator:a4862277014463d564f9b3a64bb1f32e9 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e4919227d150a0aa99fc135ea032ee inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a17e4919227d150a0aa99fc135ea032ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a17e4919227d150a0aa99fc135ea032ee">setBackgroundColour</a> (int value)</td></tr>
<tr class="separator:a17e4919227d150a0aa99fc135ea032ee inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6f63130d3fbb377eec5c56d2d68cea inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a0b6f63130d3fbb377eec5c56d2d68cea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a0b6f63130d3fbb377eec5c56d2d68cea">setCoordinateProvidingLayer</a> (const char *layer_name)</td></tr>
<tr class="separator:a0b6f63130d3fbb377eec5c56d2d68cea inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe537ed2746b65ecf6349f9efd967173 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_afe537ed2746b65ecf6349f9efd967173"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#afe537ed2746b65ecf6349f9efd967173">setDataLayerProps</a> (const char *data_id, <a class="el" href="group__apigroup__api.html#ga1c467581ddf31341ac6acf6baa297a9a">TSLPropertyEnum</a> property_id, TSLPropertyValue new_value)</td></tr>
<tr class="separator:afe537ed2746b65ecf6349f9efd967173 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1652a09b42b30587627b88c83ac0ecec inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a1652a09b42b30587627b88c83ac0ecec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a1652a09b42b30587627b88c83ac0ecec">setDeclutterStatus</a> (const char *feature_name, <a class="el" href="group__apigroup__api.html#gababcf35d0e42f024d8d93535c70bf928">TSLDeclutterStatusEnum</a> value, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:a1652a09b42b30587627b88c83ac0ecec inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b777dcbefd270725084ff917384de5 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a59b777dcbefd270725084ff917384de5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a59b777dcbefd270725084ff917384de5">setDeclutterStatus</a> (TSLFeatureID feature_id, <a class="el" href="group__apigroup__api.html#gababcf35d0e42f024d8d93535c70bf928">TSLDeclutterStatusEnum</a> value, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:a59b777dcbefd270725084ff917384de5 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1edf066975321c7cd825af58beb1d4 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a7e1edf066975321c7cd825af58beb1d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a7e1edf066975321c7cd825af58beb1d4">setDeclutterStatusOnAllFeatures</a> (<a class="el" href="group__apigroup__api.html#gababcf35d0e42f024d8d93535c70bf928">TSLDeclutterStatusEnum</a> value, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:a7e1edf066975321c7cd825af58beb1d4 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad28bc4cacd259f533cd6b6d31baff5f inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_aad28bc4cacd259f533cd6b6d31baff5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#aad28bc4cacd259f533cd6b6d31baff5f">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a> attribute, int value)</td></tr>
<tr class="separator:aad28bc4cacd259f533cd6b6d31baff5f inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843e54b936b459e6dfecf49543665bfa inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a843e54b936b459e6dfecf49543665bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a843e54b936b459e6dfecf49543665bfa">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a> attribute, double value)</td></tr>
<tr class="separator:a843e54b936b459e6dfecf49543665bfa inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d01bf5edd3a7f32f012a5b9a852cad1 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a6d01bf5edd3a7f32f012a5b9a852cad1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a6d01bf5edd3a7f32f012a5b9a852cad1">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a> attribute, bool value)</td></tr>
<tr class="separator:a6d01bf5edd3a7f32f012a5b9a852cad1 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e00cc9c70d5fbef37124d4e309ab00c inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a6e00cc9c70d5fbef37124d4e309ab00c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a6e00cc9c70d5fbef37124d4e309ab00c">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *value)</td></tr>
<tr class="separator:a6e00cc9c70d5fbef37124d4e309ab00c inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14d30f7088fab43c1f816d823d1955b inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_ae14d30f7088fab43c1f816d823d1955b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ae14d30f7088fab43c1f816d823d1955b">setFrame</a> (int style, int colour, int thickness)</td></tr>
<tr class="separator:ae14d30f7088fab43c1f816d823d1955b inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f53b83793beb451d1dd7be0f3303d8 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a11f53b83793beb451d1dd7be0f3303d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a11f53b83793beb451d1dd7be0f3303d8">setOption</a> (<a class="el" href="group__apigroup__api.html#ga28a256688c01415721a7700d84fa55bd">TSLOptionEnum</a> option, bool value)</td></tr>
<tr class="separator:a11f53b83793beb451d1dd7be0f3303d8 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3c2bc3e7e95b72564a91c16f046cfd inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_adb3c2bc3e7e95b72564a91c16f046cfd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#adb3c2bc3e7e95b72564a91c16f046cfd">TMCperMU</a> ()</td></tr>
<tr class="separator:adb3c2bc3e7e95b72564a91c16f046cfd inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dadd653096a1f0cb6fb49a2a08ebf6b inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a5dadd653096a1f0cb6fb49a2a08ebf6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apigroup__api.html#ga76e1969f4b1b3d601f72cf5936520601">TSLDrawingSurfaceTypeEnum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a5dadd653096a1f0cb6fb49a2a08ebf6b">type</a> () const</td></tr>
<tr class="separator:a5dadd653096a1f0cb6fb49a2a08ebf6b inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de924d9df6935f26a9e3bee9d59253a inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a1de924d9df6935f26a9e3bee9d59253a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a1de924d9df6935f26a9e3bee9d59253a">userWord</a> (void *ptr) const</td></tr>
<tr class="separator:a1de924d9df6935f26a9e3bee9d59253a inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba63d2164415f471b835402054095de inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a2ba63d2164415f471b835402054095de"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a2ba63d2164415f471b835402054095de">userWord</a> () const</td></tr>
<tr class="separator:a2ba63d2164415f471b835402054095de inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca53495ddd20981f1ff20b3f4972b17 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a8ca53495ddd20981f1ff20b3f4972b17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a8ca53495ddd20981f1ff20b3f4972b17">cloneDynamicRenderersFrom</a> (const <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> *otherSurface)</td></tr>
<tr class="separator:a8ca53495ddd20981f1ff20b3f4972b17 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a5591424a0629788811bca54086242 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a58a5591424a0629788811bca54086242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a58a5591424a0629788811bca54086242">addDuplicateLayers</a> (bool value)</td></tr>
<tr class="separator:a58a5591424a0629788811bca54086242 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6867615c69a56a04cf0d742233ffd4b2 inherit pub_methods_class_t_s_l_drawing_surface_base" id="r_a6867615c69a56a04cf0d742233ffd4b2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a6867615c69a56a04cf0d742233ffd4b2">~TSLDrawingSurfaceBase</a> ()</td></tr>
<tr class="separator:a6867615c69a56a04cf0d742233ffd4b2 inherit pub_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6692d3f6f792809a63bb3a55ebb59a46" id="r_a6692d3f6f792809a63bb3a55ebb59a46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6692d3f6f792809a63bb3a55ebb59a46">TSLOpenGLSurface</a> ()</td></tr>
<tr class="separator:a6692d3f6f792809a63bb3a55ebb59a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_class_t_s_l_drawing_surface_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_methods_class_t_s_l_drawing_surface_base')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a></td></tr>
<tr class="memitem:affbc1d90c399f996a0cf64dcbbcde711 inherit pro_methods_class_t_s_l_drawing_surface_base" id="r_affbc1d90c399f996a0cf64dcbbcde711"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#affbc1d90c399f996a0cf64dcbbcde711">TSLDrawingSurfaceBase</a> ()</td></tr>
<tr class="separator:affbc1d90c399f996a0cf64dcbbcde711 inherit pro_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_class_t_s_l_drawing_surface"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_class_t_s_l_drawing_surface')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a></td></tr>
<tr class="memitem:a1856e3df51781fb80a1e85613fb99b90 inherit pub_static_methods_class_t_s_l_drawing_surface" id="r_a1856e3df51781fb80a1e85613fb99b90"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a1856e3df51781fb80a1e85613fb99b90">cleanup</a> ()</td></tr>
<tr class="separator:a1856e3df51781fb80a1e85613fb99b90 inherit pub_static_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8772169e0c0c790b31b27dc334c749ea inherit pub_static_methods_class_t_s_l_drawing_surface" id="r_a8772169e0c0c790b31b27dc334c749ea"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a8772169e0c0c790b31b27dc334c749ea">copy</a> (<a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *copyTo, <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *copyFrom, bool copyUserData=false)</td></tr>
<tr class="separator:a8772169e0c0c790b31b27dc334c749ea inherit pub_static_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a964579c2078caf7fd785ae5ca59590 inherit pub_static_methods_class_t_s_l_drawing_surface" id="r_a1a964579c2078caf7fd785ae5ca59590"><td class="memItemLeft" align="right" valign="top">static TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a1a964579c2078caf7fd785ae5ca59590">getIDOfNearestColour</a> (int r, int g, int b)</td></tr>
<tr class="separator:a1a964579c2078caf7fd785ae5ca59590 inherit pub_static_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa311653bc595b8f619483d097bc91fe2 inherit pub_static_methods_class_t_s_l_drawing_surface" id="r_aa311653bc595b8f619483d097bc91fe2"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#aa311653bc595b8f619483d097bc91fe2">loadStandardConfig</a> (const char *path=0, bool delayLoadIncludes=false)</td></tr>
<tr class="separator:aa311653bc595b8f619483d097bc91fe2 inherit pub_static_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b9dd3cf9821d65515a1d23d3f9cecc inherit pub_static_methods_class_t_s_l_drawing_surface" id="r_a36b9dd3cf9821d65515a1d23d3f9cecc"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a36b9dd3cf9821d65515a1d23d3f9cecc">setupColours</a> (const char *filename)</td></tr>
<tr class="separator:a36b9dd3cf9821d65515a1d23d3f9cecc inherit pub_static_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa170198d571f4d15d556412e149a4080 inherit pub_static_methods_class_t_s_l_drawing_surface" id="r_aa170198d571f4d15d556412e149a4080"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#aa170198d571f4d15d556412e149a4080">setupFillStyles</a> (const char *filename, bool delayLoadIncludes=false)</td></tr>
<tr class="separator:aa170198d571f4d15d556412e149a4080 inherit pub_static_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046b8114dfb56a9d09f85dcb7716479d inherit pub_static_methods_class_t_s_l_drawing_surface" id="r_a046b8114dfb56a9d09f85dcb7716479d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a046b8114dfb56a9d09f85dcb7716479d">setupFonts</a> (const char *filename, bool delayLoadIncludes=false)</td></tr>
<tr class="separator:a046b8114dfb56a9d09f85dcb7716479d inherit pub_static_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeda81868b934c3a05a71cfa3c5bc611 inherit pub_static_methods_class_t_s_l_drawing_surface" id="r_afeda81868b934c3a05a71cfa3c5bc611"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#afeda81868b934c3a05a71cfa3c5bc611">setupLineStyles</a> (const char *filename, bool delayLoadIncludes=false)</td></tr>
<tr class="separator:afeda81868b934c3a05a71cfa3c5bc611 inherit pub_static_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98418e65bfd9026740db3c77abf260d0 inherit pub_static_methods_class_t_s_l_drawing_surface" id="r_a98418e65bfd9026740db3c77abf260d0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a98418e65bfd9026740db3c77abf260d0">setupSymbols</a> (const char *filename, bool delayLoadIncludes=false)</td></tr>
<tr class="separator:a98418e65bfd9026740db3c77abf260d0 inherit pub_static_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa91d7d50cada7a5626bd58e597a15f18 inherit pub_static_methods_class_t_s_l_drawing_surface" id="r_aa91d7d50cada7a5626bd58e597a15f18"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#aa91d7d50cada7a5626bd58e597a15f18">disableAntiAliasFonts</a> ()</td></tr>
<tr class="separator:aa91d7d50cada7a5626bd58e597a15f18 inherit pub_static_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ec24d8d55cd08c24e1409997950a89 inherit pub_static_methods_class_t_s_l_drawing_surface" id="r_a42ec24d8d55cd08c24e1409997950a89"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface.html#a42ec24d8d55cd08c24e1409997950a89">enableAntiAliasFonts</a> ()</td></tr>
<tr class="separator:a42ec24d8d55cd08c24e1409997950a89 inherit pub_static_methods_class_t_s_l_drawing_surface"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_class_t_s_l_drawing_surface_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_static_methods_class_t_s_l_drawing_surface_base')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a></td></tr>
<tr class="memitem:aed9a67d3faea852e71e981ba5550b10e inherit pub_static_methods_class_t_s_l_drawing_surface_base" id="r_aed9a67d3faea852e71e981ba5550b10e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#aed9a67d3faea852e71e981ba5550b10e">addLoader</a> (<a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *loader)</td></tr>
<tr class="separator:aed9a67d3faea852e71e981ba5550b10e inherit pub_static_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d868cc316b91af4b7ad52e07b0ebde0 inherit pub_static_methods_class_t_s_l_drawing_surface_base" id="r_a8d868cc316b91af4b7ad52e07b0ebde0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a8d868cc316b91af4b7ad52e07b0ebde0">addPathList</a> (<a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> *path_list)</td></tr>
<tr class="separator:a8d868cc316b91af4b7ad52e07b0ebde0 inherit pub_static_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d9c0144fcd50dd472f4a4aa01852e4 inherit pub_static_methods_class_t_s_l_drawing_surface_base" id="r_ab2d9c0144fcd50dd472f4a4aa01852e4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ab2d9c0144fcd50dd472f4a4aa01852e4">findFile</a> (const char *filename, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;foundPath)</td></tr>
<tr class="separator:ab2d9c0144fcd50dd472f4a4aa01852e4 inherit pub_static_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7feaa515d8d97a663bfe2e11d71d893 inherit pub_static_methods_class_t_s_l_drawing_surface_base" id="r_ad7feaa515d8d97a663bfe2e11d71d893"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#ad7feaa515d8d97a663bfe2e11d71d893">getLoader</a> ()</td></tr>
<tr class="separator:ad7feaa515d8d97a663bfe2e11d71d893 inherit pub_static_methods_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_class_t_s_l_drawing_surface_base"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pro_attribs_class_t_s_l_drawing_surface_base')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a></td></tr>
<tr class="memitem:a06d217cc978c3dd7d7838602a74b8041 inherit pro_attribs_class_t_s_l_drawing_surface_base" id="r_a06d217cc978c3dd7d7838602a74b8041"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_drawing_surface_base.html#a06d217cc978c3dd7d7838602a74b8041">m_classID</a></td></tr>
<tr class="separator:a06d217cc978c3dd7d7838602a74b8041 inherit pro_attribs_class_t_s_l_drawing_surface_base"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a41b4c4e88762628170d56976a25ba4d6" name="a41b4c4e88762628170d56976a25ba4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b4c4e88762628170d56976a25ba4d6">&#9670;&#160;</a></span>~TSLOpenGLSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TSLOpenGLSurface::~TSLOpenGLSurface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6692d3f6f792809a63bb3a55ebb59a46" name="a6692d3f6f792809a63bb3a55ebb59a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6692d3f6f792809a63bb3a55ebb59a46">&#9670;&#160;</a></span>TSLOpenGLSurface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TSLOpenGLSurface::TSLOpenGLSurface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3506c0601af61c3163dee0f67936a67f" name="a3506c0601af61c3163dee0f67936a67f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3506c0601af61c3163dee0f67936a67f">&#9670;&#160;</a></span>acquireDepthSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float TSLOpenGLSurface::acquireDepthSlice </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When mixing custom OpenGL rendering with MapLink rendering inside a custom data layer, drawing may not give the expected results due to MapLink's use of the depth buffer to ensure ordering when issuing rendering commands out of back-to-front sequence.</p>
<p>This method asks the drawing surface to reserve the next available depth buffer value for the application to use for the current layer being drawn, and returns the value in clip space/normalised device coordinate space. This value can be used to ensure drawing appears in the correct order relative to MapLink rendering without the application having to issue all drawing commands from back to front.</p>
<p>See the OpenGL Drawing Surface - Interspersing Custom Rendering with MapLink Rendering section of the MapLink developer's guide for more information and code examples.</p>
<p>Returns the next available depth value in clip space/normalised device coordinate space. Each call reserves a new depth value for application use that is in front of any previous depth values. </p>

</div>
</div>
<a id="a66f323a8671c859ea87dd71b66e44be6" name="a66f323a8671c859ea87dd71b66e44be6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f323a8671c859ea87dd71b66e44be6">&#9670;&#160;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> * TSLOpenGLSurface::clone </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>copyUserData</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The OpenGL drawing surface cannot be cloned. This method always returns NULL. </p>

<p>Implements <a class="el" href="class_t_s_l_drawing_surface.html#a2e495c3693a20a9c7bacd180d9e9e452">TSLDrawingSurface</a>.</p>

</div>
</div>
<a id="aabe02b0e04ad6577d4697cb6343dbddd" name="aabe02b0e04ad6577d4697cb6343dbddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabe02b0e04ad6577d4697cb6343dbddd">&#9670;&#160;</a></span>coordinateCentreX()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TSLOpenGLSurface::coordinateCentreX </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the X coordinate in TMC space that the drawing surface mapped to the centre of the screen during the last or current draw. This can be used in custom data layers to assist in positioning items correctly on the display when performing rendering that does not use the MapLink TSLRendering Interface.</p>
<p>Subtracting this value from an item's TMC location gives the necessary translation in order to correctly position it on the drawing surface. </p>

</div>
</div>
<a id="a4d02d7fd0e882153b3753146fde2ec79" name="a4d02d7fd0e882153b3753146fde2ec79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d02d7fd0e882153b3753146fde2ec79">&#9670;&#160;</a></span>coordinateCentreY()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TSLOpenGLSurface::coordinateCentreY </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the Y coordinate in TMC space that the drawing surface mapped to the centre of the screen during the last or current draw. This can be used in custom data layers to assist in positioning items correctly on the display when performing rendering that does not use the MapLink TSLRendering Interface.</p>
<p>Subtracting this value from an item's TMC location gives the necessary translation in order to correctly position it on the drawing surface. </p>

</div>
</div>
<a id="a8934d8e210f322de9ce93c5eeb5f9469" name="a8934d8e210f322de9ce93c5eeb5f9469"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8934d8e210f322de9ce93c5eeb5f9469">&#9670;&#160;</a></span>createChildSurface()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_open_g_l_surface.html">TSLOpenGLSurface</a> * TSLOpenGLSurface::createChildSurface </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new drawing surface that shares the OpenGL context of this drawing surface.</p>
<p>A child drawing surface can be useful when performing offscreen rendering using MapLink, such as when drawing to an OpenGL framebuffer object. As a child surface is a separate drawing surface to its parent, it may use entirely different settings such as window size and contain different data layers to its parent without affecting the parent.</p>
<p>A child drawing surface may be created or deleted within a draw call of its parent, e.g. inside the implementation of TSLClientCustomDatalayer::drawLayer.</p>
<p>A child surface does not automatically include any of the data layers that were present in the parent surface at the time of its creation.</p>
<p>As the OpenGL context used by a child drawing surface is the same as the context used by its parent, a child drawing surface is bound to the same thread as its parent. Detaching or deleting the parent drawing surface automatically detaches any child surfaces that exist.</p>
<p>A child surface uses the same <a class="el" href="class_t_s_l_open_g_l_state_tracker.html">TSLOpenGLStateTracker</a> as its parent, therefore changes made through the child's state tracker will automatically be reflected in its parent's state tracker and vice versa. </p>

</div>
</div>
<a id="a52609d927120349229968498a49bcfa7" name="a52609d927120349229968498a49bcfa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52609d927120349229968498a49bcfa7">&#9670;&#160;</a></span>currentDepthSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float TSLOpenGLSurface::currentDepthSlice </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current depth value in clip space/normalised device coordinate space.</p>
<p>This method does not allocate a new depth slice. </p>

</div>
</div>
<a id="a2517935e510fb391144ad272f8ad2fb2" name="a2517935e510fb391144ad272f8ad2fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2517935e510fb391144ad272f8ad2fb2">&#9670;&#160;</a></span>depthSliceIncrement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float TSLOpenGLSurface::depthSliceIncrement </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the amount that each draw of an object increments the depth value by.</p>
<p>The depth value has to be incremented by a sufficent amount to ensure that each object is drawn at a unique depth. </p>

</div>
</div>
<a id="ac4e6b0788faf8743ff23a265923b15a0" name="ac4e6b0788faf8743ff23a265923b15a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e6b0788faf8743ff23a265923b15a0">&#9670;&#160;</a></span>enableRealtimeReprojection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLOpenGLSurface::enableRealtimeReprojection </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enable</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8100d0ca50de786d6fff11a5cf58294" name="ae8100d0ca50de786d6fff11a5cf58294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8100d0ca50de786d6fff11a5cf58294">&#9670;&#160;</a></span>flushLoadedShaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLOpenGLSurface::flushLoadedShaders </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all loaded shader programs and flush all references to them</p>
<p>This method may be used by applications in combination with preloadProjectionShaders in order to manually flush the shader programs.</p>
<p>Applications may want to flush shader programs in order to slightly reduce GPU memory usage, however shader programs will typically be small compared to the data being displayed e.g large raster tiles.</p>
<p>Once shaders have been flushed they will automatically be reloaded when necessary, or may be preloaded again by the application.</p>
<p>The application must first call shaderPreloadEnabled(true) in order to use this method. </p>

</div>
</div>
<a id="abf6f16f01de584b6c2021169792fa264" name="abf6f16f01de584b6c2021169792fa264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6f16f01de584b6c2021169792fa264">&#9670;&#160;</a></span>flushPendingDraws()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLOpenGLSurface::flushPendingDraws </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instructs the drawing surface to issue OpenGL commands for any outstanding draws. This method is only useful when performing custom application rendering from inside a MapLink data layer, e.g. through a <a class="el" href="class_t_s_l_custom_data_layer.html">TSLCustomDataLayer</a> or <a class="el" href="class_t_s_l_dynamic_renderer.html">TSLDynamicRenderer</a> when the layer's storage hint is not set to TSLOpenGLTransparencyHintAlways.</p>
<p>Applications should try to avoid calling this method frequently as it reduces the ability of the drawing surface to internally optimise rendering. If there are no pending drawing operations this method does nothing. </p>

</div>
</div>
<a id="a1656726e7b9a9d1ce0001a4b2fca1f0d" name="a1656726e7b9a9d1ce0001a4b2fca1f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1656726e7b9a9d1ce0001a4b2fca1f0d">&#9670;&#160;</a></span>getLayerStorageStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLOpenGLSurface::getLayerStorageStrategy </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga5a179736bbaa6140780153039419128f">TSLOpenGLStorageStrategyEnum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the current storage strategy for the given data layer. See the documentation for <a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga5a179736bbaa6140780153039419128f">TSLOpenGLStorageStrategyEnum</a> for a description of the possible values.</p>
<p>By default all layers use the TSLOpenGLPerTileStrategy storage strategy.</p>
<p>Returns false if the given layer is not present in the drawing surface, otherwise returns true. </p>

</div>
</div>
<a id="a87483718d40f8424d852464ff4f4521c" name="a87483718d40f8424d852464ff4f4521c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87483718d40f8424d852464ff4f4521c">&#9670;&#160;</a></span>getLayerTransparencyHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLOpenGLSurface::getLayerTransparencyHint </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga38981acc5b361a3b59eede68ba2021a4">TSLOpenGLTransparencyHintEnum</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>hint</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the current transparency hint for the given data layer. See the documentation for <a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga38981acc5b361a3b59eede68ba2021a4">TSLOpenGLTransparencyHintEnum</a> for a description of the possible values.</p>
<p>By default all layers use the TSLOpenGLTransparencyHintNever hint.</p>
<p>Returns false if the given layer is not present in the drawing surface, otherwise returns true. </p>

</div>
</div>
<a id="adf3bab5c2e8e44c07e278faa6f9c16da" name="adf3bab5c2e8e44c07e278faa6f9c16da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf3bab5c2e8e44c07e278faa6f9c16da">&#9670;&#160;</a></span>getSwitchRangeForFP64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TSLOpenGLSurface::getSwitchRangeForFP64 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the range at which the drawing surface switches to FP64 calculations on the GPU to.</p>
<p>This is related to realtime reprojection.</p>
<dl class="section return"><dt>Returns</dt><dd>range in Nautical Miles (default is 10NM) </dd></dl>

</div>
</div>
<a id="a5118651f8e45e88b96e8d20c2fc5560e" name="a5118651f8e45e88b96e8d20c2fc5560e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5118651f8e45e88b96e8d20c2fc5560e">&#9670;&#160;</a></span>incrementDepthSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float TSLOpenGLSurface::incrementDepthSlice </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>numDrawItems</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Increment the depth slice by the numDrawItems.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numDrawItems</td><td>specifies the number of items that the current depth slice needs to be incremented by.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new depth slice value in clip space/normalised device coordinate space. </dd></dl>

</div>
</div>
<a id="af4b6dd338e013a8f23cf55b90e8bd577" name="af4b6dd338e013a8f23cf55b90e8bd577"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b6dd338e013a8f23cf55b90e8bd577">&#9670;&#160;</a></span>modelViewMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float * TSLOpenGLSurface::modelViewMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the 4x4 modelview matrix used by the drawing surface for the current or last draw. This can be used in custom data layers to assist in positioning items correctly on the display when performing rendering that does not use the MapLink <a class="el" href="class_t_s_l_rendering_interface.html">TSLRenderingInterface</a>.</p>
<p>If the drawing surface is not currently attached to an OpenGL context this method will return NULL. </p>

</div>
</div>
<a id="a9eeb8f2b1166991cc967d3361a1085f9" name="a9eeb8f2b1166991cc967d3361a1085f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9eeb8f2b1166991cc967d3361a1085f9">&#9670;&#160;</a></span>preloadProjectionShaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLOpenGLSurface::preloadProjectionShaders </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *</td>          <td class="paramname"><span class="paramname"><em>cs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>loadfp64Variant</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Preload shader programs for realtime reprojection.</p>
<p>When rendering MapLink will automatically load and compile shader programs as required, and in most cases this will not cause any visual impact.</p>
<p>In some scenarios however (specifically when the GL_ARB_shader_subroutine extension is not supported) the time needed to compile shaders with realtime reprojection enabled can cause a significant visual stall. This stall will happen when a type of geometry is first displayed, or when zooming in far enough to require 64-bit precision in the shaders (&lt;10NM view range).</p>
<p>This method allows the application to preload the required shader programs, and move the stall to program initialisation. The application will need to wait for shader compilation to be performed however if preloaded the shaders will not need to be compiled during future draw calls, and will not cause visual stalls when zooming/panning the map.</p>
<p>The application should call this method multiple times for each required display projection (cs), and required floating point precision in the shaders.</p>
<p>Notes:</p><ul>
<li>Most applications should not need to call this method.</li>
<li>This method will only preload shaders for realtime reprojection. Shaders used for unprojected drawing will be loaded when required.</li>
<li>This method's functionality or signature may change in a future MapLink release. If you are using this method please contact Envitia support to discuss your use case.</li>
<li>The application may manually flush shader programs by calling flushLoadedShaders.</li>
<li>The application must first call shaderPreloadEnabled(true) in order to use this method.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cs</td><td>The coordinate system (projection) to preload shader programs for. </td></tr>
    <tr><td class="paramname">loadfp64Variant</td><td>If true the 64-bit version of the shaders will be loaded, otherwise 32-bit versions will be loaded. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if shaders were preloaded, false otherwise. </dd></dl>

</div>
</div>
<a id="a4a6281b7c2a5b0cc7230ef4800e90450" name="a4a6281b7c2a5b0cc7230ef4800e90450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6281b7c2a5b0cc7230ef4800e90450">&#9670;&#160;</a></span>projectionMatrix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const float * TSLOpenGLSurface::projectionMatrix </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the 4x4 projection matrix used by the drawing surface for the current or last draw. This can be used in custom data layers to assist in positioning items correctly on the display when performing rendering that does not use the MapLink <a class="el" href="class_t_s_l_rendering_interface.html">TSLRenderingInterface</a>.</p>
<p>If the drawing surface is not currently attached to an OpenGL context this method will return NULL. </p>

</div>
</div>
<a id="a028b33106544171d6c3685c9c3b710be" name="a028b33106544171d6c3685c9c3b710be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028b33106544171d6c3685c9c3b710be">&#9670;&#160;</a></span>rasterProjectionControlPointParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLOpenGLSurface::rasterProjectionControlPointParameters </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>minPointsPerRaster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>maxPointsPerRaster</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>gridSizePixels</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the parameters for raster projection control points</p>
<p>When rasters are projected a grid of control points is used. This grid is defined by the following parameters:</p><ul>
<li>Minimum points per raster: The minimum number of points for any raster tile. Default 8, minimum 4.</li>
<li>Maximum points per raster: The maximum number of points for any raster tile. Default 25.</li>
<li>Grid Size: The distance between control points in pixels. Default 20. By specifying this value in pixels the accuracy of projection will be maintained while the view is zoomed in further, and reduced in order to maintain performance when zooming out.</li>
</ul>
<p>The default values for these values have been chosen as appropriate for the largest number of scenarios, and as such the application may further tune these to a specific use case. These values may be changed at any time, and any changes will be reflected during subsequent redraws.</p>
<p>This tuning process should be as follows:</p><ul>
<li>Minimum points per raster should be set such that the data looks good enough when zoomed out a long way, without affecting performance.</li>
<li>Maximum points per raster should be set such that performance is not greatly affected when zooming in a long way.</li>
<li>Grid size should be set as small as possible while maintaining sufficient performance.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minPointsPerRaster</td><td>The minimum number of control points for each raster tile. </td></tr>
    <tr><td class="paramname">maxPointsPerRaster</td><td>The maximum number of control points for each raster tile. </td></tr>
    <tr><td class="paramname">gridSizePixels</td><td>The distance between control points in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dc9d44735c93c48302be5a84aad58aa" name="a8dc9d44735c93c48302be5a84aad58aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc9d44735c93c48302be5a84aad58aa">&#9670;&#160;</a></span>setAntialiasingMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLOpenGLSurface::setAntialiasingMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga673d8ea7fa2e34b2883e1f0506bcdc8c">TSLOpenGLAntialiasModeEnum</a></td>          <td class="paramname"><span class="paramname"><em>mode</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Controls the type of antialiasing used by the drawing surface, if any. See the documentation for <a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga673d8ea7fa2e34b2883e1f0506bcdc8c">TSLOpenGLAntialiasModeEnum</a> and the MapLink Developer's Guide for information on the available antialiasing types.</p>
<p>If the OpenGL context used by the drawing surface was created with multisampling then the only valid value that can be passed to this function is TSLOpenGLAntialiasModeDefault.</p>
<p>The postprocessing antialiasing modes can be enabled and disabled freely at runtime, however if sample buffers are present in the framebuffer configuration (GL_SAMPLE_BUFFERS is greater than 0) then the drawing surface will need to reload its shaders when enabling or disabling the antialiasing mode which will lead to a small delay on the next draw.</p>
<p>Returns true if the requested mode was set, or false if the requested mode is not valid given the framebuffer configuration used by the OpenGL context of the drawing surface. </p>

</div>
</div>
<a id="af8bb0e88cd7a12cf095e62f3ba4d2114" name="af8bb0e88cd7a12cf095e62f3ba4d2114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8bb0e88cd7a12cf095e62f3ba4d2114">&#9670;&#160;</a></span>setDepthSlice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float TSLOpenGLSurface::setDepthSlice </td>
          <td>(</td>
          <td class="paramtype">uint32_t</td>          <td class="paramname"><span class="paramname"><em>numDrawItems</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows the user to set the number of items that have been drawn.</p>
<p>This method should be used with care as it affects where in the depth buffer MapLink Pro draws geometry.</p>
<p>If the application calls glClear() for the depth buffer from within a <a class="el" href="class_t_s_l_client_custom_data_layer.html">TSLClientCustomDataLayer</a> then this method should be called to reset the depth slice calculations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numDrawItems</td><td>is the number of items that are assumed to have been drawn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the corresponding depth slice value in clip space/normalised device coordinate space. </dd></dl>

</div>
</div>
<a id="a9f18667f9a1526390a29f94221b21d86" name="a9f18667f9a1526390a29f94221b21d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f18667f9a1526390a29f94221b21d86">&#9670;&#160;</a></span>setDisplayMetrics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLOpenGLSurface::setDisplayMetrics </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dpiX</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>dpiY</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>horizontalSizePixels</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>verticalSizePixels</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provides an alternate method of specifying the physical properties of the display device. Aside from the different arguments this method is functionally identical to <a class="el" href="class_t_s_l_drawing_surface.html#ac3c1fbad2ef1ae403936f7d92b06ce29">TSLDrawingSurface::setDeviceCapabilities</a>.</p>
<p>Returns true if the display metrics were set, or false if the drawing surface is not currently attached. </p>

</div>
</div>
<a id="a0dfe93b13f983b586dcc7b9a56a35a29" name="a0dfe93b13f983b586dcc7b9a56a35a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dfe93b13f983b586dcc7b9a56a35a29">&#9670;&#160;</a></span>setLayerStorageStrategy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLOpenGLSurface::setLayerStorageStrategy </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga5a179736bbaa6140780153039419128f">TSLOpenGLStorageStrategyEnum</a></td>          <td class="paramname"><span class="paramname"><em>strategy</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the current storage strategy for the given data layer. See the documentation for <a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga5a179736bbaa6140780153039419128f">TSLOpenGLStorageStrategyEnum</a> for a description of the possible values.</p>
<p>Returns false if the given layer is not present in the drawing surface, otherwise returns true. </p>

</div>
</div>
<a id="a45d411a70bce77cf1a5abf85ea2df29a" name="a45d411a70bce77cf1a5abf85ea2df29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d411a70bce77cf1a5abf85ea2df29a">&#9670;&#160;</a></span>setLayerTransparencyHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLOpenGLSurface::setLayerTransparencyHint </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga38981acc5b361a3b59eede68ba2021a4">TSLOpenGLTransparencyHintEnum</a></td>          <td class="paramname"><span class="paramname"><em>hint</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the transparency hint for the given data layer. See the documentation for <a class="el" href="group__apigroup__maplink__opengl__drawing__surface__api.html#ga38981acc5b361a3b59eede68ba2021a4">TSLOpenGLTransparencyHintEnum</a> for a description of the possible values, and the OpenGL Drawing Surface - Transparency section of the MapLink Developer's Guide for more detail.</p>
<p>Returns false if the given layer is not present in the drawing surface, otherwise returns true. </p>

</div>
</div>
<a id="ab09e7576eb4226bf32dfa2b6cef4145b" name="ab09e7576eb4226bf32dfa2b6cef4145b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab09e7576eb4226bf32dfa2b6cef4145b">&#9670;&#160;</a></span>setRGBABackgroundColour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLOpenGLSurface::setRGBABackgroundColour </td>
          <td>(</td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char</td>          <td class="paramname"><span class="paramname"><em>a</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the default background colour of the drawing surface. If the drawing surface is attached to a framebuffer with an alpha channel, the alpha channel will be cleared to the specified value. </p>

</div>
</div>
<a id="ac5932411f19711eb3d6af4a5b8787195" name="ac5932411f19711eb3d6af4a5b8787195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5932411f19711eb3d6af4a5b8787195">&#9670;&#160;</a></span>setSwitchRangeForFP64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLOpenGLSurface::setSwitchRangeForFP64 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>range</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows the range at which to switch to FP64 calculations on the GPU to be specified by the application.</p>
<p>This is related to realtime reprojection.</p>
<p>By default the projection shader maths is performed using 32bit float.</p>
<p>Depending on the accuracy required and the capability of the GPU we need to switch to using 64bit floating point.</p>
<p>Using FP64 is expensive and as such we only switch to FP64 shaders when necessary.</p>
<p>This method provides the ability to override the switch point.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">range</td><td>in Nautical Miles (default is 10NM) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a77230d0d6604c7bb9eb09bb6f23d26aa" name="a77230d0d6604c7bb9eb09bb6f23d26aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77230d0d6604c7bb9eb09bb6f23d26aa">&#9670;&#160;</a></span>shaderPreloadEnabled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLOpenGLSurface::shaderPreloadEnabled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query whether shader preloading is enabled on the surface</p>
<dl class="section return"><dt>Returns</dt><dd>true if shader preloading is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="a0b883dd87243d69e7df3545ab54e94cb" name="a0b883dd87243d69e7df3545ab54e94cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b883dd87243d69e7df3545ab54e94cb">&#9670;&#160;</a></span>shaderPreloadEnabled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLOpenGLSurface::shaderPreloadEnabled </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enabled</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable shader preloading</p>
<p>If enabled this option will allow the application to pre-load OpenGL shaders prior to the point they are required.</p>
<p>This will also prevent the surface from flushing/deleting shader programs in most situations.</p>
<p>These options are provided in order to avoid visual stalls related to shader compilation when using realtime reprojection.</p>
<p>Most applications should not need to enable this feature as shader compilation is usually fast enough that no stalls will be observed. If you are using this method please contact Envitia support to discuss your use case.</p>
<p>If disabled (The default) the drawing surface will load shader programs as needed, and will flush loaded shaders when switching between display projections/floating point precision modes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>Whether shader preloading should be enabled. By default shader preloading is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a005d2645e416e78abf3321ef206849c9" name="a005d2645e416e78abf3321ef206849c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a005d2645e416e78abf3321ef206849c9">&#9670;&#160;</a></span>stateTracker()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_open_g_l_state_tracker.html">TSLOpenGLStateTracker</a> * TSLOpenGLSurface::stateTracker </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the internal OpenGL state tracker used by this drawing surface. If the drawing surface is not attached, this method returns NULL. </p>

</div>
</div>
<a id="ac1e6c241c81e776d972f9ea4077454bf" name="ac1e6c241c81e776d972f9ea4077454bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e6c241c81e776d972f9ea4077454bf">&#9670;&#160;</a></span>targetFrameBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">GLuint TSLOpenGLSurface::targetFrameBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The framebuffer that MapLink will render into.</p>
<dl class="section return"><dt>Returns</dt><dd>The framebuffer that MapLink will render into. </dd></dl>

</div>
</div>
<a id="aa53d93f56835ee6f98203a20d498654e" name="aa53d93f56835ee6f98203a20d498654e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53d93f56835ee6f98203a20d498654e">&#9670;&#160;</a></span>targetFrameBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLOpenGLSurface::targetFrameBuffer </td>
          <td>(</td>
          <td class="paramtype">GLuint</td>          <td class="paramname"><span class="paramname"><em>fbo</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows the user to set the framebuffer that MapLink will render into.</p>
<p>If the OpenGL drawing surface is attached to an existing OpenGL context, the FBO will be read from the context. Otherwise the FBO will default to zero.</p>
<p>The application may change the framebuffer target in order to render MapLink into a framebuffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fbo</td><td>The target framebuffer to render into.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if fbo was set, false otherwise. </dd></dl>

</div>
</div>
<a id="ae116e68568ad88530021f4fe7d1c3a73" name="ae116e68568ad88530021f4fe7d1c3a73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae116e68568ad88530021f4fe7d1c3a73">&#9670;&#160;</a></span>textRoundingAmount() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TSLOpenGLSurface::textRoundingAmount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the amount of text rounding.</p>
<dl class="section return"><dt>Returns</dt><dd>The text rounding amount. </dd></dl>

</div>
</div>
<a id="a2ce6501aafd7bb4eb374f912c3267813" name="a2ce6501aafd7bb4eb374f912c3267813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce6501aafd7bb4eb374f912c3267813">&#9670;&#160;</a></span>textRoundingAmount() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLOpenGLSurface::textRoundingAmount </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>px</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the amount of text rounding in pixels.</p>
<p>If textRoundingEnabled is true, text objects will be positioned to an aligned pixel position, based on this value. The position of text on the display will not move, until the text has moved more than this distance horizontally or vertically.</p>
<p>By default textRoundingAmount is set to 1 pixel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">px</td><td>The text rounding amount in pixels. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab70fbc36211784d2d59258305a35d09d" name="ab70fbc36211784d2d59258305a35d09d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70fbc36211784d2d59258305a35d09d">&#9670;&#160;</a></span>textRoundingEnabled() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLOpenGLSurface::textRoundingEnabled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query whether text rounding is enabled on the surface.</p>
<dl class="section return"><dt>Returns</dt><dd>true if text rounding is enabled, false otherwise. </dd></dl>

</div>
</div>
<a id="ab301106ee62dc5482f4f65619a6c5dfa" name="ab301106ee62dc5482f4f65619a6c5dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab301106ee62dc5482f4f65619a6c5dfa">&#9670;&#160;</a></span>textRoundingEnabled() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLOpenGLSurface::textRoundingEnabled </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enabled</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable/Disable text rounding</p>
<p>By default text rounding is enabled, with a textRoundingAmount of 1 pixel.</p>
<p>If enabled the position of text objects on the display will be rounded to ensure the text aligns with pixels on the screen. This will affect any <a class="el" href="class_t_s_l_text.html">TSLText</a> object drawn by the application, or data drawn by a <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>. Text drawn through <a class="el" href="class_t_s_l_rendering_interface.html#a6e27b2bcbdbb0ef781999e4881734a66">TSLRenderingInterface::drawText</a> without providing a <a class="el" href="class_t_s_l_text.html">TSLText</a> object will always be rounded to the nearest pixel.</p>
<p>When rounding is enabled, and realtime reprojection is enabled the text objects may jitter back/forth slightly on the display in situations where the projection origin is updated frequently.</p>
<p>In this scenario one of the following is recommended:</p><ul>
<li>Text rounding enabled, and textRoundingAmount increased to reduce the jitter. In this case the text will still visibly 'jump' on the display however as it will move by a larger amount will be more predictable/stable.</li>
<li>Text rounding disabled in order to ensure text is always aligned with the underlying map. In this case the text will no longer be rounded, and may be slightly harder to read. We recommend the use of multisample anti-aliasing (at least 4x) in this case in order to improve text readability.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>true to enable text rounding, false to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_open_g_l_surface.html">TSLOpenGLSurface</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.1.2.0. | Documentation created Mon May 12 2025 | Generated with <a href="http://www.doxygen.org/index.html">Doxygen 1.13.2</a> | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
