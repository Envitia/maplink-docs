<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLNetwork Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.2</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_network.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_t_s_l_network-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLNetwork Class Reference<div class="ingroups"><a class="el" href="group__group__networksdk.html">MapLink Network API</a> &raquo; <a class="el" href="group__group__networksdk__network.html">Network</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class represents a generic network of nodes and links, where the nodes are <a class="el" href="class_t_s_l_node.html">TSLNode</a> objects and the links are <a class="el" href="class_t_s_l_link.html">TSLLink</a> objects. A link inserted between two nodes is considered uni-directional; therefore 2 links are required for bi-directional linkage.</p>
<p>The network also introduces the concept of inter-link relationships (turns). For example, in a road network, whilst two junctions may be physically connected, traffic may be prohibited from following a particular set of links (e.g. no left turn at a junction). A traditional solution to this is to locally expand the number of junction nodes and create 'dummy' one-way links which can lead to an explosion of nodes and links. The solution used by MapLink is to allow clients to specify relationships between links, where this is required. The absence of such a relationship implies freedom of connection between corresponding links. This allows clients to create networks corresponding directly to those in their problem domain; to then add the costs of inter-link communication where necessary, again corresponding directly to the problem domain. The accompanying route-traversal class is intelligent enough to use this information for routing network flow appropriately.</p>
<p>A Spatial Index can be created that provides a more efficient search mechanism for links. Functions exist to query the Spatial Index status, invalidate it and to update it. Additionally, the Spatial Index can be saved to a file and loaded from a previously stored file. It is advisable to save the Spatial Index, when the Network is stable, as it is much quicker to load from file than to recreate it. Adding nodes or links invalidates the Spatial Index. However, if a link's geometry is changed, the user should invalidate the Spatial Index explicitly. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_network_1_1_streamer.html">Streamer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5c08c798944f061ebaa693bb79a20e57" id="r_a5c08c798944f061ebaa693bb79a20e57"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c08c798944f061ebaa693bb79a20e57">find_type</a> { <a class="el" href="#a5c08c798944f061ebaa693bb79a20e57a483a204ef713f34d8c69687710099297">tsl_nwk_find_nodes</a> = 0
, <a class="el" href="#a5c08c798944f061ebaa693bb79a20e57a9b63e0c6dbe931e07f645b2029cc8f00">tsl_nwk_find_links</a> = 1
, <a class="el" href="#a5c08c798944f061ebaa693bb79a20e57ac576dbd4b6da22b00b7be697cbd97b0b">tsl_nwk_find_both</a> = 2
 }</td></tr>
<tr class="separator:a5c08c798944f061ebaa693bb79a20e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9cbcd7fb4644faf14a70e619070b6ca8" id="r_a9cbcd7fb4644faf14a70e619070b6ca8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cbcd7fb4644faf14a70e619070b6ca8">appendNetwork</a> (<a class="el" href="class_t_s_l_network.html">TSLNetwork</a> *other)</td></tr>
<tr class="separator:a9cbcd7fb4644faf14a70e619070b6ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4303501fa43f9e8e7c30dcfb1b94fe9b" id="r_a4303501fa43f9e8e7c30dcfb1b94fe9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4303501fa43f9e8e7c30dcfb1b94fe9b">appendNetworkCopy</a> (const <a class="el" href="class_t_s_l_network.html">TSLNetwork</a> *other)</td></tr>
<tr class="separator:a4303501fa43f9e8e7c30dcfb1b94fe9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97c1b927aeb8cfebbeb92a61d6a9ea8" id="r_af97c1b927aeb8cfebbeb92a61d6a9ea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af97c1b927aeb8cfebbeb92a61d6a9ea8">begin_links</a> ()</td></tr>
<tr class="separator:af97c1b927aeb8cfebbeb92a61d6a9ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12aaf5de7ee1076ea02e7d6004902b4" id="r_ac12aaf5de7ee1076ea02e7d6004902b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac12aaf5de7ee1076ea02e7d6004902b4">begin_links</a> () const</td></tr>
<tr class="separator:ac12aaf5de7ee1076ea02e7d6004902b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a188b86b0d2796e7be1070b4162761444" id="r_a188b86b0d2796e7be1070b4162761444"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a188b86b0d2796e7be1070b4162761444">begin_links</a> (int src)</td></tr>
<tr class="separator:a188b86b0d2796e7be1070b4162761444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7100ef5894e20e772eff295791f3128" id="r_af7100ef5894e20e772eff295791f3128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7100ef5894e20e772eff295791f3128">begin_links</a> (int src) const</td></tr>
<tr class="separator:af7100ef5894e20e772eff295791f3128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a305ef659b3b2cf8cd5599da6ef28facc" id="r_a305ef659b3b2cf8cd5599da6ef28facc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a305ef659b3b2cf8cd5599da6ef28facc">begin_links</a> (const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;it)</td></tr>
<tr class="separator:a305ef659b3b2cf8cd5599da6ef28facc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a611b0bd96aba487f0719339175a4cd55" id="r_a611b0bd96aba487f0719339175a4cd55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a611b0bd96aba487f0719339175a4cd55">begin_links</a> (const <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a> &amp;it) const</td></tr>
<tr class="separator:a611b0bd96aba487f0719339175a4cd55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664379b7a39036cf93171e13a5463b47" id="r_a664379b7a39036cf93171e13a5463b47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a664379b7a39036cf93171e13a5463b47">begin_nodes</a> ()</td></tr>
<tr class="separator:a664379b7a39036cf93171e13a5463b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012823edf74bfeb6f10aabc092c02437" id="r_a012823edf74bfeb6f10aabc092c02437"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a012823edf74bfeb6f10aabc092c02437">begin_nodes</a> () const</td></tr>
<tr class="separator:a012823edf74bfeb6f10aabc092c02437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612128a440d1bc96d730d8620c68b430" id="r_a612128a440d1bc96d730d8620c68b430"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a612128a440d1bc96d730d8620c68b430">begin_turns</a> ()</td></tr>
<tr class="separator:a612128a440d1bc96d730d8620c68b430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae50a137e7f647f4c243b97723b290655" id="r_ae50a137e7f647f4c243b97723b290655"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae50a137e7f647f4c243b97723b290655">begin_turns</a> () const</td></tr>
<tr class="separator:ae50a137e7f647f4c243b97723b290655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9138550769882f590a0848971853ab0" id="r_ad9138550769882f590a0848971853ab0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad9138550769882f590a0848971853ab0">begin_turns</a> (int src)</td></tr>
<tr class="separator:ad9138550769882f590a0848971853ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb54686560a394c0cac53d409dc1744" id="r_a9bb54686560a394c0cac53d409dc1744"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9bb54686560a394c0cac53d409dc1744">begin_turns</a> (int src) const</td></tr>
<tr class="separator:a9bb54686560a394c0cac53d409dc1744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c459abcc8b08b33945469d61cea166" id="r_a31c459abcc8b08b33945469d61cea166"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a31c459abcc8b08b33945469d61cea166">begin_turns</a> (const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;it)</td></tr>
<tr class="separator:a31c459abcc8b08b33945469d61cea166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03193e8b8956ec5aff503dd5548cfa5e" id="r_a03193e8b8956ec5aff503dd5548cfa5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03193e8b8956ec5aff503dd5548cfa5e">begin_turns</a> (const <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a> &amp;it) const</td></tr>
<tr class="separator:a03193e8b8956ec5aff503dd5548cfa5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb245b19c1cc59f2a25753531948663" id="r_aacb245b19c1cc59f2a25753531948663"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacb245b19c1cc59f2a25753531948663">capacity</a> () const</td></tr>
<tr class="separator:aacb245b19c1cc59f2a25753531948663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a7e1c1aa21f6a46067faa43c2793de" id="r_a51a7e1c1aa21f6a46067faa43c2793de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a51a7e1c1aa21f6a46067faa43c2793de">clear</a> ()</td></tr>
<tr class="separator:a51a7e1c1aa21f6a46067faa43c2793de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb741aa81e57db0e0dbd71c9015f56a1" id="r_abb741aa81e57db0e0dbd71c9015f56a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abb741aa81e57db0e0dbd71c9015f56a1">clear_links</a> ()</td></tr>
<tr class="separator:abb741aa81e57db0e0dbd71c9015f56a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429e0a07b4d9254773d72eb0783ca3e1" id="r_a429e0a07b4d9254773d72eb0783ca3e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a429e0a07b4d9254773d72eb0783ca3e1">clear_turns</a> ()</td></tr>
<tr class="separator:a429e0a07b4d9254773d72eb0783ca3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd47931c99eb1e86749e19faface979" id="r_adbd47931c99eb1e86749e19faface979"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adbd47931c99eb1e86749e19faface979">destroy</a> ()</td></tr>
<tr class="separator:adbd47931c99eb1e86749e19faface979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33ced98cb8a6031211570f92f4bc990" id="r_af33ced98cb8a6031211570f92f4bc990"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af33ced98cb8a6031211570f92f4bc990">empty</a> ()</td></tr>
<tr class="separator:af33ced98cb8a6031211570f92f4bc990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad45d1d464258b8f613c91d88e21c0f6f" id="r_ad45d1d464258b8f613c91d88e21c0f6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad45d1d464258b8f613c91d88e21c0f6f">empty_links</a> ()</td></tr>
<tr class="separator:ad45d1d464258b8f613c91d88e21c0f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b8ffe190b8ec885523bf93cb01ae439" id="r_a9b8ffe190b8ec885523bf93cb01ae439"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b8ffe190b8ec885523bf93cb01ae439">empty_turns</a> ()</td></tr>
<tr class="separator:a9b8ffe190b8ec885523bf93cb01ae439"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ce79c3aaa55e120b61dc8105e57458" id="r_a22ce79c3aaa55e120b61dc8105e57458"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22ce79c3aaa55e120b61dc8105e57458">end_links</a> (const <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a> &amp;it) const</td></tr>
<tr class="separator:a22ce79c3aaa55e120b61dc8105e57458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53545ab0f2818bc71a5a824533f5f5b6" id="r_a53545ab0f2818bc71a5a824533f5f5b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a53545ab0f2818bc71a5a824533f5f5b6">end_links</a> ()</td></tr>
<tr class="separator:a53545ab0f2818bc71a5a824533f5f5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e6ee6f7aee676d251437cc76b93213f" id="r_a8e6ee6f7aee676d251437cc76b93213f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e6ee6f7aee676d251437cc76b93213f">end_links</a> () const</td></tr>
<tr class="separator:a8e6ee6f7aee676d251437cc76b93213f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee3bc08f664e9e289ec564eba012ec9" id="r_a0ee3bc08f664e9e289ec564eba012ec9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ee3bc08f664e9e289ec564eba012ec9">end_links</a> (int src)</td></tr>
<tr class="separator:a0ee3bc08f664e9e289ec564eba012ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cdf0ff1e823d38734571e94b8f1783" id="r_a16cdf0ff1e823d38734571e94b8f1783"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a16cdf0ff1e823d38734571e94b8f1783">end_links</a> (int src) const</td></tr>
<tr class="separator:a16cdf0ff1e823d38734571e94b8f1783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac791d911bfa7d726c8da4882b10eb4a8" id="r_ac791d911bfa7d726c8da4882b10eb4a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac791d911bfa7d726c8da4882b10eb4a8">end_links</a> (const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;it)</td></tr>
<tr class="separator:ac791d911bfa7d726c8da4882b10eb4a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0132b34c32291c27e76c667f14b8ec95" id="r_a0132b34c32291c27e76c667f14b8ec95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0132b34c32291c27e76c667f14b8ec95">end_nodes</a> () const</td></tr>
<tr class="separator:a0132b34c32291c27e76c667f14b8ec95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea315790dcd639005744ad0e6e37b1a" id="r_acea315790dcd639005744ad0e6e37b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acea315790dcd639005744ad0e6e37b1a">end_nodes</a> ()</td></tr>
<tr class="separator:acea315790dcd639005744ad0e6e37b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09dd8621e32ab8336f2ab7afd5273b59" id="r_a09dd8621e32ab8336f2ab7afd5273b59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09dd8621e32ab8336f2ab7afd5273b59">end_turns</a> ()</td></tr>
<tr class="separator:a09dd8621e32ab8336f2ab7afd5273b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5d7e1f871530810229dc59690ca18e" id="r_a8e5d7e1f871530810229dc59690ca18e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e5d7e1f871530810229dc59690ca18e">end_turns</a> () const</td></tr>
<tr class="separator:a8e5d7e1f871530810229dc59690ca18e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13728a4e47e5d7191589610e4b576383" id="r_a13728a4e47e5d7191589610e4b576383"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13728a4e47e5d7191589610e4b576383">end_turns</a> (int src)</td></tr>
<tr class="separator:a13728a4e47e5d7191589610e4b576383"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6d29b6be157d1eae887e67268c48bf" id="r_a2a6d29b6be157d1eae887e67268c48bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a6d29b6be157d1eae887e67268c48bf">end_turns</a> (int src) const</td></tr>
<tr class="separator:a2a6d29b6be157d1eae887e67268c48bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a942507957af5de78da0f1cd6b12ed0" id="r_a5a942507957af5de78da0f1cd6b12ed0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5a942507957af5de78da0f1cd6b12ed0">end_turns</a> (const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;it)</td></tr>
<tr class="separator:a5a942507957af5de78da0f1cd6b12ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fdebf3f6a33f86fd02b741fc9560e5" id="r_a95fdebf3f6a33f86fd02b741fc9560e5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95fdebf3f6a33f86fd02b741fc9560e5">end_turns</a> (const <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a> &amp;it) const</td></tr>
<tr class="separator:a95fdebf3f6a33f86fd02b741fc9560e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8131a028572368b3e07bf0798481b072" id="r_a8131a028572368b3e07bf0798481b072"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8131a028572368b3e07bf0798481b072">erase_links</a> (const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;first, const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;last)</td></tr>
<tr class="separator:a8131a028572368b3e07bf0798481b072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8abe2ad3f184ab7d3782d83914fe19c" id="r_ad8abe2ad3f184ab7d3782d83914fe19c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8abe2ad3f184ab7d3782d83914fe19c">erase_links</a> (const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;it)</td></tr>
<tr class="separator:ad8abe2ad3f184ab7d3782d83914fe19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616ac09838d67bd1fd3831f4cc081acc" id="r_a616ac09838d67bd1fd3831f4cc081acc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a616ac09838d67bd1fd3831f4cc081acc">erase_links</a> (int dest)</td></tr>
<tr class="separator:a616ac09838d67bd1fd3831f4cc081acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6258e42def4786e770588b7f8a7ffc" id="r_acb6258e42def4786e770588b7f8a7ffc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb6258e42def4786e770588b7f8a7ffc">erase_nodes</a> (int first, int last)</td></tr>
<tr class="separator:acb6258e42def4786e770588b7f8a7ffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39b29f13c900e53dad4136cb76856193" id="r_a39b29f13c900e53dad4136cb76856193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a39b29f13c900e53dad4136cb76856193">erase_nodes</a> (int src)</td></tr>
<tr class="separator:a39b29f13c900e53dad4136cb76856193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad167677314ca5bbd11a59a3fdc244989" id="r_ad167677314ca5bbd11a59a3fdc244989"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad167677314ca5bbd11a59a3fdc244989">erase_nodes</a> (const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;first, const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;last)</td></tr>
<tr class="separator:ad167677314ca5bbd11a59a3fdc244989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2e5a6d813ef47945a9cfd01a8b0cb8c" id="r_ac2e5a6d813ef47945a9cfd01a8b0cb8c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2e5a6d813ef47945a9cfd01a8b0cb8c">erase_nodes</a> (const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;it)</td></tr>
<tr class="separator:ac2e5a6d813ef47945a9cfd01a8b0cb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a427f3518e917bd40470fddbdc117ba22" id="r_a427f3518e917bd40470fddbdc117ba22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a427f3518e917bd40470fddbdc117ba22">erase_turns</a> (const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;it)</td></tr>
<tr class="separator:a427f3518e917bd40470fddbdc117ba22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f8f8cd3487382d273abf09e569abe4" id="r_a52f8f8cd3487382d273abf09e569abe4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52f8f8cd3487382d273abf09e569abe4">erase_turns</a> (int the_node)</td></tr>
<tr class="separator:a52f8f8cd3487382d273abf09e569abe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcc55c0c594af8c7506a63bb8fb25bc8" id="r_adcc55c0c594af8c7506a63bb8fb25bc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adcc55c0c594af8c7506a63bb8fb25bc8">find</a> (const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent, const <a class="el" href="class_t_s_l_nwk_finder.html">TSLNwkFinder</a> &amp;filter, <a class="el" href="#a5c08c798944f061ebaa693bb79a20e57">find_type</a> filter_mode=<a class="el" href="#a5c08c798944f061ebaa693bb79a20e57ac576dbd4b6da22b00b7be697cbd97b0b">tsl_nwk_find_both</a>) const</td></tr>
<tr class="separator:adcc55c0c594af8c7506a63bb8fb25bc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc42223576826283c848674fd37cba81" id="r_abc42223576826283c848674fd37cba81"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc42223576826283c848674fd37cba81">find_link</a> (const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;location, int aperture) const</td></tr>
<tr class="separator:abc42223576826283c848674fd37cba81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b269504a8b1ba01ab8b75a014d3426" id="r_ae9b269504a8b1ba01ab8b75a014d3426"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9b269504a8b1ba01ab8b75a014d3426">find_links</a> (const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;location, int aperture, const <a class="el" href="class_t_s_l_nwk_finder.html">TSLNwkFinder</a> *filter=NULL, int limit=-1, bool useSpatialIndex=true)</td></tr>
<tr class="separator:ae9b269504a8b1ba01ab8b75a014d3426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77092e1c5fdbc5564b8c6eaf965dcc4" id="r_ab77092e1c5fdbc5564b8c6eaf965dcc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab77092e1c5fdbc5564b8c6eaf965dcc4">find_node</a> (const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;location, int aperture) const</td></tr>
<tr class="separator:ab77092e1c5fdbc5564b8c6eaf965dcc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a93582e6f2eea204b121c9d6c11a46c" id="r_a3a93582e6f2eea204b121c9d6c11a46c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a93582e6f2eea204b121c9d6c11a46c">get_node</a> (int pos)</td></tr>
<tr class="separator:a3a93582e6f2eea204b121c9d6c11a46c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa528eae4cd93355c44a2d88586683809" id="r_aa528eae4cd93355c44a2d88586683809"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa528eae4cd93355c44a2d88586683809">get_node</a> (int pos) const</td></tr>
<tr class="separator:aa528eae4cd93355c44a2d88586683809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1205e3cfdd9975dbd4a195cf51252e0" id="r_ab1205e3cfdd9975dbd4a195cf51252e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab1205e3cfdd9975dbd4a195cf51252e0">insert_link</a> (int src, int dest, const <a class="el" href="class_t_s_l_link.html">TSLLink</a> &amp;the_link=<a class="el" href="class_t_s_l_link.html">TSLLink</a>())</td></tr>
<tr class="separator:ab1205e3cfdd9975dbd4a195cf51252e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adef5c0f745b442298a878f0466a10a1f" id="r_adef5c0f745b442298a878f0466a10a1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adef5c0f745b442298a878f0466a10a1f">insert_link</a> (const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;link_it, const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;dest_it, const <a class="el" href="class_t_s_l_link.html">TSLLink</a> &amp;the_link=<a class="el" href="class_t_s_l_link.html">TSLLink</a>())</td></tr>
<tr class="separator:adef5c0f745b442298a878f0466a10a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad547c1e9b747c81fc26888cf4847b272" id="r_ad547c1e9b747c81fc26888cf4847b272"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad547c1e9b747c81fc26888cf4847b272">insert_link</a> (const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;src_it, const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;dest_it, const <a class="el" href="class_t_s_l_link.html">TSLLink</a> &amp;the_link=<a class="el" href="class_t_s_l_link.html">TSLLink</a>())</td></tr>
<tr class="separator:ad547c1e9b747c81fc26888cf4847b272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca515404e42d30d67aafb34377b017d0" id="r_aca515404e42d30d67aafb34377b017d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca515404e42d30d67aafb34377b017d0">insert_nodes</a> (const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;it, const <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;the_node=<a class="el" href="class_t_s_l_node.html">TSLNode</a>())</td></tr>
<tr class="separator:aca515404e42d30d67aafb34377b017d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa9cbe7eb9c532799d03a4b08813ae6" id="r_a7aa9cbe7eb9c532799d03a4b08813ae6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7aa9cbe7eb9c532799d03a4b08813ae6">insert_nodes</a> (const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;it, int N, const <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;the_node=<a class="el" href="class_t_s_l_node.html">TSLNode</a>())</td></tr>
<tr class="separator:a7aa9cbe7eb9c532799d03a4b08813ae6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2077795f97987812c499769798733f04" id="r_a2077795f97987812c499769798733f04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2077795f97987812c499769798733f04">insert_turn</a> (const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;src_it, const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;dest_it, const <a class="el" href="group__group__networksdk__network.html#ga0f95f705951d51122e4e334f83b61dcd">TSLTurn</a> &amp;the_turn=<a class="el" href="group__group__networksdk__network.html#ga0f95f705951d51122e4e334f83b61dcd">TSLTurn</a>())</td></tr>
<tr class="separator:a2077795f97987812c499769798733f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1421a364740a025947a34d23571e7971" id="r_a1421a364740a025947a34d23571e7971"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1421a364740a025947a34d23571e7971">insert_turn</a> (int src, int dest, int via, const <a class="el" href="group__group__networksdk__network.html#ga0f95f705951d51122e4e334f83b61dcd">TSLTurn</a> &amp;the_turn=<a class="el" href="group__group__networksdk__network.html#ga0f95f705951d51122e4e334f83b61dcd">TSLTurn</a>())</td></tr>
<tr class="separator:a1421a364740a025947a34d23571e7971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c60a4944583d8336a3dfbbf32a70b9" id="r_a15c60a4944583d8336a3dfbbf32a70b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15c60a4944583d8336a3dfbbf32a70b9">invalidateSpatialIndex</a> ()</td></tr>
<tr class="separator:a15c60a4944583d8336a3dfbbf32a70b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f994a4c8d71074aceb127b3e6a8949e" id="r_a1f994a4c8d71074aceb127b3e6a8949e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f994a4c8d71074aceb127b3e6a8949e">isEdgeNode</a> (int index) const</td></tr>
<tr class="separator:a1f994a4c8d71074aceb127b3e6a8949e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1f42ce4d2aa98ca10bdfaeaf51a828" id="r_a0d1f42ce4d2aa98ca10bdfaeaf51a828"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d1f42ce4d2aa98ca10bdfaeaf51a828">isStitchNode</a> (int index) const</td></tr>
<tr class="separator:a0d1f42ce4d2aa98ca10bdfaeaf51a828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0ac3e4b397edc8da6c7c7a34149e66" id="r_abd0ac3e4b397edc8da6c7c7a34149e66"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd0ac3e4b397edc8da6c7c7a34149e66">linkDestinNode</a> (const <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> &amp;it) const</td></tr>
<tr class="separator:abd0ac3e4b397edc8da6c7c7a34149e66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d76f4367c09f64c148bb5bb9282cdf3" id="r_a7d76f4367c09f64c148bb5bb9282cdf3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d76f4367c09f64c148bb5bb9282cdf3">linkDestinNodePos</a> (const <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> &amp;it) const</td></tr>
<tr class="separator:a7d76f4367c09f64c148bb5bb9282cdf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63135066d841881f79566ceba8016a1" id="r_aa63135066d841881f79566ceba8016a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa63135066d841881f79566ceba8016a1">linkNodes</a> (const <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> &amp;it, <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;src, <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;dst) const</td></tr>
<tr class="separator:aa63135066d841881f79566ceba8016a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa315047a145cf596b810920dd0cd240a" id="r_aa315047a145cf596b810920dd0cd240a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa315047a145cf596b810920dd0cd240a">linkNodes</a> (const <a class="el" href="class_t_s_l_link.html">TSLLink</a> &amp;link, <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;src, <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;dst) const</td></tr>
<tr class="separator:aa315047a145cf596b810920dd0cd240a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa046f0043ff6ccaba240b58076abe6e4" id="r_aa046f0043ff6ccaba240b58076abe6e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1_streamer.html">Streamer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa046f0043ff6ccaba240b58076abe6e4">links</a> ()</td></tr>
<tr class="separator:aa046f0043ff6ccaba240b58076abe6e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab66b5a574370b825f69f28dc69ec09f3" id="r_ab66b5a574370b825f69f28dc69ec09f3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab66b5a574370b825f69f28dc69ec09f3">linkSourceNode</a> (const <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> &amp;it) const</td></tr>
<tr class="separator:ab66b5a574370b825f69f28dc69ec09f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25e807adddce7871d099d61a0dc8352c" id="r_a25e807adddce7871d099d61a0dc8352c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25e807adddce7871d099d61a0dc8352c">linkSourceNodePos</a> (const <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> &amp;it) const</td></tr>
<tr class="separator:a25e807adddce7871d099d61a0dc8352c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0713184b271a811df142cba85c5b0a" id="r_a2f0713184b271a811df142cba85c5b0a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f0713184b271a811df142cba85c5b0a">loadSpatialIndex</a> (<a class="el" href="class_t_s_lifstream.html">TSLifstream</a> &amp;inputStream)</td></tr>
<tr class="separator:a2f0713184b271a811df142cba85c5b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ffc346df3ad720b5d913b8fc448a768" id="r_a4ffc346df3ad720b5d913b8fc448a768"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ffc346df3ad720b5d913b8fc448a768">markEdgeNode</a> (int index)</td></tr>
<tr class="separator:a4ffc346df3ad720b5d913b8fc448a768"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890c08be0635545865a473a127f95b89" id="r_a890c08be0635545865a473a127f95b89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a890c08be0635545865a473a127f95b89">markStitchNode</a> (int index)</td></tr>
<tr class="separator:a890c08be0635545865a473a127f95b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2000a695abe56c6be95876689ea6ccc5" id="r_a2000a695abe56c6be95876689ea6ccc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2000a695abe56c6be95876689ea6ccc5">mergeEdgeNodes</a> (const <a class="el" href="class_t_s_l_node_cmp.html">TSLNodeCmp</a> &amp;nodePred, const <a class="el" href="class_t_s_l_link_cmp.html">TSLLinkCmp</a> &amp;linkPred)</td></tr>
<tr class="separator:a2000a695abe56c6be95876689ea6ccc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af310255c014370cd123d227262c8a648" id="r_af310255c014370cd123d227262c8a648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af310255c014370cd123d227262c8a648">mergeNetwork</a> (<a class="el" href="class_t_s_l_network.html">TSLNetwork</a> *other, const <a class="el" href="class_t_s_l_node_cmp.html">TSLNodeCmp</a> &amp;nodePred)</td></tr>
<tr class="separator:af310255c014370cd123d227262c8a648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d03a7fac49b5599b14eef4cb4f81420" id="r_a5d03a7fac49b5599b14eef4cb4f81420"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1_streamer.html">Streamer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d03a7fac49b5599b14eef4cb4f81420">net__</a> ()</td></tr>
<tr class="separator:a5d03a7fac49b5599b14eef4cb4f81420"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5301dcd66b13e7bc8e1709c56b4dbc51" id="r_a5301dcd66b13e7bc8e1709c56b4dbc51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1_streamer.html">Streamer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5301dcd66b13e7bc8e1709c56b4dbc51">nodes</a> ()</td></tr>
<tr class="separator:a5301dcd66b13e7bc8e1709c56b4dbc51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af323c5654c1faeac89fdc63e9c0bf858" id="r_af323c5654c1faeac89fdc63e9c0bf858"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af323c5654c1faeac89fdc63e9c0bf858">pop_back</a> ()</td></tr>
<tr class="separator:af323c5654c1faeac89fdc63e9c0bf858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41dd38ee4c8f0ad9416a3c99f1c8dde" id="r_ab41dd38ee4c8f0ad9416a3c99f1c8dde"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab41dd38ee4c8f0ad9416a3c99f1c8dde">push_back</a> (const <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;the_node)</td></tr>
<tr class="separator:ab41dd38ee4c8f0ad9416a3c99f1c8dde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4a20083b1d37063571cba5e2bf8abe" id="r_a3d4a20083b1d37063571cba5e2bf8abe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d4a20083b1d37063571cba5e2bf8abe">removeEdgeNode</a> (int index)</td></tr>
<tr class="separator:a3d4a20083b1d37063571cba5e2bf8abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ded0e3b7c05c8a764d42348382f770c" id="r_a6ded0e3b7c05c8a764d42348382f770c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ded0e3b7c05c8a764d42348382f770c">reserve</a> (int N)</td></tr>
<tr class="separator:a6ded0e3b7c05c8a764d42348382f770c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b0c625fe968fc9eccb349baf0a6313" id="r_a22b0c625fe968fc9eccb349baf0a6313"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a22b0c625fe968fc9eccb349baf0a6313">resize</a> (int N, <a class="el" href="class_t_s_l_node.html">TSLNode</a> the_node=<a class="el" href="class_t_s_l_node.html">TSLNode</a>())</td></tr>
<tr class="separator:a22b0c625fe968fc9eccb349baf0a6313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7270cac5a1300a198f583feb0eec1dcf" id="r_a7270cac5a1300a198f583feb0eec1dcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7270cac5a1300a198f583feb0eec1dcf">saveSpatialIndex</a> (<a class="el" href="class_t_s_lofstream.html">TSLofstream</a> &amp;outputStream) const</td></tr>
<tr class="separator:a7270cac5a1300a198f583feb0eec1dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c8c26d1a86a6e17161be4f659c0d72" id="r_a29c8c26d1a86a6e17161be4f659c0d72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a29c8c26d1a86a6e17161be4f659c0d72">spatialIndexUpToDate</a> () const</td></tr>
<tr class="separator:a29c8c26d1a86a6e17161be4f659c0d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8502209732a2615d367b4a3846cf465b" id="r_a8502209732a2615d367b4a3846cf465b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8502209732a2615d367b4a3846cf465b">size</a> () const</td></tr>
<tr class="separator:a8502209732a2615d367b4a3846cf465b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dd33d8a4ffa19c45296a91e094ff0e" id="r_af1dd33d8a4ffa19c45296a91e094ff0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1dd33d8a4ffa19c45296a91e094ff0e">size_links</a> () const</td></tr>
<tr class="separator:af1dd33d8a4ffa19c45296a91e094ff0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af32280bfde16e5c2770fc510d920473b" id="r_af32280bfde16e5c2770fc510d920473b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af32280bfde16e5c2770fc510d920473b">size_turns</a> () const</td></tr>
<tr class="separator:af32280bfde16e5c2770fc510d920473b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef3567c42f01b64c0c18cddb169557e" id="r_aeef3567c42f01b64c0c18cddb169557e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1_streamer.html">Streamer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeef3567c42f01b64c0c18cddb169557e">turns</a> ()</td></tr>
<tr class="separator:aeef3567c42f01b64c0c18cddb169557e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c4e110def9b484e665f85c7afc6226" id="r_a97c4e110def9b484e665f85c7afc6226"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97c4e110def9b484e665f85c7afc6226">turnDestinLink</a> (const <a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> &amp;it) const</td></tr>
<tr class="separator:a97c4e110def9b484e665f85c7afc6226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c6d9b288e8661b90e1872ee4ab3909" id="r_a09c6d9b288e8661b90e1872ee4ab3909"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09c6d9b288e8661b90e1872ee4ab3909">turnSourceLink</a> (const <a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> &amp;it) const</td></tr>
<tr class="separator:a09c6d9b288e8661b90e1872ee4ab3909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acebb940dd29a5548678da11ff349e681" id="r_acebb940dd29a5548678da11ff349e681"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acebb940dd29a5548678da11ff349e681">updateSpatialIndex</a> ()</td></tr>
<tr class="separator:acebb940dd29a5548678da11ff349e681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e922dc4b7fce6a17bd9cf7873ad01c8" id="r_a7e922dc4b7fce6a17bd9cf7873ad01c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e922dc4b7fce6a17bd9cf7873ad01c8">insert_link_between</a> (int src, int dest, const <a class="el" href="class_t_s_l_link.html">TSLLink</a> &amp;the_link=<a class="el" href="class_t_s_l_link.html">TSLLink</a>())</td></tr>
<tr class="separator:a7e922dc4b7fce6a17bd9cf7873ad01c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaa2ce0a9fa1b20e067248e62128a01a" id="r_adaa2ce0a9fa1b20e067248e62128a01a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adaa2ce0a9fa1b20e067248e62128a01a">mendEdgeNodes</a> (<a class="el" href="class_t_s_l_network.html">TSLNetwork</a> *other, const <a class="el" href="class_t_s_l_node_cmp.html">TSLNodeCmp</a> &amp;nodePred)</td></tr>
<tr class="separator:adaa2ce0a9fa1b20e067248e62128a01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546834f888da5d6ca62bf6eeec26c9ff" id="r_a546834f888da5d6ca62bf6eeec26c9ff"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a546834f888da5d6ca62bf6eeec26c9ff">operator new</a> (size_t <a class="el" href="#a8502209732a2615d367b4a3846cf465b">size</a>)</td></tr>
<tr class="separator:a546834f888da5d6ca62bf6eeec26c9ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9682a11d1063303fea693412568d7699" id="r_a9682a11d1063303fea693412568d7699"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9682a11d1063303fea693412568d7699">operator new</a> (size_t <a class="el" href="#a8502209732a2615d367b4a3846cf465b">size</a>, char *filename, int line)</td></tr>
<tr class="separator:a9682a11d1063303fea693412568d7699"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5c08c798944f061ebaa693bb79a20e57" name="a5c08c798944f061ebaa693bb79a20e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c08c798944f061ebaa693bb79a20e57">&#9670;&#160;</a></span>find_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a5c08c798944f061ebaa693bb79a20e57">TSLNetwork::find_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of find </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5c08c798944f061ebaa693bb79a20e57a483a204ef713f34d8c69687710099297" name="a5c08c798944f061ebaa693bb79a20e57a483a204ef713f34d8c69687710099297"></a>tsl_nwk_find_nodes&#160;</td><td class="fielddoc"><p>search for nodes only </p>
</td></tr>
<tr><td class="fieldname"><a id="a5c08c798944f061ebaa693bb79a20e57a9b63e0c6dbe931e07f645b2029cc8f00" name="a5c08c798944f061ebaa693bb79a20e57a9b63e0c6dbe931e07f645b2029cc8f00"></a>tsl_nwk_find_links&#160;</td><td class="fielddoc"><p>search for links only </p>
</td></tr>
<tr><td class="fieldname"><a id="a5c08c798944f061ebaa693bb79a20e57ac576dbd4b6da22b00b7be697cbd97b0b" name="a5c08c798944f061ebaa693bb79a20e57ac576dbd4b6da22b00b7be697cbd97b0b"></a>tsl_nwk_find_both&#160;</td><td class="fielddoc"><p>search for both nodes and links </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9cbcd7fb4644faf14a70e619070b6ca8" name="a9cbcd7fb4644faf14a70e619070b6ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cbcd7fb4644faf14a70e619070b6ca8">&#9670;&#160;</a></span>appendNetwork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLNetwork::appendNetwork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_network.html">TSLNetwork</a> *</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append one network to another. Invalidates the other network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Pointer to the network to append.</td></tr>
  </table>
  </dd>
</dl>
<p>Return true on success, false otherwise. </p>

</div>
</div>
<a id="a4303501fa43f9e8e7c30dcfb1b94fe9b" name="a4303501fa43f9e8e7c30dcfb1b94fe9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4303501fa43f9e8e7c30dcfb1b94fe9b">&#9670;&#160;</a></span>appendNetworkCopy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLNetwork::appendNetworkCopy </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network.html">TSLNetwork</a> *</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append a copy of one network to another.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>Pointer to the network to append.</td></tr>
  </table>
  </dd>
</dl>
<p>Return true on success, false otherwise. </p>

</div>
</div>
<a id="af97c1b927aeb8cfebbeb92a61d6a9ea8" name="af97c1b927aeb8cfebbeb92a61d6a9ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97c1b927aeb8cfebbeb92a61d6a9ea8">&#9670;&#160;</a></span>begin_links() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> TSLNetwork::begin_links </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for links in the network.</p>
<p>Returns a <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> to the first link. </p>

</div>
</div>
<a id="ac12aaf5de7ee1076ea02e7d6004902b4" name="ac12aaf5de7ee1076ea02e7d6004902b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12aaf5de7ee1076ea02e7d6004902b4">&#9670;&#160;</a></span>begin_links() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> TSLNetwork::begin_links </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for links in the network.</p>
<p>Returns a <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> to the first link. </p>

</div>
</div>
<a id="a611b0bd96aba487f0719339175a4cd55" name="a611b0bd96aba487f0719339175a4cd55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a611b0bd96aba487f0719339175a4cd55">&#9670;&#160;</a></span>begin_links() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> TSLNetwork::begin_links </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for the links outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Reference to the node iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> to the first outgoing link of the node associated with the given <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a>. </dd></dl>

</div>
</div>
<a id="a305ef659b3b2cf8cd5599da6ef28facc" name="a305ef659b3b2cf8cd5599da6ef28facc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a305ef659b3b2cf8cd5599da6ef28facc">&#9670;&#160;</a></span>begin_links() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> TSLNetwork::begin_links </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for the links outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>Reference to the node iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> to the first outgoing link of the node associated with the given <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>. </dd></dl>

</div>
</div>
<a id="a188b86b0d2796e7be1070b4162761444" name="a188b86b0d2796e7be1070b4162761444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a188b86b0d2796e7be1070b4162761444">&#9670;&#160;</a></span>begin_links() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> TSLNetwork::begin_links </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for the links outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The index of the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> to the first outgoing link of the node at the given index. </dd></dl>

</div>
</div>
<a id="af7100ef5894e20e772eff295791f3128" name="af7100ef5894e20e772eff295791f3128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7100ef5894e20e772eff295791f3128">&#9670;&#160;</a></span>begin_links() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> TSLNetwork::begin_links </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for the links outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The index of the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> to the first outgoing link of the node at the given index. </dd></dl>

</div>
</div>
<a id="a664379b7a39036cf93171e13a5463b47" name="a664379b7a39036cf93171e13a5463b47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664379b7a39036cf93171e13a5463b47">&#9670;&#160;</a></span>begin_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> TSLNetwork::begin_nodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for nodes in the network.</p>
<p>Returns a <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> to the first node. </p>

</div>
</div>
<a id="a012823edf74bfeb6f10aabc092c02437" name="a012823edf74bfeb6f10aabc092c02437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012823edf74bfeb6f10aabc092c02437">&#9670;&#160;</a></span>begin_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a> TSLNetwork::begin_nodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const ) for nodes in the network.</p>
<p>Returns a <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a> to the first node. </p>

</div>
</div>
<a id="a612128a440d1bc96d730d8620c68b430" name="a612128a440d1bc96d730d8620c68b430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a612128a440d1bc96d730d8620c68b430">&#9670;&#160;</a></span>begin_turns() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> TSLNetwork::begin_turns </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for turns in the network.</p>
<p>Returns a <a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> to the first turn. </p>

</div>
</div>
<a id="ae50a137e7f647f4c243b97723b290655" name="ae50a137e7f647f4c243b97723b290655"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae50a137e7f647f4c243b97723b290655">&#9670;&#160;</a></span>begin_turns() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> TSLNetwork::begin_turns </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for turns in the network.</p>
<p>Returns a <a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> to the first turn. </p>

</div>
</div>
<a id="a03193e8b8956ec5aff503dd5548cfa5e" name="a03193e8b8956ec5aff503dd5548cfa5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03193e8b8956ec5aff503dd5548cfa5e">&#9670;&#160;</a></span>begin_turns() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> TSLNetwork::begin_turns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for the turns outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the const node iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> to the first outgoing turn of the node associated with the given <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a>. </dd></dl>

</div>
</div>
<a id="a31c459abcc8b08b33945469d61cea166" name="a31c459abcc8b08b33945469d61cea166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c459abcc8b08b33945469d61cea166">&#9670;&#160;</a></span>begin_turns() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> TSLNetwork::begin_turns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for the turns outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the node iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> to the first outgoing turn of the node associated with the given <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>. </dd></dl>

</div>
</div>
<a id="ad9138550769882f590a0848971853ab0" name="ad9138550769882f590a0848971853ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9138550769882f590a0848971853ab0">&#9670;&#160;</a></span>begin_turns() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> TSLNetwork::begin_turns </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for the turns outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The index of the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> to the first outgoing turn of the node at the given index. </dd></dl>

</div>
</div>
<a id="a9bb54686560a394c0cac53d409dc1744" name="a9bb54686560a394c0cac53d409dc1744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb54686560a394c0cac53d409dc1744">&#9670;&#160;</a></span>begin_turns() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> TSLNetwork::begin_turns </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for the turns outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The index of the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> to the first outgoing turn of the node at the given index. </dd></dl>

</div>
</div>
<a id="aacb245b19c1cc59f2a25753531948663" name="aacb245b19c1cc59f2a25753531948663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb245b19c1cc59f2a25753531948663">&#9670;&#160;</a></span>capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLNetwork::capacity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for nodes in the network.</p>
<p>Returns the storage currently allocated to hold the nodes, a value at least as large as <a class="el" href="#a8502209732a2615d367b4a3846cf465b">size()</a>. </p>

</div>
</div>
<a id="a51a7e1c1aa21f6a46067faa43c2793de" name="a51a7e1c1aa21f6a46067faa43c2793de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a7e1c1aa21f6a46067faa43c2793de">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all the nodes, links and turns. </p>

</div>
</div>
<a id="abb741aa81e57db0e0dbd71c9015f56a1" name="abb741aa81e57db0e0dbd71c9015f56a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb741aa81e57db0e0dbd71c9015f56a1">&#9670;&#160;</a></span>clear_links()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::clear_links </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all links (&amp; therefore any associated turns). </p>

</div>
</div>
<a id="a429e0a07b4d9254773d72eb0783ca3e1" name="a429e0a07b4d9254773d72eb0783ca3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429e0a07b4d9254773d72eb0783ca3e1">&#9670;&#160;</a></span>clear_turns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::clear_turns </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all the turns. </p>

</div>
</div>
<a id="adbd47931c99eb1e86749e19faface979" name="adbd47931c99eb1e86749e19faface979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd47931c99eb1e86749e19faface979">&#9670;&#160;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::destroy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deletes the <a class="el" href="class_t_s_l_network.html">TSLNetwork</a> object (but does not delete contained node &amp; link objects). </p>

</div>
</div>
<a id="af33ced98cb8a6031211570f92f4bc990" name="af33ced98cb8a6031211570f92f4bc990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33ced98cb8a6031211570f92f4bc990">&#9670;&#160;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLNetwork::empty </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for nodes in the network.</p>
<p>Returns true if there are no nodes in the network, false otherwise. </p>

</div>
</div>
<a id="ad45d1d464258b8f613c91d88e21c0f6f" name="ad45d1d464258b8f613c91d88e21c0f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad45d1d464258b8f613c91d88e21c0f6f">&#9670;&#160;</a></span>empty_links()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLNetwork::empty_links </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for links in the network.</p>
<p>Returns true if there are no links in the network, false otherwise. </p>

</div>
</div>
<a id="a9b8ffe190b8ec885523bf93cb01ae439" name="a9b8ffe190b8ec885523bf93cb01ae439"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b8ffe190b8ec885523bf93cb01ae439">&#9670;&#160;</a></span>empty_turns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLNetwork::empty_turns </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for turns in the network.</p>
<p>Returns true if there are no turns in the network, false otherwise. </p>

</div>
</div>
<a id="a53545ab0f2818bc71a5a824533f5f5b6" name="a53545ab0f2818bc71a5a824533f5f5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53545ab0f2818bc71a5a824533f5f5b6">&#9670;&#160;</a></span>end_links() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> TSLNetwork::end_links </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for links in the network.</p>
<p>Returns a <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> to one past the last link. </p>

</div>
</div>
<a id="a8e6ee6f7aee676d251437cc76b93213f" name="a8e6ee6f7aee676d251437cc76b93213f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e6ee6f7aee676d251437cc76b93213f">&#9670;&#160;</a></span>end_links() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> TSLNetwork::end_links </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for links in the network.</p>
<p>Returns a <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> to one past the last link. </p>

</div>
</div>
<a id="a22ce79c3aaa55e120b61dc8105e57458" name="a22ce79c3aaa55e120b61dc8105e57458"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ce79c3aaa55e120b61dc8105e57458">&#9670;&#160;</a></span>end_links() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> TSLNetwork::end_links </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for the links outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the const node iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> to one past the last outgoing link of the node associated with the given <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a>. </dd></dl>

</div>
</div>
<a id="ac791d911bfa7d726c8da4882b10eb4a8" name="ac791d911bfa7d726c8da4882b10eb4a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac791d911bfa7d726c8da4882b10eb4a8">&#9670;&#160;</a></span>end_links() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> TSLNetwork::end_links </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for the links outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the node iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> to one past the last outgoing link of the node associated with the given <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>. </dd></dl>

</div>
</div>
<a id="a0ee3bc08f664e9e289ec564eba012ec9" name="a0ee3bc08f664e9e289ec564eba012ec9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee3bc08f664e9e289ec564eba012ec9">&#9670;&#160;</a></span>end_links() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> TSLNetwork::end_links </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for the links outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The index of the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> to one past the last outgoing link of the node at the given index. </dd></dl>

</div>
</div>
<a id="a16cdf0ff1e823d38734571e94b8f1783" name="a16cdf0ff1e823d38734571e94b8f1783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16cdf0ff1e823d38734571e94b8f1783">&#9670;&#160;</a></span>end_links() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> TSLNetwork::end_links </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for the links outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The index of the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> to one past the last outgoing link of the node at the given index. </dd></dl>

</div>
</div>
<a id="acea315790dcd639005744ad0e6e37b1a" name="acea315790dcd639005744ad0e6e37b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea315790dcd639005744ad0e6e37b1a">&#9670;&#160;</a></span>end_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> TSLNetwork::end_nodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for nodes in the network.</p>
<p>Returns a <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> to one past the last node. </p>

</div>
</div>
<a id="a0132b34c32291c27e76c667f14b8ec95" name="a0132b34c32291c27e76c667f14b8ec95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0132b34c32291c27e76c667f14b8ec95">&#9670;&#160;</a></span>end_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a> TSLNetwork::end_nodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for nodes in the network.</p>
<p>Returns a <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a> to one past the last node. </p>

</div>
</div>
<a id="a09dd8621e32ab8336f2ab7afd5273b59" name="a09dd8621e32ab8336f2ab7afd5273b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09dd8621e32ab8336f2ab7afd5273b59">&#9670;&#160;</a></span>end_turns() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> TSLNetwork::end_turns </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for turns in the network.</p>
<p>Returns a <a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> to one past the last turn. </p>

</div>
</div>
<a id="a8e5d7e1f871530810229dc59690ca18e" name="a8e5d7e1f871530810229dc59690ca18e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5d7e1f871530810229dc59690ca18e">&#9670;&#160;</a></span>end_turns() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> TSLNetwork::end_turns </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for turns in the network.</p>
<p>Returns a <a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> to one past the last turn. </p>

</div>
</div>
<a id="a95fdebf3f6a33f86fd02b741fc9560e5" name="a95fdebf3f6a33f86fd02b741fc9560e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95fdebf3f6a33f86fd02b741fc9560e5">&#9670;&#160;</a></span>end_turns() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> TSLNetwork::end_turns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for the turns outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the const node iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> to one past the last outgoing turn of the node associated with the given <a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a>. </dd></dl>

</div>
</div>
<a id="a5a942507957af5de78da0f1cd6b12ed0" name="a5a942507957af5de78da0f1cd6b12ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a942507957af5de78da0f1cd6b12ed0">&#9670;&#160;</a></span>end_turns() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> TSLNetwork::end_turns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for the turns outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the node iterator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> to one past the last outgoing turn of the node associated with the given <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>. </dd></dl>

</div>
</div>
<a id="a13728a4e47e5d7191589610e4b576383" name="a13728a4e47e5d7191589610e4b576383"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13728a4e47e5d7191589610e4b576383">&#9670;&#160;</a></span>end_turns() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> TSLNetwork::end_turns </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for the turns outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The index of the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> to one past the last outgoing turn of the node at the given index. </dd></dl>

</div>
</div>
<a id="a2a6d29b6be157d1eae887e67268c48bf" name="a2a6d29b6be157d1eae887e67268c48bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6d29b6be157d1eae887e67268c48bf">&#9670;&#160;</a></span>end_turns() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> TSLNetwork::end_turns </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for the turns outgoing from a given node in the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The index of the node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> to one past the last outgoing turn of the node at the given index. </dd></dl>

</div>
</div>
<a id="a8131a028572368b3e07bf0798481b072" name="a8131a028572368b3e07bf0798481b072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8131a028572368b3e07bf0798481b072">&#9670;&#160;</a></span>erase_links() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> TSLNetwork::erase_links </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the links in the range [first, last).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> pointing to the first link to remove. </td></tr>
    <tr><td class="paramname">last</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> pointing to the last link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> that points to first remaining link beyond those that have been removed. </dd></dl>

</div>
</div>
<a id="ad8abe2ad3f184ab7d3782d83914fe19c" name="ad8abe2ad3f184ab7d3782d83914fe19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8abe2ad3f184ab7d3782d83914fe19c">&#9670;&#160;</a></span>erase_links() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> TSLNetwork::erase_links </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the link pointed to by the <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> pointing to the link to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> that points to first remaining link beyond the one that has been removed. </dd></dl>

</div>
</div>
<a id="a616ac09838d67bd1fd3831f4cc081acc" name="a616ac09838d67bd1fd3831f4cc081acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616ac09838d67bd1fd3831f4cc081acc">&#9670;&#160;</a></span>erase_links() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::erase_links </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dest</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all links that have the given node as their destination.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The index of the destination node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad167677314ca5bbd11a59a3fdc244989" name="ad167677314ca5bbd11a59a3fdc244989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad167677314ca5bbd11a59a3fdc244989">&#9670;&#160;</a></span>erase_nodes() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> TSLNetwork::erase_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the nodes in the range [first, last).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> pointing to the first node to remove. </td></tr>
    <tr><td class="paramname">last</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> pointing to the last node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> that points to first remaining node beyond those that have been removed. </dd></dl>

</div>
</div>
<a id="ac2e5a6d813ef47945a9cfd01a8b0cb8c" name="ac2e5a6d813ef47945a9cfd01a8b0cb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2e5a6d813ef47945a9cfd01a8b0cb8c">&#9670;&#160;</a></span>erase_nodes() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> TSLNetwork::erase_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the node pointed to by the <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> pointing to the node to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> that points to first remaining node beyond the one that has been removed. </dd></dl>

</div>
</div>
<a id="acb6258e42def4786e770588b7f8a7ffc" name="acb6258e42def4786e770588b7f8a7ffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6258e42def4786e770588b7f8a7ffc">&#9670;&#160;</a></span>erase_nodes() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> TSLNetwork::erase_nodes </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>first</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>last</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the nodes in the range [first, last).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The index of the first node to remove. </td></tr>
    <tr><td class="paramname">last</td><td>The index of the last node.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> that points to first remaining node beyond those that have been removed. </dd></dl>

</div>
</div>
<a id="a39b29f13c900e53dad4136cb76856193" name="a39b29f13c900e53dad4136cb76856193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39b29f13c900e53dad4136cb76856193">&#9670;&#160;</a></span>erase_nodes() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> TSLNetwork::erase_nodes </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the node at the given index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The index of the node to remove.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> that points to first remaining node beyond the one that has been removed. </dd></dl>

</div>
</div>
<a id="a427f3518e917bd40470fddbdc117ba22" name="a427f3518e917bd40470fddbdc117ba22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427f3518e917bd40470fddbdc117ba22">&#9670;&#160;</a></span>erase_turns() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::erase_turns </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all the turns associated with the given <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> pointing to the link. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52f8f8cd3487382d273abf09e569abe4" name="a52f8f8cd3487382d273abf09e569abe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52f8f8cd3487382d273abf09e569abe4">&#9670;&#160;</a></span>erase_turns() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::erase_turns </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>the_node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove all the turns that are associated with the given node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_node</td><td>The index of the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adcc55c0c594af8c7506a63bb8fb25bc8" name="adcc55c0c594af8c7506a63bb8fb25bc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc55c0c594af8c7506a63bb8fb25bc8">&#9670;&#160;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> * TSLNetwork::find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_nwk_finder.html">TSLNwkFinder</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>filter</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a5c08c798944f061ebaa693bb79a20e57">find_type</a></td>          <td class="paramname"><span class="paramname"><em>filter_mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a5c08c798944f061ebaa693bb79a20e57ac576dbd4b6da22b00b7be697cbd97b0b">tsl_nwk_find_both</a></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a query object which contains the elements satisfying the filter criteria and search mode supplied by the client. Checks the status of the Spatial Index. If the Spatial Index is valid, then if links are being searched for the Spatial Index is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>The region to query. </td></tr>
    <tr><td class="paramname">filter</td><td>A reference finder object. filter_mode: Any of <a class="el" href="#a5c08c798944f061ebaa693bb79a20e57a483a204ef713f34d8c69687710099297" title="search for nodes only">TSLNetwork::tsl_nwk_find_nodes</a> / tsl_nwk_find_links / tsl_nwk_find_both.. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abc42223576826283c848674fd37cba81" name="abc42223576826283c848674fd37cba81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc42223576826283c848674fd37cba81">&#9670;&#160;</a></span>find_link()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> TSLNetwork::find_link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>location</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>aperture</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the nearest link based on location and (square) aperture. Checks the status of the Spatial Index. If the Spatial Index is valid, then the Spatial Index is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The centre point of area to search. </td></tr>
    <tr><td class="paramname">aperture</td><td>The distance from the centre point to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> that refers to the link that was found. </dd></dl>

</div>
</div>
<a id="ae9b269504a8b1ba01ab8b75a014d3426" name="ae9b269504a8b1ba01ab8b75a014d3426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b269504a8b1ba01ab8b75a014d3426">&#9670;&#160;</a></span>find_links()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> * TSLNetwork::find_links </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>location</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>aperture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_nwk_finder.html">TSLNwkFinder</a> *</td>          <td class="paramname"><span class="paramname"><em>filter</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>limit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>useSpatialIndex</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that returns a set (<a class="el" href="class_t_s_l_network_1_1_query.html">Query</a>) of Links within the boundary of the search area, dependent on additional optional filter logic. If the Spatial Index is valid, then it is used for the search and the links within the query object are ordered by distance and the distance is also stored in the query. All links should be within the aperture distance set. Initially, the set should contain all the Links that are within the boundary of the aperture from the location. This can be reduced by the optional filter and limit. If the Limit is supplied then the query object is restricted to return only this number of links or less. The limit is only used if the Spatial Index is valid.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The centre point of area to search. </td></tr>
    <tr><td class="paramname">aperture</td><td>The distance from the centre point to search. </td></tr>
    <tr><td class="paramname">filter</td><td>Optional Filter object. </td></tr>
    <tr><td class="paramname">limit</td><td>Optional limit on the number of links to return. </td></tr>
    <tr><td class="paramname">useSpatialIndex</td><td>If true the spatial index for the loaded network will be used if it is valid. If no spatial index is available then the standard search method will be used. Defaults to true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab77092e1c5fdbc5564b8c6eaf965dcc4" name="ab77092e1c5fdbc5564b8c6eaf965dcc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77092e1c5fdbc5564b8c6eaf965dcc4">&#9670;&#160;</a></span>find_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__node__iterator.html">const_node_iterator</a> TSLNetwork::find_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>location</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>aperture</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the nearest node based on location and (square) aperture.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">location</td><td>The centre point of area to search. </td></tr>
    <tr><td class="paramname">aperture</td><td>The distance from the centre point to search.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> that refers to the link that was found. </dd></dl>

</div>
</div>
<a id="a3a93582e6f2eea204b121c9d6c11a46c" name="a3a93582e6f2eea204b121c9d6c11a46c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a93582e6f2eea204b121c9d6c11a46c">&#9670;&#160;</a></span>get_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp; TSLNetwork::get_node </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method for nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The index position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the node at the specified position. </dd></dl>

</div>
</div>
<a id="aa528eae4cd93355c44a2d88586683809" name="aa528eae4cd93355c44a2d88586683809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa528eae4cd93355c44a2d88586683809">&#9670;&#160;</a></span>get_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp; TSLNetwork::get_node </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access method (const) for nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The index position.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the (const) node at the specified position. </dd></dl>

</div>
</div>
<a id="adef5c0f745b442298a878f0466a10a1f" name="adef5c0f745b442298a878f0466a10a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adef5c0f745b442298a878f0466a10a1f">&#9670;&#160;</a></span>insert_link() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> TSLNetwork::insert_link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>link_it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dest_it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_link.html">TSLLink</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>the_link</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_t_s_l_link.html">TSLLink</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a link between two nodes in the network, given the source node's link _iterator and the <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> object for the destination node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link_it</td><td>A reference to the source <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>. </td></tr>
    <tr><td class="paramname">dest_it</td><td>A reference to the destination <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>. </td></tr>
    <tr><td class="paramname">the_link</td><td>A reference to the link to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> that points to the newly inserted link. </dd></dl>

</div>
</div>
<a id="ad547c1e9b747c81fc26888cf4847b272" name="ad547c1e9b747c81fc26888cf4847b272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad547c1e9b747c81fc26888cf4847b272">&#9670;&#160;</a></span>insert_link() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> TSLNetwork::insert_link </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src_it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dest_it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_link.html">TSLLink</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>the_link</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_t_s_l_link.html">TSLLink</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a link between two nodes in the network, given the <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> objects for the source and destination nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_it</td><td>A reference to the source <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>. </td></tr>
    <tr><td class="paramname">dest_it</td><td>A reference to the destination <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>. </td></tr>
    <tr><td class="paramname">the_link</td><td>A reference to the link to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> that points to the newly inserted link.</dd></dl>
<p>Insert a link between two nodes given the iterators to both nodes. </p>

</div>
</div>
<a id="ab1205e3cfdd9975dbd4a195cf51252e0" name="ab1205e3cfdd9975dbd4a195cf51252e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1205e3cfdd9975dbd4a195cf51252e0">&#9670;&#160;</a></span>insert_link() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> TSLNetwork::insert_link </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_link.html">TSLLink</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>the_link</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_t_s_l_link.html">TSLLink</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a link between two nodes in the network, given the index position of the source and destination nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source node index. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination node index. </td></tr>
    <tr><td class="paramname">the_link</td><td>A reference to the link to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> that points to the newly inserted link. </dd></dl>

</div>
</div>
<a id="a7e922dc4b7fce6a17bd9cf7873ad01c8" name="a7e922dc4b7fce6a17bd9cf7873ad01c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e922dc4b7fce6a17bd9cf7873ad01c8">&#9670;&#160;</a></span>insert_link_between()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> TSLNetwork::insert_link_between </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_link.html">TSLLink</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>the_link</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_t_s_l_link.html">TSLLink</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a link between two nodes in the network, given the index position of the source and destination nodes.</p>
<p>The destination node need not exist.</p>
<p>This method is provided to aid in constructing tiled networks.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source node index. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination node index. </td></tr>
    <tr><td class="paramname">the_link</td><td>A reference to the link to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> that points to the newly inserted link. </dd></dl>

</div>
</div>
<a id="aca515404e42d30d67aafb34377b017d0" name="aca515404e42d30d67aafb34377b017d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca515404e42d30d67aafb34377b017d0">&#9670;&#160;</a></span>insert_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> TSLNetwork::insert_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>the_node</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_t_s_l_node.html">TSLNode</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a node into the network, before the node pointed to by the given node _iterator.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the node iterator. </td></tr>
    <tr><td class="paramname">the_node</td><td>A reference to the node to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> that points to the newly inserted node. </dd></dl>

</div>
</div>
<a id="a7aa9cbe7eb9c532799d03a4b08813ae6" name="a7aa9cbe7eb9c532799d03a4b08813ae6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa9cbe7eb9c532799d03a4b08813ae6">&#9670;&#160;</a></span>insert_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::insert_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>the_node</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_t_s_l_node.html">TSLNode</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a repetition of N nodes of value the_node into the network, before the node pointed to by the given <a class="el" href="class_t_s_l_network_1_1node__iterator.html">node_iterator</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the node iterator. </td></tr>
    <tr><td class="paramname">N</td><td>The number of nodes required. </td></tr>
    <tr><td class="paramname">the_node</td><td>A reference to the node to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2077795f97987812c499769798733f04" name="a2077795f97987812c499769798733f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2077795f97987812c499769798733f04">&#9670;&#160;</a></span>insert_turn() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> TSLNetwork::insert_turn </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src_it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dest_it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__networksdk__network.html#ga0f95f705951d51122e4e334f83b61dcd">TSLTurn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>the_turn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__group__networksdk__network.html#ga0f95f705951d51122e4e334f83b61dcd">TSLTurn</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a turn (inter-link relationship) between two links in the network, given the <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a> objects of the source and destination links.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_it</td><td>A reference to the source <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>. </td></tr>
    <tr><td class="paramname">dest_it</td><td>A reference to the destination <a class="el" href="class_t_s_l_network_1_1link__iterator.html">link_iterator</a>. </td></tr>
    <tr><td class="paramname">the_turn</td><td>A reference to the turn to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> that points to the newly inserted turn. </dd></dl>

</div>
</div>
<a id="a1421a364740a025947a34d23571e7971" name="a1421a364740a025947a34d23571e7971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1421a364740a025947a34d23571e7971">&#9670;&#160;</a></span>insert_turn() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> TSLNetwork::insert_turn </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>dest</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>via</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__group__networksdk__network.html#ga0f95f705951d51122e4e334f83b61dcd">TSLTurn</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>the_turn</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__group__networksdk__network.html#ga0f95f705951d51122e4e334f83b61dcd">TSLTurn</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a turn (inter-link relationship) between two links in the network, given the source, destination &amp; via node index positions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source node index. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination node index. </td></tr>
    <tr><td class="paramname">via</td><td>The via node index. </td></tr>
    <tr><td class="paramname">the_turn</td><td>A reference to the turn to insert.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_network_1_1turn__iterator.html">turn_iterator</a> that points to the newly inserted turn.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Clients must be absolutely certain that the given indices describe unique links. </dd></dl>

</div>
</div>
<a id="a15c60a4944583d8336a3dfbbf32a70b9" name="a15c60a4944583d8336a3dfbbf32a70b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c60a4944583d8336a3dfbbf32a70b9">&#9670;&#160;</a></span>invalidateSpatialIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::invalidateSpatialIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that invalidates the Spatial Index. An example of when to use this function would be when a Link has had its geometry changed. </p>

</div>
</div>
<a id="a1f994a4c8d71074aceb127b3e6a8949e" name="a1f994a4c8d71074aceb127b3e6a8949e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f994a4c8d71074aceb127b3e6a8949e">&#9670;&#160;</a></span>isEdgeNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLNetwork::isEdgeNode </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the node is an edge node, false otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index position of the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0d1f42ce4d2aa98ca10bdfaeaf51a828" name="a0d1f42ce4d2aa98ca10bdfaeaf51a828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1f42ce4d2aa98ca10bdfaeaf51a828">&#9670;&#160;</a></span>isStitchNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLNetwork::isStitchNode </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the node is a stitch node, false otherwise.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>the index position of the node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd0ac3e4b397edc8da6c7c7a34149e66" name="abd0ac3e4b397edc8da6c7c7a34149e66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0ac3e4b397edc8da6c7c7a34149e66">&#9670;&#160;</a></span>linkDestinNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp; TSLNetwork::linkDestinNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for links.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> pointing to the link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the link's destination Node object. </dd></dl>

</div>
</div>
<a id="a7d76f4367c09f64c148bb5bb9282cdf3" name="a7d76f4367c09f64c148bb5bb9282cdf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d76f4367c09f64c148bb5bb9282cdf3">&#9670;&#160;</a></span>linkDestinNodePos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLNetwork::linkDestinNodePos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for links.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> pointing to the link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the link's destination node. </dd></dl>

</div>
</div>
<a id="aa63135066d841881f79566ceba8016a1" name="aa63135066d841881f79566ceba8016a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63135066d841881f79566ceba8016a1">&#9670;&#160;</a></span>linkNodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLNetwork::linkNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for links. Returns the link's source &amp; destination Node objects, via the supplied arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> pointing to the link. </td></tr>
    <tr><td class="paramname">src</td><td>A reference to the link's source Node object. </td></tr>
    <tr><td class="paramname">dst</td><td>A reference to the link's destination Node object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if link exists, false otherwise. </dd></dl>

</div>
</div>
<a id="aa315047a145cf596b810920dd0cd240a" name="aa315047a145cf596b810920dd0cd240a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa315047a145cf596b810920dd0cd240a">&#9670;&#160;</a></span>linkNodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLNetwork::linkNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_link.html">TSLLink</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>link</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>dst</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for links. Returns the link's source &amp; destination Node objects, via the supplied arguments.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">link</td><td>A reference to the Link object. </td></tr>
    <tr><td class="paramname">src</td><td>A reference to the link's source Node object. </td></tr>
    <tr><td class="paramname">dst</td><td>A reference to the link's destination Node object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if link exists, false otherwise. </dd></dl>

</div>
</div>
<a id="aa046f0043ff6ccaba240b58076abe6e4" name="aa046f0043ff6ccaba240b58076abe6e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa046f0043ff6ccaba240b58076abe6e4">&#9670;&#160;</a></span>links()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1_streamer.html">Streamer</a> TSLNetwork::links </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method extracts the network links for subsequent streaming. </p>

</div>
</div>
<a id="ab66b5a574370b825f69f28dc69ec09f3" name="ab66b5a574370b825f69f28dc69ec09f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab66b5a574370b825f69f28dc69ec09f3">&#9670;&#160;</a></span>linkSourceNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp; TSLNetwork::linkSourceNode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for links.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> pointing to the link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a reference to the link's source Node object. </dd></dl>

</div>
</div>
<a id="a25e807adddce7871d099d61a0dc8352c" name="a25e807adddce7871d099d61a0dc8352c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25e807adddce7871d099d61a0dc8352c">&#9670;&#160;</a></span>linkSourceNodePos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLNetwork::linkSourceNodePos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for links.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> pointing to the link.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the index of the link's source node. </dd></dl>

</div>
</div>
<a id="a2f0713184b271a811df142cba85c5b0a" name="a2f0713184b271a811df142cba85c5b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0713184b271a811df142cba85c5b0a">&#9670;&#160;</a></span>loadSpatialIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLNetwork::loadSpatialIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_lifstream.html">TSLifstream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inputStream</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that reads and creates the Spatial Index from a file stream. If the Spatial Index already exists, it is deleted. Returns true on success or false on error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">inputStream</td><td>Reference to stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4ffc346df3ad720b5d913b8fc448a768" name="a4ffc346df3ad720b5d913b8fc448a768"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ffc346df3ad720b5d913b8fc448a768">&#9670;&#160;</a></span>markEdgeNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::markEdgeNode </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the node at the supplied position is an edge node i.e. it originated from the edge of a dataset.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The node index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a890c08be0635545865a473a127f95b89" name="a890c08be0635545865a473a127f95b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890c08be0635545865a473a127f95b89">&#9670;&#160;</a></span>markStitchNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::markStitchNode </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the node at the supplied position is a stitch node i.e. its purpose in the original data is to break links across datasets.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The node index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adaa2ce0a9fa1b20e067248e62128a01a" name="adaa2ce0a9fa1b20e067248e62128a01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa2ce0a9fa1b20e067248e62128a01a">&#9670;&#160;</a></span>mendEdgeNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::mendEdgeNodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_network.html">TSLNetwork</a> *</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_node_cmp.html">TSLNodeCmp</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>nodePred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method tags nodes in other network as stitch nodes where appropriate. </p>

</div>
</div>
<a id="a2000a695abe56c6be95876689ea6ccc5" name="a2000a695abe56c6be95876689ea6ccc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2000a695abe56c6be95876689ea6ccc5">&#9670;&#160;</a></span>mergeEdgeNodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::mergeEdgeNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_node_cmp.html">TSLNodeCmp</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>nodePred</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_link_cmp.html">TSLLinkCmp</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>linkPred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For every link crossing a tile boundary, its segments are replaced by a single link and the corresponding edge nodes are removed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nodePred</td><td>A reference to the <a class="el" href="class_t_s_l_node_cmp.html">TSLNodeCmp</a> object. </td></tr>
    <tr><td class="paramname">linkPred</td><td>A reference to the <a class="el" href="class_t_s_l_link_cmp.html">TSLLinkCmp</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af310255c014370cd123d227262c8a648" name="af310255c014370cd123d227262c8a648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af310255c014370cd123d227262c8a648">&#9670;&#160;</a></span>mergeNetwork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::mergeNetwork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_network.html">TSLNetwork</a> *</td>          <td class="paramname"><span class="paramname"><em>other</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_node_cmp.html">TSLNodeCmp</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>nodePred</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merges the supplied network into the current one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td>The network to merge into this one. </td></tr>
    <tr><td class="paramname">nodePred</td><td>A reference to the <a class="el" href="class_t_s_l_node_cmp.html">TSLNodeCmp</a> object. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5d03a7fac49b5599b14eef4cb4f81420" name="a5d03a7fac49b5599b14eef4cb4f81420"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d03a7fac49b5599b14eef4cb4f81420">&#9670;&#160;</a></span>net__()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1_streamer.html">Streamer</a> TSLNetwork::net__ </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method extracts the network internals for subsequent streaming. </p>

</div>
</div>
<a id="a5301dcd66b13e7bc8e1709c56b4dbc51" name="a5301dcd66b13e7bc8e1709c56b4dbc51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5301dcd66b13e7bc8e1709c56b4dbc51">&#9670;&#160;</a></span>nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1_streamer.html">Streamer</a> TSLNetwork::nodes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method extracts the network nodes for subsequent streaming. </p>

</div>
</div>
<a id="a546834f888da5d6ca62bf6eeec26c9ff" name="a546834f888da5d6ca62bf6eeec26c9ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546834f888da5d6ca62bf6eeec26c9ff">&#9670;&#160;</a></span>operator new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLNetwork::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are here to avoid being documented Allocation override for API redirection. </p>

</div>
</div>
<a id="a9682a11d1063303fea693412568d7699" name="a9682a11d1063303fea693412568d7699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9682a11d1063303fea693412568d7699">&#9670;&#160;</a></span>operator new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLNetwork::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When included in an MFC application in debug mode, the debug new expects this to be here. Override it and return the same as the normal one. The library must include it when compiled in release mode, since the user's application may be in debug mode. </p>

</div>
</div>
<a id="af323c5654c1faeac89fdc63e9c0bf858" name="af323c5654c1faeac89fdc63e9c0bf858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af323c5654c1faeac89fdc63e9c0bf858">&#9670;&#160;</a></span>pop_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::pop_back </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the last node in the network - clients must ensure that at least some nodes have been added to the network prior to calling this method. </p>

</div>
</div>
<a id="ab41dd38ee4c8f0ad9416a3c99f1c8dde" name="ab41dd38ee4c8f0ad9416a3c99f1c8dde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41dd38ee4c8f0ad9416a3c99f1c8dde">&#9670;&#160;</a></span>push_back()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_node.html">TSLNode</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>the_node</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts a node into the end of the network.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">the_node</td><td>A reference to the node to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d4a20083b1d37063571cba5e2bf8abe" name="a3d4a20083b1d37063571cba5e2bf8abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4a20083b1d37063571cba5e2bf8abe">&#9670;&#160;</a></span>removeEdgeNode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::removeEdgeNode </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that the node at the supplied position is no longer an edge node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The node index. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6ded0e3b7c05c8a764d42348382f770c" name="a6ded0e3b7c05c8a764d42348382f770c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ded0e3b7c05c8a764d42348382f770c">&#9670;&#160;</a></span>reserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::reserve </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The member function ensures that <a class="el" href="#aacb245b19c1cc59f2a25753531948663">capacity()</a> henceforth returns at least N.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>The number of nodes to reserve space for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a22b0c625fe968fc9eccb349baf0a6313" name="a22b0c625fe968fc9eccb349baf0a6313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b0c625fe968fc9eccb349baf0a6313">&#9670;&#160;</a></span>resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLNetwork::resize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_node.html">TSLNode</a></td>          <td class="paramname"><span class="paramname"><em>the_node</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_t_s_l_node.html">TSLNode</a>()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensures that <a class="el" href="#a8502209732a2615d367b4a3846cf465b">size()</a> henceforth returns N. If it must lengthen the storage for nodes, it appends nodes with value the_node.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>The required number of nodes. </td></tr>
    <tr><td class="paramname">the_node</td><td>The node to insert. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7270cac5a1300a198f583feb0eec1dcf" name="a7270cac5a1300a198f583feb0eec1dcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7270cac5a1300a198f583feb0eec1dcf">&#9670;&#160;</a></span>saveSpatialIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLNetwork::saveSpatialIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_lofstream.html">TSLofstream</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>outputStream</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that saves the Spatial Index to a file stream. Returns true on success, or false on error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">outputStream</td><td>Reference to stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8502209732a2615d367b4a3846cf465b" name="a8502209732a2615d367b4a3846cf465b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8502209732a2615d367b4a3846cf465b">&#9670;&#160;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLNetwork::size </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for nodes in the network.</p>
<p>Returns the number of nodes in the network. </p>

</div>
</div>
<a id="af1dd33d8a4ffa19c45296a91e094ff0e" name="af1dd33d8a4ffa19c45296a91e094ff0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dd33d8a4ffa19c45296a91e094ff0e">&#9670;&#160;</a></span>size_links()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLNetwork::size_links </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for links in the network.</p>
<p>Returns the number of links in the network. </p>

</div>
</div>
<a id="af32280bfde16e5c2770fc510d920473b" name="af32280bfde16e5c2770fc510d920473b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af32280bfde16e5c2770fc510d920473b">&#9670;&#160;</a></span>size_turns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLNetwork::size_turns </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for turns in the network.</p>
<p>Returns the number of turns in the network. </p>

</div>
</div>
<a id="a29c8c26d1a86a6e17161be4f659c0d72" name="a29c8c26d1a86a6e17161be4f659c0d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c8c26d1a86a6e17161be4f659c0d72">&#9670;&#160;</a></span>spatialIndexUpToDate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLNetwork::spatialIndexUpToDate </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the status of the Spatial Index.</p>
<p>Returns true if the spatial index is valid and can be used, false otherwise. </p>

</div>
</div>
<a id="a97c4e110def9b484e665f85c7afc6226" name="a97c4e110def9b484e665f85c7afc6226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c4e110def9b484e665f85c7afc6226">&#9670;&#160;</a></span>turnDestinLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> TSLNetwork::turnDestinLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for turns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> pointing to the turn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> pointing to the turn's destination link. </dd></dl>

</div>
</div>
<a id="aeef3567c42f01b64c0c18cddb169557e" name="aeef3567c42f01b64c0c18cddb169557e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef3567c42f01b64c0c18cddb169557e">&#9670;&#160;</a></span>turns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1_streamer.html">Streamer</a> TSLNetwork::turns </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method extracts the network turns for subsequent streaming. </p>

</div>
</div>
<a id="a09c6d9b288e8661b90e1872ee4ab3909" name="a09c6d9b288e8661b90e1872ee4ab3909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c6d9b288e8661b90e1872ee4ab3909">&#9670;&#160;</a></span>turnSourceLink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> TSLNetwork::turnSourceLink </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>it</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="class_t_s_l_network_1_1_query.html">Query</a> method for turns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>A reference to the <a class="el" href="class_t_s_l_network_1_1const__turn__iterator.html">const_turn_iterator</a> pointing to the turn.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the <a class="el" href="class_t_s_l_network_1_1const__link__iterator.html">const_link_iterator</a> pointing to the turn's source link. </dd></dl>

</div>
</div>
<a id="acebb940dd29a5548678da11ff349e681" name="acebb940dd29a5548678da11ff349e681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acebb940dd29a5548678da11ff349e681">&#9670;&#160;</a></span>updateSpatialIndex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLNetwork::updateSpatialIndex </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that updates the Networks Spatial Index. If the Spatial Index exists, it is deleted and rebuilt. If the Spatial Index doesn't exist it is constructed.</p>
<p>Returns true if the Spatial Index was created successfully. Returns false if an error was encountered. The <a class="el" href="class_t_s_l_error_stack.html">TSLErrorStack</a> should be interrogated for further information. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_network.html">TSLNetwork</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.2 | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
