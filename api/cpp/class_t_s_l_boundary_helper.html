<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLBoundaryHelper Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.1</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_boundary_helper.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_t_s_l_boundary_helper-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLBoundaryHelper Class Reference<div class="ingroups"><a class="el" href="group__group__spatialeditorsdk.html">MapLink Spatial Editor API</a> &raquo; <a class="el" href="group__group__landlinkapi.html">LandLink API</a> &raquo; <a class="el" href="group__group__landlinkapi__helpers.html">Helpers</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides low-level access to the underlying bound, lasso and auto-title functionality.</p>
<p>Before using this class, you should set up the (static) snap-tolerance in the <a class="el" href="class_t_s_l_boundary_vertex.html">TSLBoundaryVertex</a> class. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa99f7a79906f316da3c63386e9f8f38f" id="r_aa99f7a79906f316da3c63386e9f8f38f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa99f7a79906f316da3c63386e9f8f38f">TSLBoundaryHelper</a> (TSLFeatureID *buildingFeatureCodes=0, int numBuildingFeatureCodes=0, TSLFeatureID *extensionFeatureCodes=0, int numExtensionFeatureCodes=0)</td></tr>
<tr class="separator:aa99f7a79906f316da3c63386e9f8f38f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f777466bb6434b8a8fb94e35c09ef34" id="r_a8f777466bb6434b8a8fb94e35c09ef34"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f777466bb6434b8a8fb94e35c09ef34">TSLBoundaryHelper</a> (<a class="el" href="class_t_s_l_boundary_helper.html">TSLBoundaryHelper</a> &amp;src, <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent, bool includeMarked, bool extensionOnly)</td></tr>
<tr class="separator:a8f777466bb6434b8a8fb94e35c09ef34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36438901001616e7ae6e00468787f623" id="r_a36438901001616e7ae6e00468787f623"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36438901001616e7ae6e00468787f623">TSLBoundaryHelper</a> (<a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *surface)</td></tr>
<tr class="separator:a36438901001616e7ae6e00468787f623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23772dc8910a3405f5be3e3fed1b2a61" id="r_a23772dc8910a3405f5be3e3fed1b2a61"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23772dc8910a3405f5be3e3fed1b2a61">~TSLBoundaryHelper</a> ()</td></tr>
<tr class="separator:a23772dc8910a3405f5be3e3fed1b2a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6379ffc714a34003cf359edf592f8ae4" id="r_a6379ffc714a34003cf359edf592f8ae4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6379ffc714a34003cf359edf592f8ae4">addEdge</a> (TSLTMC end1_x, TSLTMC end1_y, TSLTMC end2_x, TSLTMC end2_y)</td></tr>
<tr class="separator:a6379ffc714a34003cf359edf592f8ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad343b0044b99748d8d6b4c52efc1c123" id="r_ad343b0044b99748d8d6b4c52efc1c123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad343b0044b99748d8d6b4c52efc1c123">clear</a> ()</td></tr>
<tr class="separator:ad343b0044b99748d8d6b4c52efc1c123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3612236dd77346191d3f70a752ad1951" id="r_a3612236dd77346191d3f70a752ad1951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3612236dd77346191d3f70a752ad1951">decompose</a> (const <a class="el" href="class_t_s_l_entity_set.html">TSLEntitySet</a> *entity, bool(*valid)(const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *entity)=0, const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *clipEntity=0)</td></tr>
<tr class="separator:a3612236dd77346191d3f70a752ad1951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1ba58f8d4c84e70487e026fe0ee7fe" id="r_a5c1ba58f8d4c84e70487e026fe0ee7fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c1ba58f8d4c84e70487e026fe0ee7fe">decompose</a> (const <a class="el" href="class_t_s_l_polyline.html">TSLPolyline</a> *entity, const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *clipEntity=0, bool mark=false, bool clearMarkIfExists=false)</td></tr>
<tr class="separator:a5c1ba58f8d4c84e70487e026fe0ee7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47693b90b4a26f18870a9bf34b256886" id="r_a47693b90b4a26f18870a9bf34b256886"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47693b90b4a26f18870a9bf34b256886">decompose</a> (const <a class="el" href="class_t_s_l_polygon.html">TSLPolygon</a> *entity, const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *clipEntity=0, bool mark=false, bool clearMarkIfExists=false)</td></tr>
<tr class="separator:a47693b90b4a26f18870a9bf34b256886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e15885daa8a744758a1dec2179d8f5" id="r_aa9e15885daa8a744758a1dec2179d8f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_coord_set.html">TSLCoordSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9e15885daa8a744758a1dec2179d8f5">dynamicBound</a> (const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> *coord, const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> *boundary=0)</td></tr>
<tr class="separator:aa9e15885daa8a744758a1dec2179d8f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c05dc0c09f634dc15bc67d1c62feb71" id="r_a5c05dc0c09f634dc15bc67d1c62feb71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c05dc0c09f634dc15bc67d1c62feb71">extendMarkedCorners</a> (double minCornerAngleChange, TSLTMC maxExtensionLength)</td></tr>
<tr class="separator:a5c05dc0c09f634dc15bc67d1c62feb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a81b82abc0175ad6c9e9d4b844a2e4" id="r_a66a81b82abc0175ad6c9e9d4b844a2e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a66a81b82abc0175ad6c9e9d4b844a2e4">extendOrphans</a> (double angleTolerance, double scaleFactor)</td></tr>
<tr class="separator:a66a81b82abc0175ad6c9e9d4b844a2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d0a8a89094c2a342030ae1ccfcfd40" id="r_a47d0a8a89094c2a342030ae1ccfcfd40"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_boundary_edge_list.html">TSLBoundaryEdgeList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a47d0a8a89094c2a342030ae1ccfcfd40">getEdges</a> () const</td></tr>
<tr class="separator:a47d0a8a89094c2a342030ae1ccfcfd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999e8eb9e44f0008b1df1f8f18c14af8" id="r_a999e8eb9e44f0008b1df1f8f18c14af8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_boundary_edge_list.html">TSLBoundaryEdgeList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a999e8eb9e44f0008b1df1f8f18c14af8">getEdgesWithVerticesNear</a> (const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;point, TSLTMC tolerance) const</td></tr>
<tr class="separator:a999e8eb9e44f0008b1df1f8f18c14af8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e31438cdba98ec05cabd0016b7338b" id="r_ad2e31438cdba98ec05cabd0016b7338b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_boundary_vertex.html">TSLBoundaryVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2e31438cdba98ec05cabd0016b7338b">getNearestPoint</a> (const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;pt, TSLTMC maxTMCDistance)</td></tr>
<tr class="separator:ad2e31438cdba98ec05cabd0016b7338b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61b812429bf9432df2f0621fb7d063be" id="r_a61b812429bf9432df2f0621fb7d063be"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_boundary_vertex.html">TSLBoundaryVertex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61b812429bf9432df2f0621fb7d063be">getNearestVertex</a> (const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;pt, bool existingOnly, TSLTMC maxTMCDistance)</td></tr>
<tr class="separator:a61b812429bf9432df2f0621fb7d063be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d9965807c6ab74e9045605b2b89ad0" id="r_a50d9965807c6ab74e9045605b2b89ad0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50d9965807c6ab74e9045605b2b89ad0">insertGapFillets</a> (TSLTMC maximumDistance)</td></tr>
<tr class="separator:a50d9965807c6ab74e9045605b2b89ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc743f6a9ad239201fa4029023ef61a" id="r_aedc743f6a9ad239201fa4029023ef61a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_coord_set.html">TSLCoordSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedc743f6a9ad239201fa4029023ef61a">largestContained</a> (<a class="el" href="class_t_s_l_boundary_edge_list.html">TSLBoundaryEdgeList</a> **constituentEdges)</td></tr>
<tr class="separator:aedc743f6a9ad239201fa4029023ef61a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d599b249f187bf6d3e86f147d069c24" id="r_a5d599b249f187bf6d3e86f147d069c24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5d599b249f187bf6d3e86f147d069c24">removeOrphans</a> (double angleTolerance=360.0, TSLTMC maximumLength=0)</td></tr>
<tr class="separator:a5d599b249f187bf6d3e86f147d069c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a840f0999a0e596076ba5693f764993cf" id="r_a840f0999a0e596076ba5693f764993cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a840f0999a0e596076ba5693f764993cf">removeMarkedEdges</a> ()</td></tr>
<tr class="separator:a840f0999a0e596076ba5693f764993cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a510fff5df3468de0e751c2b2e826e1d9" id="r_a510fff5df3468de0e751c2b2e826e1d9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_coord_set.html">TSLCoordSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a510fff5df3468de0e751c2b2e826e1d9">seeds</a> () const</td></tr>
<tr class="separator:a510fff5df3468de0e751c2b2e826e1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791efa4c423ba909009300966a425a65" id="r_a791efa4c423ba909009300966a425a65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_coord_set.html">TSLCoordSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a791efa4c423ba909009300966a425a65">smallestEnclosure</a> (const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;coord, <a class="el" href="class_t_s_l_boundary_edge_list.html">TSLBoundaryEdgeList</a> **constituentEdges)</td></tr>
<tr class="separator:a791efa4c423ba909009300966a425a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a480717e4dab5a4b23d9cc6cb56552a56" id="r_a480717e4dab5a4b23d9cc6cb56552a56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a480717e4dab5a4b23d9cc6cb56552a56">splitEdges</a> ()</td></tr>
<tr class="separator:a480717e4dab5a4b23d9cc6cb56552a56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac034c5e4d29c6ceed815692eb3f3d4f0" id="r_ac034c5e4d29c6ceed815692eb3f3d4f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac034c5e4d29c6ceed815692eb3f3d4f0">unmarkContinuationEdges</a> (Double angleTolerance)</td></tr>
<tr class="separator:ac034c5e4d29c6ceed815692eb3f3d4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ca02c7c21f2b51c698099fc898bd7ec" id="r_a5ca02c7c21f2b51c698099fc898bd7ec"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ca02c7c21f2b51c698099fc898bd7ec">getHandle</a> () const</td></tr>
<tr class="separator:a5ca02c7c21f2b51c698099fc898bd7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aa99f7a79906f316da3c63386e9f8f38f" name="aa99f7a79906f316da3c63386e9f8f38f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa99f7a79906f316da3c63386e9f8f38f">&#9670;&#160;</a></span>TSLBoundaryHelper() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLBoundaryHelper::TSLBoundaryHelper </td>
          <td>(</td>
          <td class="paramtype">TSLFeatureID *</td>          <td class="paramname"><span class="paramname"><em>buildingFeatureCodes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numBuildingFeatureCodes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID *</td>          <td class="paramname"><span class="paramname"><em>extensionFeatureCodes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>numExtensionFeatureCodes</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is the basic constructor for <a class="el" href="class_t_s_l_boundary_helper.html">TSLBoundaryHelper</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">buildingFeatureCodes</td><td>Feature codes to identify building outlines and seed points.</td></tr>
    <tr><td class="paramname">numBuildingFeatureCodes</td><td>Number of feature codes specified in 'building FeatureCodes'.</td></tr>
    <tr><td class="paramname">extensionFeatureCodes</td><td>Feature codes for features used during 'extendMarked Corners'.</td></tr>
    <tr><td class="paramname">numExtensionFeatureCodes</td><td>Number of feature codes specified in 'extension FeatureCodes'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f777466bb6434b8a8fb94e35c09ef34" name="a8f777466bb6434b8a8fb94e35c09ef34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f777466bb6434b8a8fb94e35c09ef34">&#9670;&#160;</a></span>TSLBoundaryHelper() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLBoundaryHelper::TSLBoundaryHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_boundary_helper.html">TSLBoundaryHelper</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>src</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>includeMarked</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>extensionOnly</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a copy constructor for the <a class="el" href="class_t_s_l_boundary_helper.html">TSLBoundaryHelper</a> class.</p>
<p>This takes an existing <a class="el" href="class_t_s_l_boundary_helper.html">TSLBoundaryHelper</a> and copies across all edges that intersect the specified extent. Optionally, marked edges can be ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source <a class="el" href="class_t_s_l_boundary_helper.html">TSLBoundaryHelper</a> to copy from</td></tr>
    <tr><td class="paramname">extent</td><td>Extent of edges to copy. Note that all edges that intersect the extent will be copied without being clipped.</td></tr>
    <tr><td class="paramname">includeMarked</td><td>This flag indicates whether marked edges should be copied as well.</td></tr>
    <tr><td class="paramname">extensionOnly</td><td>This flag indicates whether only extension features shuld be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a36438901001616e7ae6e00468787f623" name="a36438901001616e7ae6e00468787f623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36438901001616e7ae6e00468787f623">&#9670;&#160;</a></span>TSLBoundaryHelper() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLBoundaryHelper::TSLBoundaryHelper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *</td>          <td class="paramname"><span class="paramname"><em>surface</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a23772dc8910a3405f5be3e3fed1b2a61" name="a23772dc8910a3405f5be3e3fed1b2a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23772dc8910a3405f5be3e3fed1b2a61">&#9670;&#160;</a></span>~TSLBoundaryHelper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLBoundaryHelper::~TSLBoundaryHelper </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor for boundary helper </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6379ffc714a34003cf359edf592f8ae4" name="a6379ffc714a34003cf359edf592f8ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6379ffc714a34003cf359edf592f8ae4">&#9670;&#160;</a></span>addEdge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLBoundaryHelper::addEdge </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>end1_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>end1_y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>end2_x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>end2_y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an edge line to the map data.</p>
<p>When all required edges have been added, call splitEdges to make sure vertices are created where edges cross.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">end1_x,end1_y</td><td>coordinates of one end of the edge </td></tr>
    <tr><td class="paramname">end2_x,end2_y</td><td>coordinates of the other end of the edge </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad343b0044b99748d8d6b4c52efc1c123" name="ad343b0044b99748d8d6b4c52efc1c123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad343b0044b99748d8d6b4c52efc1c123">&#9670;&#160;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLBoundaryHelper::clear </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This clears the all vertex and edge lists held within the boundary helper. </p>

</div>
</div>
<a id="a3612236dd77346191d3f70a752ad1951" name="a3612236dd77346191d3f70a752ad1951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3612236dd77346191d3f70a752ad1951">&#9670;&#160;</a></span>decompose() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLBoundaryHelper::decompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity_set.html">TSLEntitySet</a> *</td>          <td class="paramname"><span class="paramname"><em>entity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool(*</td>          <td class="paramname"><span class="paramname"><em>valid&#160;</em></span>)(const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *entity)<span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>clipEntity</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method decomposes the specified entity into its component edges. For entities that contain other entities, this function recursively calls itself.</p>
<p>The (optional) validate function is called for all entities. If the validate function returns true, then that entity's edges are added. If no validate function is specified, then all entities edges are added</p>
<p>An optional clipping entity may be specified. The edges will be clipped to the boundary of this entity prior to addition.</p>
<p>Arguments list details :</p>
<p>entity : A pointer to the entity to be decomposed.</p>
<p>valid : Optional pointer to the validate function.</p>
<p>clipEntity : A pointer to the optional clip region. </p>

</div>
</div>
<a id="a47693b90b4a26f18870a9bf34b256886" name="a47693b90b4a26f18870a9bf34b256886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47693b90b4a26f18870a9bf34b256886">&#9670;&#160;</a></span>decompose() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLBoundaryHelper::decompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_polygon.html">TSLPolygon</a> *</td>          <td class="paramname"><span class="paramname"><em>entity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>clipEntity</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>mark</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clearMarkIfExists</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method decomposes the specified polygon into its component edges.</p>
<p>An optional clipping entity may be specified. The edges will be clipped to the boundary of this entity prior to addition.</p>
<p>Arguments list details :</p>
<p>entity : A pointer to the entity to be decomposed.</p>
<p>clipEntity: Optional pointer to the clip boundary</p>
<p>mark : Flag to indicate whether the edges of the polygon should be marked.</p>
<p>clearMarkIfExists: Flag to indicate whether the edges of the polyline should have their mark cleared if they are already in the network. </p>

</div>
</div>
<a id="a5c1ba58f8d4c84e70487e026fe0ee7fe" name="a5c1ba58f8d4c84e70487e026fe0ee7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1ba58f8d4c84e70487e026fe0ee7fe">&#9670;&#160;</a></span>decompose() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLBoundaryHelper::decompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_polyline.html">TSLPolyline</a> *</td>          <td class="paramname"><span class="paramname"><em>entity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>clipEntity</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>mark</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clearMarkIfExists</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method decomposes the specified polyline into its component edges.</p>
<p>An optional clipping entity may be specified. The edges will be clipped to the boundary of this entity prior to addition.</p>
<p>Arguments list details :</p>
<p>entity : A pointer to the entity to be decomposed.</p>
<p>clipEntity: Optional pointer to the clip boundary</p>
<p>mark : Flag to indicate whether the edges of the polyline should be marked.</p>
<p>clearMarkIfExists: Flag to indicate whether the edges of the polyline should have their mark cleared if they are already in the network. </p>

</div>
</div>
<a id="aa9e15885daa8a744758a1dec2179d8f5" name="aa9e15885daa8a744758a1dec2179d8f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e15885daa8a744758a1dec2179d8f5">&#9670;&#160;</a></span>dynamicBound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_coord_set.html">TSLCoordSet</a> * TSLBoundaryHelper::dynamicBound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> *</td>          <td class="paramname"><span class="paramname"><em>coord</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> *</td>          <td class="paramname"><span class="paramname"><em>boundary</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use this method to find the smallest possible polygon at a given point on a drawing surface. To use this method you must use the constructor that takes a drawing surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>The point at which the search should start.</td></tr>
    <tr><td class="paramname">boundary</td><td>A bounding polygon which specifies the extent to the search. If this is not declared, then a 'smart' search will take place.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="class_t_s_l_coord_set.html">TSLCoordSet</a> representing the smallest enclosure if it succeeds or a null pointer otherwise. </dd></dl>

</div>
</div>
<a id="a5c05dc0c09f634dc15bc67d1c62feb71" name="a5c05dc0c09f634dc15bc67d1c62feb71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c05dc0c09f634dc15bc67d1c62feb71">&#9670;&#160;</a></span>extendMarkedCorners()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLBoundaryHelper::extendMarkedCorners </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>minCornerAngleChange</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>maxExtensionLength</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method extends corners including marked edges be extended to a nearby non marked edge.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minCornerAngleChange</td><td>Minimum angle change, in degrees, that must occur to indicate a corner.</td></tr>
    <tr><td class="paramname">maxExtensionLength</td><td>Maximum length, in TMC units, that a corner may be extended by, </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a66a81b82abc0175ad6c9e9d4b844a2e4" name="a66a81b82abc0175ad6c9e9d4b844a2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a81b82abc0175ad6c9e9d4b844a2e4">&#9670;&#160;</a></span>extendOrphans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLBoundaryHelper::extendOrphans </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>angleTolerance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>scaleFactor</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method extends any orphan chains by the maximum specified amount.</p>
<p>An orphan chain is a chain of edges, starting with a vertex that is only used by a single edge (the end vertex). The angle between each edge in the chain may vary by no more than the specified tolerance, typically a few degrees. The chain will also be terminated by a vertex that is used by three or more edges (eg. a T junction). Once the chain edges have been determined, the length of the chain is calculated. A ray is cast, extending out from the end vertex. If the ray intersects with another edge, then the distance from the end vertex to the intersection is calculated. If this distance is less than the chain length multiplied by the scaleFactor, then an edge is added between the end vertex and the intersection.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angleTolerance</td><td>This is the angle that determines whether the chain is to be continued. The angle is in degrees.</td></tr>
    <tr><td class="paramname">scaleFactor</td><td>Multiplication factor to determine the maximum length of edge that may be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47d0a8a89094c2a342030ae1ccfcfd40" name="a47d0a8a89094c2a342030ae1ccfcfd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d0a8a89094c2a342030ae1ccfcfd40">&#9670;&#160;</a></span>getEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_boundary_edge_list.html">TSLBoundaryEdgeList</a> * TSLBoundaryHelper::getEdges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a new list of the edges found by the operation. Note that though the list is new (and should be destroyed after use), the list contains references to edges actually owned by the <a class="el" href="class_t_s_l_boundary_helper.html">TSLBoundaryHelper</a>. Therefore the helper must stay in existence while the list or its edges are in use.</p>
<p>No arguments. </p>

</div>
</div>
<a id="a999e8eb9e44f0008b1df1f8f18c14af8" name="a999e8eb9e44f0008b1df1f8f18c14af8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a999e8eb9e44f0008b1df1f8f18c14af8">&#9670;&#160;</a></span>getEdgesWithVerticesNear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_boundary_edge_list.html">TSLBoundaryEdgeList</a> * TSLBoundaryHelper::getEdgesWithVerticesNear </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>tolerance</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a list of edges that have at least one vertex close to the given point. Note that though the list is new (and should be destroyed after use), the list contains references to edges actually owned by the TSLBoundary Helper. Therefore the helper must stay in existence while the list or its edges are in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Point to test.</td></tr>
    <tr><td class="paramname">tolerance</td><td>Maximum distance that the vertex may be from the edge to return true. If the point must be exacly on the edge, pass zero. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5ca02c7c21f2b51c698099fc898bd7ec" name="a5ca02c7c21f2b51c698099fc898bd7ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ca02c7c21f2b51c698099fc898bd7ec">&#9670;&#160;</a></span>getHandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLBoundaryHelper::getHandle </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad2e31438cdba98ec05cabd0016b7338b" name="ad2e31438cdba98ec05cabd0016b7338b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e31438cdba98ec05cabd0016b7338b">&#9670;&#160;</a></span>getNearestPoint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_boundary_vertex.html">TSLBoundaryVertex</a> * TSLBoundaryHelper::getNearestPoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>maxTMCDistance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the nearest vertex within the specified distance to the specified point. If no such vertex currently exists within the vertex list, but the point is within maxTMCDistance of an existing edge, then a new vertex is created at the closest point along the edge and returned. The edge is split into two by the new vertex.</p>
<p>Argument descripton: pt : The point to check against maxTMCDistance: Tolerance value to decide whether the vertex and point are the same</p>
<p>Returns nearest Vertex within tolerance or nearest vertex along an edge, NULL if none found </p>

</div>
</div>
<a id="a61b812429bf9432df2f0621fb7d063be" name="a61b812429bf9432df2f0621fb7d063be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61b812429bf9432df2f0621fb7d063be">&#9670;&#160;</a></span>getNearestVertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_boundary_vertex.html">TSLBoundaryVertex</a> * TSLBoundaryHelper::getNearestVertex </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>pt</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>existingOnly</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>maxTMCDistance</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the nearest vertex within the specified distance to the specified point. If no such point currently exists within the vertex list and the 'existingOnly' flag is false, then all edges are checked to see if they are within the tolerance value if the point. If so, then the nearest vertex of that edge is returned. No new vertex is created. Under the latter circumstances, the returned vertex may be outside the tolerance value.</p>
<p>Argument descripton: pt : The point to check against existingOnly : If true, only looks for an existing vertex. If false, also checks for edges within tolerance and returns nearest vertex of any edge within the tolerance value. maxTMCDistance: Tolerance value to decide whether the vertex and point are the same</p>
<p>Returns nearest Vertex within tolerance, NULL if none found and existingOnly is true. </p>

</div>
</div>
<a id="a50d9965807c6ab74e9045605b2b89ad0" name="a50d9965807c6ab74e9045605b2b89ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d9965807c6ab74e9045605b2b89ad0">&#9670;&#160;</a></span>insertGapFillets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLBoundaryHelper::insertGapFillets </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>maximumDistance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inserts additional edges between end vertices.</p>
<p>An end vertex is a vertex that is only used by a single edge. This method inserts an edge between end vertices that are within the specified distance of each other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maximumDistance</td><td>Maximum distance between end vertices to be filled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aedc743f6a9ad239201fa4029023ef61a" name="aedc743f6a9ad239201fa4029023ef61a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc743f6a9ad239201fa4029023ef61a">&#9670;&#160;</a></span>largestContained()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_coord_set.html">TSLCoordSet</a> * TSLBoundaryHelper::largestContained </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_boundary_edge_list.html">TSLBoundaryEdgeList</a> **</td>          <td class="paramname"><span class="paramname"><em>constituentEdges</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method determines the largest polygon that can be constructed within the edges. If necessary, the edges that make up the polygon can be returned by reference.</p>
<p>Both the coordinate set and any constituentEdges returned must be destroyed by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">constituentEdges</td><td>Storage for list of edges that make up the returned polygon.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>smallest enclosing polygon by value, constituent edges by reference. </dd></dl>

</div>
</div>
<a id="a840f0999a0e596076ba5693f764993cf" name="a840f0999a0e596076ba5693f764993cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a840f0999a0e596076ba5693f764993cf">&#9670;&#160;</a></span>removeMarkedEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLBoundaryHelper::removeMarkedEdges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method removes all marked edges from list of edges. </p>

</div>
</div>
<a id="a5d599b249f187bf6d3e86f147d069c24" name="a5d599b249f187bf6d3e86f147d069c24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d599b249f187bf6d3e86f147d069c24">&#9670;&#160;</a></span>removeOrphans()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLBoundaryHelper::removeOrphans </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>angleTolerance</em></span><span class="paramdefsep"> = </span><span class="paramdefval">360.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>maximumLength</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method removes any orphan chains</p>
<p>An orphan chain is a chain of edges, starting with a vertex that is only used by a single edge (the end vertex). The angle between each edge in the chain may vary by no more than the specified tolerance, typically a few degrees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">angleTolerance</td><td>This is the angle that determines whether the chain is to be continued. The angle is in degrees. The default (360.0) will ignore angle changes when determining the chain. The chain will then be terminated by a vertex that is used by three or more edges (eg. a T junction).</td></tr>
    <tr><td class="paramname">maximumLength</td><td>Maximum length of orphan chain to be removed, in TMC units. The default (0.0) will ignore the length and remove all orphan chains. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a510fff5df3468de0e751c2b2e826e1d9" name="a510fff5df3468de0e751c2b2e826e1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a510fff5df3468de0e751c2b2e826e1d9">&#9670;&#160;</a></span>seeds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_coord_set.html">TSLCoordSet</a> * TSLBoundaryHelper::seeds </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method queries for any seed points found during the decomposition of entity sets.</p>
<p>Returns coord set containing seed points found. </p>

</div>
</div>
<a id="a791efa4c423ba909009300966a425a65" name="a791efa4c423ba909009300966a425a65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791efa4c423ba909009300966a425a65">&#9670;&#160;</a></span>smallestEnclosure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_coord_set.html">TSLCoordSet</a> * TSLBoundaryHelper::smallestEnclosure </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coord.html">TSLCoord</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>coord</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_boundary_edge_list.html">TSLBoundaryEdgeList</a> **</td>          <td class="paramname"><span class="paramname"><em>constituentEdges</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method determines the smallest polygon that can be constructed around the specified point. If necessary, the edges that make up the polygon can be returned by reference.</p>
<p>Both the coordinate set and any constituentEdges returned must be destroyed by the caller.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coord</td><td>Coordinate to construct polygon around.</td></tr>
    <tr><td class="paramname">constituentEdges</td><td>Storage for list of edges that make up the returned polygon.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>smallest enclosing polygon by value, constituent edges by reference. </dd></dl>

</div>
</div>
<a id="a480717e4dab5a4b23d9cc6cb56552a56" name="a480717e4dab5a4b23d9cc6cb56552a56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480717e4dab5a4b23d9cc6cb56552a56">&#9670;&#160;</a></span>splitEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLBoundaryHelper::splitEdges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This splits up existing edges where vertices touch. eg. T junctions and + junctions</p>
<p>Arguments list details :</p>
<p>No parameters. </p>

</div>
</div>
<a id="ac034c5e4d29c6ceed815692eb3f3d4f0" name="ac034c5e4d29c6ceed815692eb3f3d4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac034c5e4d29c6ceed815692eb3f3d4f0">&#9670;&#160;</a></span>unmarkContinuationEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLBoundaryHelper::unmarkContinuationEdges </td>
          <td>(</td>
          <td class="paramtype">Double</td>          <td class="paramname"><span class="paramname"><em>angleTolerance</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method removes the 'marked' flag from edges which run in a straight line from unmarked edges.</p>
<p>A tolerance angle may be specified to determine how straight the line should be.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">toleranceAngle</td><td>This is the angle that determines whether the line is straight. The angle is in degrees. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_boundary_helper.html">TSLBoundaryHelper</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.1 | Documentation created Thu Feb 6 2025 11:09:32 | Generated with <a href="http://www.doxygen.org/index.html">Doxygen 1.13.2</a> | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
