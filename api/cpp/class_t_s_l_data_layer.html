<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLDataLayer Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.1.1.0.</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_data_layer.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_t_s_l_data_layer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLDataLayer Class Reference<div class="ingroups"><a class="el" href="group__apigroup__maplink__pro__developers__toolkit.html">MapLink Pro Developer Toolkit</a> &raquo; <a class="el" href="group__apigroup__api.html">Core API</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for TSLDataLayer:</div>
<div class="dyncontent">
<div class="center"><img src="class_t_s_l_data_layer__inherit__graph.png" border="0" usemap="#a_t_s_l_data_layer_inherit__map" alt="Inheritance graph"/></div>
<map name="a_t_s_l_data_layer_inherit__map" id="a_t_s_l_data_layer_inherit__map">
<area shape="rect" title=" " alt="" coords="5,655,99,681"/>
<area shape="rect" href="class_t_s_l2_d_satellite_data_layer.html" title=" " alt="" coords="157,31,308,57"/>
<area shape="poly" title=" " alt="" coords="51,639,56,517,70,346,82,259,98,179,119,113,131,88,145,68,159,56,163,60,149,71,135,90,124,115,103,181,87,260,76,347,62,517,57,639"/>
<area shape="rect" href="class_t_s_l3_d_data_layer.html" title=" " alt="" coords="179,81,286,108"/>
<area shape="poly" title=" " alt="" coords="52,639,58,526,73,371,85,291,101,219,121,160,145,118,160,106,178,98,180,103,163,111,149,122,125,162,106,221,91,292,79,371,63,526,57,639"/>
<area shape="rect" href="class_t_s_l_accelerated_custom_data_layer.html" title=" " alt="" coords="147,132,319,175"/>
<area shape="poly" title=" " alt="" coords="53,639,62,539,79,404,91,336,106,273,124,221,145,185,158,173,161,177,149,188,129,224,111,275,97,337,84,405,67,540,58,639"/>
<area shape="rect" href="class_t_s_l_c_a_d_r_g_data_layer.html" title=" " alt="" coords="168,199,298,225"/>
<area shape="poly" title=" " alt="" coords="53,639,63,548,81,428,108,312,125,267,145,235,166,221,169,225,149,239,130,269,113,314,86,429,68,549,58,640"/>
<area shape="rect" href="class_t_s_l_custom_data_layer.html" title=" " alt="" coords="165,249,301,276"/>
<area shape="poly" title=" " alt="" coords="54,639,65,557,84,452,111,352,127,313,145,286,163,273,166,277,149,290,132,316,116,354,90,454,71,558,59,639"/>
<area shape="rect" href="class_t_s_l_direct_import_data_layer.html" title=" " alt="" coords="152,300,314,327"/>
<area shape="poly" title=" " alt="" coords="50,639,53,577,66,496,78,453,95,411,117,372,145,337,161,325,164,329,149,341,121,375,99,413,83,455,71,497,59,577,55,639"/>
<area shape="rect" href="class_t_s_l_filter_data_layer.html" title=" " alt="" coords="173,351,292,377"/>
<area shape="poly" title=" " alt="" coords="52,639,58,585,73,518,85,483,100,448,120,416,145,387,171,371,174,376,148,391,125,419,105,451,90,485,78,520,63,586,57,639"/>
<area shape="rect" href="class_t_s_l_g_a_r_s_grid_data_layer.html" title=" " alt="" coords="162,401,304,428"/>
<area shape="poly" title=" " alt="" coords="54,639,63,595,80,541,106,486,124,460,145,438,163,426,166,431,148,442,128,464,111,489,85,543,68,596,60,640"/>
<area shape="rect" href="class_t_s_l_grid_data_layer.html" title=" " alt="" coords="175,452,290,479"/>
<area shape="poly" title=" " alt="" coords="58,638,70,604,88,564,113,523,145,489,173,473,176,478,148,493,117,527,93,566,75,606,63,640"/>
<area shape="rect" href="class_t_s_l_heat_map_data_layer.html" title="Class to display heat map data." alt="" coords="162,503,304,529"/>
<area shape="poly" title=" " alt="" coords="64,639,96,588,119,562,145,539,167,528,169,532,148,544,123,566,101,592,69,642"/>
<area shape="rect" href="class_t_s_l_k_m_l_data_layer.html" title=" " alt="" coords="176,553,290,580"/>
<area shape="poly" title=" " alt="" coords="76,642,108,615,145,590,175,577,177,582,148,594,111,619,79,646"/>
<area shape="rect" href="class_t_s_l_lat_long_grid_data_layer.html" title=" " alt="" coords="154,604,312,631"/>
<area shape="poly" title=" " alt="" coords="113,648,182,629,183,634,114,653"/>
<area shape="rect" href="class_t_s_l_m_g_r_s_grid_data_layer.html" title=" " alt="" coords="161,655,305,681"/>
<area shape="poly" title=" " alt="" coords="114,665,160,665,160,671,114,671"/>
<area shape="rect" href="class_t_s_l_map_data_layer.html" title=" " alt="" coords="175,705,291,732"/>
<area shape="poly" title=" " alt="" coords="114,683,183,702,182,707,113,688"/>
<area shape="rect" href="class_t_s_l_national_grid_data_layer.html" title=" " alt="" coords="153,756,313,783"/>
<area shape="poly" title=" " alt="" coords="79,690,111,717,148,742,175,753,173,758,145,746,108,721,76,694"/>
<area shape="rect" href="class_t_s_l_object_data_layer.html" title=" " alt="" coords="169,807,297,833"/>
<area shape="poly" title=" " alt="" coords="69,694,101,744,123,770,148,792,169,804,167,808,145,797,119,774,96,748,64,697"/>
<area shape="rect" href="class_t_s_l_pooled_map_data_layer.html" title=" " alt="" coords="156,857,310,884"/>
<area shape="poly" title=" " alt="" coords="63,696,75,730,93,770,117,809,148,843,167,854,164,859,145,847,113,813,88,772,70,732,58,698"/>
<area shape="rect" href="class_t_s_l_raster_data_layer.html" title=" " alt="" coords="169,908,296,935"/>
<area shape="poly" title=" " alt="" coords="60,696,68,740,85,793,111,847,128,872,148,894,170,907,167,912,145,898,124,876,106,850,80,795,63,741,54,697"/>
<area shape="rect" href="class_t_s_l_s52_no_data_layer.html" title=" " alt="" coords="170,959,296,985"/>
<area shape="poly" title=" " alt="" coords="57,697,63,750,78,816,90,851,105,885,125,917,148,945,171,959,168,963,145,949,120,920,100,888,85,853,73,818,58,751,52,697"/>
<area shape="rect" href="class_t_s_l_s63_data_layer.html" title=" " alt="" coords="177,1009,289,1036"/>
<area shape="poly" title=" " alt="" coords="55,697,59,759,71,839,83,881,99,923,121,961,149,995,162,1005,177,1012,175,1017,159,1010,145,999,117,964,95,925,78,883,66,840,53,759,50,697"/>
<area shape="rect" href="class_t_s_l_standard_data_layer.html" title=" " alt="" coords="162,1060,304,1087"/>
<area shape="poly" title=" " alt="" coords="59,697,71,778,90,882,116,982,132,1020,149,1046,163,1057,160,1062,145,1050,127,1023,111,984,84,884,65,779,54,697"/>
<area shape="rect" href="class_t_s_l_static_map_data_layer.html" title=" " alt="" coords="160,1111,306,1137"/>
<area shape="poly" title=" " alt="" coords="58,696,68,787,86,907,113,1022,130,1067,149,1097,163,1108,160,1112,145,1100,125,1069,108,1024,81,908,63,788,53,697"/>
<area shape="rect" href="class_t_s_l_view_shed_data_layer.html" title=" " alt="" coords="160,1161,306,1188"/>
<area shape="poly" title=" " alt="" coords="58,697,66,797,83,932,95,1001,110,1063,128,1113,149,1148,163,1159,159,1163,145,1151,123,1115,105,1064,90,1002,78,933,61,798,52,697"/>
<area shape="rect" href="class_t_s_l_w_m_s_data_layer.html" title=" " alt="" coords="174,1212,292,1239"/>
<area shape="poly" title=" " alt="" coords="57,697,64,806,80,957,92,1033,107,1103,126,1160,149,1198,160,1208,174,1215,172,1220,157,1212,145,1202,121,1162,102,1104,86,1034,74,958,59,807,52,697"/>
<area shape="rect" href="class_t_s_l_w_m_t_s_data_layer.html" title=" " alt="" coords="171,1263,295,1289"/>
<area shape="poly" title=" " alt="" coords="57,697,62,816,76,981,88,1066,104,1143,124,1206,136,1230,149,1249,172,1265,168,1269,145,1253,131,1233,119,1208,99,1144,83,1067,71,982,57,816,51,697"/>
<area shape="rect" href="class_t_s_l3_d_custom_data_layer.html" title=" " alt="" coords="370,5,520,32"/>
<area shape="poly" title=" " alt="" coords="300,74,318,67,366,42,397,30,398,35,368,46,320,72,302,79"/>
<area shape="rect" href="class_t_s_l3_d_satellite_data_layer.html" title=" " alt="" coords="370,56,521,83"/>
<area shape="poly" title=" " alt="" coords="302,84,369,76,369,81,303,89"/>
<area shape="rect" href="class_t_s_l3_d_standard_data_layer.html" title=" " alt="" coords="367,107,523,133"/>
<area shape="poly" title=" " alt="" coords="303,100,367,108,366,113,302,106"/>
<area shape="rect" href="class_t_s_l3_d_terrain_data_layer.html" title=" " alt="" coords="372,157,518,184"/>
<area shape="poly" title=" " alt="" coords="302,111,320,118,368,143,398,154,397,159,366,148,318,122,300,116"/>
<area shape="rect" href="class_t_s_l_n_i_t_f_filter_data_layer.html" title=" " alt="" coords="375,325,515,352"/>
<area shape="poly" title=" " alt="" coords="307,352,374,344,375,350,308,358"/>
<area shape="rect" href="class_t_s_l_raster_filter_data_layer.html" title=" " alt="" coords="368,376,522,403"/>
<area shape="poly" title=" " alt="" coords="309,370,368,378,368,383,308,376"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Collection of all entities used to make up a coherent set of data.</p>
<p><a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> is an abstract class and so cannot be instantiated directly. Clients should instantiate one of its derived classes (e.g. <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a>).</p>
<p>Data layers should be destroyed by calling the destroy method rather than deleting them.</p>
<p><a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> provides a mechanism by which historical versions of a layer can be viewed - this is termed 'flashback'. The methods <a class="el" href="#abd072130777b87c3ef6db086749845e5">flashbackToVersion()</a> and <a class="el" href="#ab953980469594aab11575009626c00b3">flashbackToTimestamp()</a> allow the user to look at historical versions of the layer based either on a version number or on a timestamp. When these methods are called, both the memory and persistent caches will be cleared.</p>
<p>Users can query whether a layer has any historical versions by calling the method <a class="el" href="#a19803bde4b29d406445dd7a4b9aab850">versionHistory()</a>. This returns an object that users can query for the number of versions. If it is empty it means that no archived versions of the layer exist. To revert to the current layer, simply call <a class="el" href="#a3105441039ed9fb09713165dad545d9c">cancelFlashback()</a>. If the data layer is being dynamically archived, then calling <a class="el" href="#aad29ab355dbb41a0fcd809dcc7b11337">refreshFlashback()</a> will refresh all internal memory structures and allow the newly archived versions to be available to the user.</p>
<p>When using either of the two flashbackTo...() methods, users must provide a callback function. MapLink will use the callback to ask for the location of the layer's archive at a particular version. This will then be cached until flashback is cancelled or refreshed. The directory that should be returned by the callback is the same directory that was used to create the archive originally. This will depend on the application that creates the original archive. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4fbc03b97523bbe9eb21cfefb8b545de" id="r_a4fbc03b97523bbe9eb21cfefb8b545de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4fbc03b97523bbe9eb21cfefb8b545de">addDrawingCallback</a> (<a class="el" href="class_t_s_l_data_layer_drawing_callback.html">TSLDataLayerDrawingCallback</a> *drawingCallback)</td></tr>
<tr class="separator:a4fbc03b97523bbe9eb21cfefb8b545de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e9a5296f10a07340cc465b5ca9466f" id="r_a10e9a5296f10a07340cc465b5ca9466f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10e9a5296f10a07340cc465b5ca9466f">addFeatureRendering</a> (const char *featureName, TSLFeatureID featureID)</td></tr>
<tr class="separator:a10e9a5296f10a07340cc465b5ca9466f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f31630e6fda8c34be66ef6dc987ff0" id="r_a17f31630e6fda8c34be66ef6dc987ff0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17f31630e6fda8c34be66ef6dc987ff0">addLoader</a> (<a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *loader, <a class="el" href="group__apigroup__api.html#ga48f96f9ef6e81104016f6904e8883230">TSLLoaderAppCallback</a> callback, void *arg, <a class="el" href="group__apigroup__api.html#ga11aea432930000091575dc2fefca227d">TSLAllLoadedCallback</a> allLoadedCallback=0, void *arg2=0)</td></tr>
<tr class="separator:a17f31630e6fda8c34be66ef6dc987ff0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d9f8234df5031730501c6371e12d88" id="r_ac2d9f8234df5031730501c6371e12d88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2d9f8234df5031730501c6371e12d88">addPathList</a> (const <a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> *path_list)</td></tr>
<tr class="separator:ac2d9f8234df5031730501c6371e12d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3105441039ed9fb09713165dad545d9c" id="r_a3105441039ed9fb09713165dad545d9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3105441039ed9fb09713165dad545d9c">cancelFlashback</a> ()</td></tr>
<tr class="separator:a3105441039ed9fb09713165dad545d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991b7cfea7d673b7b3d9f9f4c64d5cfd" id="r_a991b7cfea7d673b7b3d9f9f4c64d5cfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a991b7cfea7d673b7b3d9f9f4c64d5cfd">clearFeatureRendering</a> (const char *featureName, TSLFeatureID featureID)</td></tr>
<tr class="separator:a991b7cfea7d673b7b3d9f9f4c64d5cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4acea014d2126ae89eeb777cbebb26" id="r_a8d4acea014d2126ae89eeb777cbebb26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d4acea014d2126ae89eeb777cbebb26">createDataHandler</a> (const char *config_file=0)</td></tr>
<tr class="separator:a8d4acea014d2126ae89eeb777cbebb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f02a7ea00e2ea18861508ffec7b024" id="r_a02f02a7ea00e2ea18861508ffec7b024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02f02a7ea00e2ea18861508ffec7b024">currentVersion</a> () const</td></tr>
<tr class="separator:a02f02a7ea00e2ea18861508ffec7b024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8761e162ed667836db6f6ec2f21f1d8" id="r_ab8761e162ed667836db6f6ec2f21f1d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8761e162ed667836db6f6ec2f21f1d8">dataHandler</a> ()</td></tr>
<tr class="separator:ab8761e162ed667836db6f6ec2f21f1d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab86eea288d1ecae6b630954038ba1a2" id="r_aab86eea288d1ecae6b630954038ba1a2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab86eea288d1ecae6b630954038ba1a2">dataHandler</a> () const</td></tr>
<tr class="separator:aab86eea288d1ecae6b630954038ba1a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cffcfd0ac1e02c02e845fc46411a25e" id="r_a4cffcfd0ac1e02c02e845fc46411a25e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cffcfd0ac1e02c02e845fc46411a25e">destroy</a> ()</td></tr>
<tr class="separator:a4cffcfd0ac1e02c02e845fc46411a25e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c73aeed7bdbabd90e656b4db0d8ecb" id="r_ad7c73aeed7bdbabd90e656b4db0d8ecb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7c73aeed7bdbabd90e656b4db0d8ecb">entityIsVisible</a> (const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *entity, const <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *drawingSurface) const</td></tr>
<tr class="separator:ad7c73aeed7bdbabd90e656b4db0d8ecb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194db4f2f5e2c20b9b75285abaa8841b" id="r_a194db4f2f5e2c20b9b75285abaa8841b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_feature_class_list.html">TSLFeatureClassList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a194db4f2f5e2c20b9b75285abaa8841b">featureList</a> () const</td></tr>
<tr class="separator:a194db4f2f5e2c20b9b75285abaa8841b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af587d2e872c15803342eef1973cec1bb" id="r_af587d2e872c15803342eef1973cec1bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_feature_class_list.html">TSLFeatureClassList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af587d2e872c15803342eef1973cec1bb">featureList</a> (const char *detailLayerName) const</td></tr>
<tr class="separator:af587d2e872c15803342eef1973cec1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8997d0cbd428a6aa9783a4fd45a70cb5" id="r_a8997d0cbd428a6aa9783a4fd45a70cb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8997d0cbd428a6aa9783a4fd45a70cb5">fileModificationTime</a> (const char *filename, TSLTimeType &amp;lastModificationTime)</td></tr>
<tr class="separator:a8997d0cbd428a6aa9783a4fd45a70cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd7da13f831401661e0a63e19c52a64" id="r_abfd7da13f831401661e0a63e19c52a64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfd7da13f831401661e0a63e19c52a64">findEntity</a> (TSLTMC x, TSLTMC y, TSLTMC aperture, int depth, const char *featureName=0, int drawingSurfaceID=-1)</td></tr>
<tr class="separator:abfd7da13f831401661e0a63e19c52a64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe90ad7a643c8cb39dac461e1ba9d367" id="r_afe90ad7a643c8cb39dac461e1ba9d367"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe90ad7a643c8cb39dac461e1ba9d367">findFile</a> (const char *filename, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;foundPath) const</td></tr>
<tr class="separator:afe90ad7a643c8cb39dac461e1ba9d367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab953980469594aab11575009626c00b3" id="r_ab953980469594aab11575009626c00b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab953980469594aab11575009626c00b3">flashbackToTimestamp</a> (<a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a> timestamp, <a class="el" href="group__apigroup__api.html#gaf92bab978dd0ee67b6781c3ca417e233">TSLLayerArchiveCallback</a> archiveCallback, void *arg=0)</td></tr>
<tr class="separator:ab953980469594aab11575009626c00b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c24847ea318be6604ec34d1d242aa62" id="r_a4c24847ea318be6604ec34d1d242aa62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c24847ea318be6604ec34d1d242aa62">flashbackToTimestamp</a> (<a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a> timestamp, <a class="el" href="group__apigroup__api.html#ga40ea9a3893d69e5865dc7c72f62b9ae2">TSLLayerArchiveTileCallback</a> archiveTileCallback, void *arg=0)</td></tr>
<tr class="separator:a4c24847ea318be6604ec34d1d242aa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd072130777b87c3ef6db086749845e5" id="r_abd072130777b87c3ef6db086749845e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd072130777b87c3ef6db086749845e5">flashbackToVersion</a> (<a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a> version, <a class="el" href="group__apigroup__api.html#gaf92bab978dd0ee67b6781c3ca417e233">TSLLayerArchiveCallback</a> archiveCallback, void *arg=0)</td></tr>
<tr class="separator:abd072130777b87c3ef6db086749845e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e8441c8c13520930ddb118c0fae0c0" id="r_a14e8441c8c13520930ddb118c0fae0c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14e8441c8c13520930ddb118c0fae0c0">flashbackToVersion</a> (<a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a> version, <a class="el" href="group__apigroup__api.html#ga40ea9a3893d69e5865dc7c72f62b9ae2">TSLLayerArchiveTileCallback</a> archiveTileCallback, void *arg=0)</td></tr>
<tr class="separator:a14e8441c8c13520930ddb118c0fae0c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf439f3ddf34295b02e4a2e31eb1911" id="r_a9cf439f3ddf34295b02e4a2e31eb1911"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9cf439f3ddf34295b02e4a2e31eb1911">getActiveLayerName</a> (const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent, double screenResolution, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;activeLayerName) const</td></tr>
<tr class="separator:a9cf439f3ddf34295b02e4a2e31eb1911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62b5809179e31d019dec790177d42a6" id="r_ad62b5809179e31d019dec790177d42a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity_iterator.html">TSLEntityIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad62b5809179e31d019dec790177d42a6">getEntityIterator</a> (const char *detailLayer, <a class="el" href="class_t_s_l_selector.html">TSLSelector</a> *selector=NULL, <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> *extent=NULL, bool splitOptimisedPrimitives=true)</td></tr>
<tr class="separator:ad62b5809179e31d019dec790177d42a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b6bf865d0afde06a262fc7fb0edc43" id="r_a75b6bf865d0afde06a262fc7fb0edc43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75b6bf865d0afde06a262fc7fb0edc43">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a> attribute, int *result) const</td></tr>
<tr class="separator:a75b6bf865d0afde06a262fc7fb0edc43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0232b2f236064f89665f1776dca140b" id="r_af0232b2f236064f89665f1776dca140b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af0232b2f236064f89665f1776dca140b">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a> attribute, double *result) const</td></tr>
<tr class="separator:af0232b2f236064f89665f1776dca140b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a98dc01354ecec9c65eac5de8795e59" id="r_a6a98dc01354ecec9c65eac5de8795e59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a98dc01354ecec9c65eac5de8795e59">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a> attribute, bool *result) const</td></tr>
<tr class="separator:a6a98dc01354ecec9c65eac5de8795e59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fae08a54978e8e2b0aa2344caeedf2d" id="r_a3fae08a54978e8e2b0aa2344caeedf2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fae08a54978e8e2b0aa2344caeedf2d">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *result) const</td></tr>
<tr class="separator:a3fae08a54978e8e2b0aa2344caeedf2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35de696e1cd209e428c8da6c2f4e300b" id="r_a35de696e1cd209e428c8da6c2f4e300b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a35de696e1cd209e428c8da6c2f4e300b">getLoader</a> ()</td></tr>
<tr class="separator:a35de696e1cd209e428c8da6c2f4e300b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34074a432614a62093d349838dcdbfd2" id="r_a34074a432614a62093d349838dcdbfd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a34074a432614a62093d349838dcdbfd2">getMUExtent</a> (double *x1, double *y1, double *x2, double *y2, int drawingSurfaceID=-1) const</td></tr>
<tr class="separator:a34074a432614a62093d349838dcdbfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7677906c203b52b4dde95807202e21f2" id="r_a7677906c203b52b4dde95807202e21f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7677906c203b52b4dde95807202e21f2">getTMCExtent</a> (TSLTMC *x1, TSLTMC *y1, TSLTMC *x2, TSLTMC *y2, int drawingSurfaceID=-1) const</td></tr>
<tr class="separator:a7677906c203b52b4dde95807202e21f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bf18c76d0d8c476eb5ce835f16b69f" id="r_ab0bf18c76d0d8c476eb5ce835f16b69f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab0bf18c76d0d8c476eb5ce835f16b69f">getUUExtent</a> (double *x1, double *y1, double *x2, double *y2, const <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *drawingSurface) const</td></tr>
<tr class="separator:ab0bf18c76d0d8c476eb5ce835f16b69f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f186469525c8fb0b4cc9c415546492" id="r_a43f186469525c8fb0b4cc9c415546492"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43f186469525c8fb0b4cc9c415546492">importHistory</a> (<a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a> mapVersion, <a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a> timestamp, <a class="el" href="class_t_s_l_history_import_set.html">TSLHistoryImportSet</a> *historySet)</td></tr>
<tr class="separator:a43f186469525c8fb0b4cc9c415546492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242fafc67323bf7489430a1b1cf20a15" id="r_a242fafc67323bf7489430a1b1cf20a15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a242fafc67323bf7489430a1b1cf20a15">latLongToTMC</a> (double latitude, double longitude, TSLTMC *x, TSLTMC *y, bool local=false) const</td></tr>
<tr class="separator:a242fafc67323bf7489430a1b1cf20a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049b9cb6c75049b976a44a63a4fda83f" id="r_a049b9cb6c75049b976a44a63a4fda83f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a049b9cb6c75049b976a44a63a4fda83f">latLongToTMC</a> (int num, double *latitudes, double *longitudes, TSLTMC *xs, TSLTMC *ys, bool local=false) const</td></tr>
<tr class="separator:a049b9cb6c75049b976a44a63a4fda83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc060243cb1337c3b8709c1cec683720" id="r_acc060243cb1337c3b8709c1cec683720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apigroup__api.html#gaf8bedcb6358f6ef60075d2bbca8fe118">TSLDataLayerTypeEnum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acc060243cb1337c3b8709c1cec683720">layerType</a> () const</td></tr>
<tr class="separator:acc060243cb1337c3b8709c1cec683720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996e6ca3e3b9b10fc0f6fbe714a525a0" id="r_a996e6ca3e3b9b10fc0f6fbe714a525a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a996e6ca3e3b9b10fc0f6fbe714a525a0">loadData</a> (const char *filename)</td></tr>
<tr class="separator:a996e6ca3e3b9b10fc0f6fbe714a525a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5882d7ca1362bf7dce2ceff2e08d5b1" id="r_ad5882d7ca1362bf7dce2ceff2e08d5b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad5882d7ca1362bf7dce2ceff2e08d5b1">loadRendering</a> (const char *filename)</td></tr>
<tr class="separator:ad5882d7ca1362bf7dce2ceff2e08d5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b87a4127970755ed66caaf44e48de9" id="r_a05b87a4127970755ed66caaf44e48de9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05b87a4127970755ed66caaf44e48de9">notifyChanged</a> (bool changed=true)</td></tr>
<tr class="separator:a05b87a4127970755ed66caaf44e48de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1794ff9ca4ebbea2ee17986729de0b3c" id="r_a1794ff9ca4ebbea2ee17986729de0b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1794ff9ca4ebbea2ee17986729de0b3c">query</a> (TSLTMC x1, TSLTMC y1, TSLTMC x2, TSLTMC y2, int depth=-1, const char *featureName=NULL, int drawingSurfaceID=-1) const</td></tr>
<tr class="separator:a1794ff9ca4ebbea2ee17986729de0b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80490627af3ab4871812115802c56359" id="r_a80490627af3ab4871812115802c56359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80490627af3ab4871812115802c56359">query</a> (TSLTMC x1, TSLTMC y1, TSLTMC x2, TSLTMC y2, <a class="el" href="class_t_s_l_selector.html">TSLSelector</a> *selector, int drawingSurfaceID=-1) const</td></tr>
<tr class="separator:a80490627af3ab4871812115802c56359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b71c959052cf95ffcdbd00d0912603" id="r_a37b71c959052cf95ffcdbd00d0912603"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37b71c959052cf95ffcdbd00d0912603">getCoordinateSystem</a> () const</td></tr>
<tr class="separator:a37b71c959052cf95ffcdbd00d0912603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ad614ec1fb35434810d08e6a8ba8b5" id="r_a36ad614ec1fb35434810d08e6a8ba8b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a36ad614ec1fb35434810d08e6a8ba8b5">queryVersionHistory</a> (const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent, <a class="el" href="class_t_s_l_version_history_set.html">TSLVersionHistorySet</a> &amp;history)</td></tr>
<tr class="separator:a36ad614ec1fb35434810d08e6a8ba8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad29ab355dbb41a0fcd809dcc7b11337" id="r_aad29ab355dbb41a0fcd809dcc7b11337"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad29ab355dbb41a0fcd809dcc7b11337">refreshFlashback</a> ()</td></tr>
<tr class="separator:aad29ab355dbb41a0fcd809dcc7b11337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7de8beee6ba358591a22c0a2dd567a0" id="r_ab7de8beee6ba358591a22c0a2dd567a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7de8beee6ba358591a22c0a2dd567a0">removeData</a> ()</td></tr>
<tr class="separator:ab7de8beee6ba358591a22c0a2dd567a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f727d73219da9ab2b94e0329a74607" id="r_ac4f727d73219da9ab2b94e0329a74607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4f727d73219da9ab2b94e0329a74607">releaseResources</a> (int surfaceID)</td></tr>
<tr class="separator:ac4f727d73219da9ab2b94e0329a74607"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b668fab4184d186d48ba860b7ca41ab" id="r_a7b668fab4184d186d48ba860b7ca41ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b668fab4184d186d48ba860b7ca41ab">saveRendering</a> (const char *filename, <a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a> ver=<a class="el" href="group__apigroup__common.html#gga8141b1e165228e088c49024076e13758a0ecdea6c91f1d3104d6166d69b57c88d">TSL_CURRENT_MAPLINK_VERSION</a>)</td></tr>
<tr class="separator:a7b668fab4184d186d48ba860b7ca41ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c58b8475acb63c5a3f031e0cac28449" id="r_a8c58b8475acb63c5a3f031e0cac28449"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c58b8475acb63c5a3f031e0cac28449">setCoordinateSystem</a> (const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *coordinateSystem)</td></tr>
<tr class="separator:a8c58b8475acb63c5a3f031e0cac28449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b60a990c7763ccb582dc2b59aa769f" id="r_a15b60a990c7763ccb582dc2b59aa769f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15b60a990c7763ccb582dc2b59aa769f">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a> attribute, int value)</td></tr>
<tr class="separator:a15b60a990c7763ccb582dc2b59aa769f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01692e748c350a23675ad3d78807e684" id="r_a01692e748c350a23675ad3d78807e684"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a01692e748c350a23675ad3d78807e684">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a> attribute, double value)</td></tr>
<tr class="separator:a01692e748c350a23675ad3d78807e684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1527856e58de4618ad218424738c6986" id="r_a1527856e58de4618ad218424738c6986"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1527856e58de4618ad218424738c6986">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a> attribute, bool value)</td></tr>
<tr class="separator:a1527856e58de4618ad218424738c6986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ac4671ad4be33730b564240532754b" id="r_a74ac4671ad4be33730b564240532754b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74ac4671ad4be33730b564240532754b">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *value)</td></tr>
<tr class="separator:a74ac4671ad4be33730b564240532754b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab580b6f9a6e8a6615937256304489f" id="r_a4ab580b6f9a6e8a6615937256304489f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4ab580b6f9a6e8a6615937256304489f">TMCToLatLong</a> (TSLTMC x, TSLTMC y, double *latitude, double *longitude, bool local=false, bool boundCheck=true) const</td></tr>
<tr class="separator:a4ab580b6f9a6e8a6615937256304489f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568048fa9c27f7100df84bb1d08524fa" id="r_a568048fa9c27f7100df84bb1d08524fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a568048fa9c27f7100df84bb1d08524fa">TMCToLatLong</a> (int num, TSLTMC *xs, TSLTMC *ys, double *latitudes, double *longitudes, bool local=false) const</td></tr>
<tr class="separator:a568048fa9c27f7100df84bb1d08524fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19803bde4b29d406445dd7a4b9aab850" id="r_a19803bde4b29d406445dd7a4b9aab850"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_version_history_set.html">TSLVersionHistorySet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19803bde4b29d406445dd7a4b9aab850">versionHistory</a> () const</td></tr>
<tr class="separator:a19803bde4b29d406445dd7a4b9aab850"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4fbc03b97523bbe9eb21cfefb8b545de" name="a4fbc03b97523bbe9eb21cfefb8b545de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fbc03b97523bbe9eb21cfefb8b545de">&#9670;&#160;</a></span>addDrawingCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDataLayer::addDrawingCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_data_layer_drawing_callback.html">TSLDataLayerDrawingCallback</a> *</td>          <td class="paramname"><span class="paramname"><em>drawingCallback</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a <a class="el" href="class_t_s_l_data_layer_drawing_callback.html">TSLDataLayerDrawingCallback</a> object to the layer. The user retains ownership of the callback object. Any existing callback object for this data layer is replaced.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">drawingCallback</td><td>a user created <a class="el" href="class_t_s_l_data_layer_drawing_callback.html">TSLDataLayerDrawingCallback</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a10e9a5296f10a07340cc465b5ca9466f" name="a10e9a5296f10a07340cc465b5ca9466f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10e9a5296f10a07340cc465b5ca9466f">&#9670;&#160;</a></span>addFeatureRendering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::addFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds feature rendering.</p>
<p>This method allows the user to add a new feature to the rendering list. If a rendering style for the feature name already exists, it will be cleared, otherwise a new style will be created.</p>
<p>When MapLink is rendering a feature, it first looks at whether the entity has an attribute set. If so, then it tries to apply that attribute set and render the entity. If not, then it uses the feature id of the entity to index into the rendering information loaded into the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. If there is no rendering information in the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>, then it defaults to the rendering information stored with the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>.</p>
<p>If an entity has no attribute set or feature id, then the parent is recursively queried for attribute set and feature code.</p>
<p>If neither an entity, nor any of its parents have attribute sets or feature id, then the entity will not be rendered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Feature class name to which the rendering style is applied.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success , false otherwise. </dd></dl>

</div>
</div>
<a id="a17f31630e6fda8c34be66ef6dc987ff0" name="a17f31630e6fda8c34be66ef6dc987ff0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f31630e6fda8c34be66ef6dc987ff0">&#9670;&#160;</a></span>addLoader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::addLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *</td>          <td class="paramname"><span class="paramname"><em>loader</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga48f96f9ef6e81104016f6904e8883230">TSLLoaderAppCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga11aea432930000091575dc2fefca227d">TSLAllLoadedCallback</a></td>          <td class="paramname"><span class="paramname"><em>allLoadedCallback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg2</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The application can provide a file loader for the data layer to use when loading data.</p>
<p>If 'addLoader' has not been called when a loader is needed, the data layer will create a FileLoaderBlocking.</p>
<p>If a loader is already instantiated, it will be replaced by the one provided.</p>
<p>Typically, 'addLoader' would be called to add a <a class="el" href="class_t_s_l_file_loader_m_t.html">TSLFileLoaderMT</a> so that an application can load data in a background thread whilst continuing to respond to user input, or a <a class="el" href="class_t_s_l_file_loader_remote.html">TSLFileLoaderRemote</a> so that an application can load data from an internet server.</p>
<p>If 'addLoader' is called, the data layer takes a reference to the loader but does not take ownership of it. The loader could be added to many data layers as well as the surface. The application must ensure that the loader remains in existence while the layer has a reference to it, and the application must delete the loader when it is no longer needed.</p>
<p>But if the layer creates a <a class="el" href="class_t_s_l_file_loader_blocking.html">TSLFileLoaderBlocking</a> because no loader was added, the surface will own the loader and will delete it when necessary. In fact, all data layers share a single static loader which is created when first needed and destroyed when no longer needed.</p>
<p>The application may add a callback which is called when each tile loads.</p>
<p>The application may also provide an "allLoaded" callback to be called after every draw of a map data layer when all required tiles have been loaded. If all required tiles are already loaded in the cache then the callback will not be called.</p>
<p>NOTE: Both callbacks may be issued from a background thread within MapLink. The user must ensure that they are handled in a thread-safe manner.</p>
<p>NOTE: The following data layers do not currently use loaders, and will load data directly from files on disk:</p><ul>
<li><a class="el" href="class_t_s_l_c_a_d_r_g_data_layer.html">TSLCADRGDataLayer</a></li>
<li><a class="el" href="class_t_s_l_raster_filter_data_layer.html">TSLRasterFilterDataLayer</a></li>
<li><a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a></li>
</ul>
<p>NOTE: The <a class="el" href="class_t_s_l_w_m_s_data_layer.html">TSLWMSDataLayer</a> may only have a <a class="el" href="class_t_s_l_file_loader_remote.html">TSLFileLoaderRemote</a> associated with it. Attempting to set a file loader of a different type will fail</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loader</td><td>Reference to loader to add.</td></tr>
    <tr><td class="paramname">callback</td><td>Callback to be made when each tile has loaded.</td></tr>
    <tr><td class="paramname">arg</td><td>User-defined argument, passed to application callback.</td></tr>
    <tr><td class="paramname">allLoadedCallback</td><td>Callback to be made when map tiles have loaded following a draw.</td></tr>
    <tr><td class="paramname">arg2</td><td>User-defined argument, passed to application allLoaded callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>

</div>
</div>
<a id="ac2d9f8234df5031730501c6371e12d88" name="ac2d9f8234df5031730501c6371e12d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2d9f8234df5031730501c6371e12d88">&#9670;&#160;</a></span>addPathList()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::addPathList </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> *</td>          <td class="paramname"><span class="paramname"><em>path_list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds a <a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> object to the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>.</p>
<p>When a <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> requires any files it will search the directory list built by the user and specified by the <a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> object.</p>
<p>In the case of the MapDataLayer, an internal pathlist may also be created by loadData.</p>
<p>A subsequent call to this method will replace the previous <a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> added to the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>. Therefore the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> will use the new added <a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> to search for the files required.</p>
<p>Note: a single <a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> object may be used by a number of TSLDataLayers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path_list</td><td>Path list object to be added to the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>. The class retains a pointer to the pathlist but does not take ownership of it. The user must delete it when no longer needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a3105441039ed9fb09713165dad545d9c" name="a3105441039ed9fb09713165dad545d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3105441039ed9fb09713165dad545d9c">&#9670;&#160;</a></span>cancelFlashback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDataLayer::cancelFlashback </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cancels the flashback. </p>

</div>
</div>
<a id="a991b7cfea7d673b7b3d9f9f4c64d5cfd" name="a991b7cfea7d673b7b3d9f9f4c64d5cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a991b7cfea7d673b7b3d9f9f4c64d5cfd">&#9670;&#160;</a></span>clearFeatureRendering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::clearFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear feature rendering.</p>
<p>This method removes the rendering style information that has been previously set for a given feature, by one of the 'setFeatureRendering' methods.</p>
<p>When MapLink is rendering a feature, it first looks at whether the entity has an attribute set. If so, then it tries to apply that attribute set and render the entity. If not, then it uses the feature id of the entity to index into the rendering information loaded into the drawing surface. If there is no rendering information in the drawing surface, then it defaults to the rendering information stored with the map.</p>
<p>If an entity has no attribute set or feature id, then the parent is recursively queried for attribute set and feature code.</p>
<p>If neither an entity, nor any of its parents have attribute sets or feature id, then the entity will not be rendered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Feature class name to which the rendering style information is removed. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a8d4acea014d2126ae89eeb777cbebb26" name="a8d4acea014d2126ae89eeb777cbebb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d4acea014d2126ae89eeb777cbebb26">&#9670;&#160;</a></span>createDataHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> * TSLDataLayer::createDataHandler </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>config_file</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a default <a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> object for use with entities contained by this <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>.</p>
<p>If the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> refers to a map the information from the map will determine the information required to create the <a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a>. Otherwise a configuration file must be provided to create the default <a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a>.</p>
<p>The <a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> is required to access any entity specific data which is held externally from the entity in memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config_file</td><td>Name of the configuration file (if any) to use when creating the <a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config_file</td><td>TSLDatahandler. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a02f02a7ea00e2ea18861508ffec7b024" name="a02f02a7ea00e2ea18861508ffec7b024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02f02a7ea00e2ea18861508ffec7b024">&#9670;&#160;</a></span>currentVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a> TSLDataLayer::currentVersion </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the current version of the layer. The default value is 1. </p>

</div>
</div>
<a id="ab8761e162ed667836db6f6ec2f21f1d8" name="ab8761e162ed667836db6f6ec2f21f1d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8761e162ed667836db6f6ec2f21f1d8">&#9670;&#160;</a></span>dataHandler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> * TSLDataLayer::dataHandler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the data handler. </p>

</div>
</div>
<a id="aab86eea288d1ecae6b630954038ba1a2" name="aab86eea288d1ecae6b630954038ba1a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab86eea288d1ecae6b630954038ba1a2">&#9670;&#160;</a></span>dataHandler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> * TSLDataLayer::dataHandler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a const pointer to the data handler. </p>

</div>
</div>
<a id="a4cffcfd0ac1e02c02e845fc46411a25e" name="a4cffcfd0ac1e02c02e845fc46411a25e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cffcfd0ac1e02c02e845fc46411a25e">&#9670;&#160;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDataLayer::destroy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroy method for general data layers. This should be called rather than deleting the data layer, since the calls are redirected internally to MapLink. </p>

</div>
</div>
<a id="ad7c73aeed7bdbabd90e656b4db0d8ecb" name="ad7c73aeed7bdbabd90e656b4db0d8ecb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7c73aeed7bdbabd90e656b4db0d8ecb">&#9670;&#160;</a></span>entityIsVisible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::entityIsVisible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *</td>          <td class="paramname"><span class="paramname"><em>entity</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *</td>          <td class="paramname"><span class="paramname"><em>drawingSurface</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether the given entity from this data layer will be drawn given the entity's rendering attributes and the current configuration of the drawing surface. For this method to return the correct result the following conditions should be true:</p>
<p>1) The entity should have been retrieved from this data layer. 2) This data layer should have already been added to the given drawing surface.</p>
<p>Returns true if the entity will be drawn, false otherwise. Note that the current view extent of the drawing surface is not considered as part of this function, so this method will still return true if the position of the entity is outside this extent. </p>

</div>
</div>
<a id="a194db4f2f5e2c20b9b75285abaa8841b" name="a194db4f2f5e2c20b9b75285abaa8841b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194db4f2f5e2c20b9b75285abaa8841b">&#9670;&#160;</a></span>featureList() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_feature_class_list.html">TSLFeatureClassList</a> * TSLDataLayer::featureList </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query feature list associated with <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>.</p>
<p>This method returns a read-only pointer to the <a class="el" href="class_t_s_l_feature_class_list.html">TSLFeatureClassList</a> attached to the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>. This is embedded within the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> and should not be destroyed by the user. The <a class="el" href="class_t_s_l_feature_class_list.html">TSLFeatureClassList</a> gives a mapping between a feature name and a numeric feature ID.</p>
<p>For TSLMapDataLayers, the feature list is defined by the currently loaded map. When the MapLink Processing Tool creates a '.map' file, it embeds within it the feature classes of the actual features that are within the map.</p>
<p>For TSLStandardDataLayers, the feature list must be created by the user using the 'addFeature' method.</p>
<p>Returns clone of <a class="el" href="class_t_s_l_feature_class_list.html">TSLFeatureClassList</a>, NULL on error. </p>

</div>
</div>
<a id="af587d2e872c15803342eef1973cec1bb" name="af587d2e872c15803342eef1973cec1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af587d2e872c15803342eef1973cec1bb">&#9670;&#160;</a></span>featureList() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_feature_class_list.html">TSLFeatureClassList</a> * TSLDataLayer::featureList </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>detailLayerName</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query feature list associated with <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>.</p>
<p>This has the same functionality as the method of the same name which does not take a parameter, but allows the user to pass in a detail layer name, and so only returns a feature class list detailing those features in the given layer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detailLayerName</td><td>the detail layer name to use as a filter on the features. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8997d0cbd428a6aa9783a4fd45a70cb5" name="a8997d0cbd428a6aa9783a4fd45a70cb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8997d0cbd428a6aa9783a4fd45a70cb5">&#9670;&#160;</a></span>fileModificationTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::fileModificationTime </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTimeType &amp;</td>          <td class="paramname"><span class="paramname"><em>lastModificationTime</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query for the time of the last modification to the given file. If a loader has been added to the layer then that is used, otherwise a blocking loader is created.</p>
<p>If a pathlist has been added to the layer then it is used, otherwise the filename must be fully qualified. In the case of the MapDataLayer, an internal pathlist may also exist, created by loadData; if so then any pathlist added is tried first and then the internal one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file. </td></tr>
    <tr><td class="paramname">lastModificationTime</td><td>A reference to the modification time.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the time could be discovered, false otherwise. </dd></dl>

</div>
</div>
<a id="abfd7da13f831401661e0a63e19c52a64" name="abfd7da13f831401661e0a63e19c52a64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfd7da13f831401661e0a63e19c52a64">&#9670;&#160;</a></span>findEntity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> * TSLDataLayer::findEntity </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>aperture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>drawingSurfaceID</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find nearest entity to a position.</p>
<p>This method allows the user to retrieve an entity from a data layer according to a location. The entity search can be refined by setting the last parameter in the argument list to a valid feature name. In this case an entity will be returned only if it belongs to the named feature.</p>
<p>The <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> returned is embedded within the tile so should not be destroyed by the user unless it is not required. Note that an entity deleted from a MapDataLayer tile may be reloaded when the tile is removed from the cache.</p>
<p>The search algorithm is as follows:</p>
<ul>
<li>Iterate across visible, selectable entities in reverse order (ie. from topmost to bottommost)</li>
<li>For map layers, the detail layer that would be used for drawing the aperture extent is used</li>
<li>All entities whose last rendered extent overlaps the aperture extent are analysed further<ul>
<li>If a feature name is specified, only entities of that feature name are considered</li>
<li>The analysis goes no deeper into the Entity Set hierarchy than specified below</li>
<li>These entities have the distance to the selection point calculated<ul>
<li>If the point is within a polygon, the distance to the polygon is 0.</li>
<li>If the point is within the last rendered extent of a text or symbol entity, the distance to that entity is 0</li>
</ul>
</li>
<li>If the distance is within the aperture distance then the entity is considered a candidate</li>
<li>If any candidate entities are found, then the closest entity in list is returned</li>
<li>Note:<ul>
<li>No check is made for entities being decluttered</li>
<li>Entities drawn last have priority</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>NOTE: When querying an Optimised map the query may return objects that can not be further analysed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y)</td><td>Co-ordinate of the location where to find the entity on the data layer. These co-ordinates are in internal TMC units.</td></tr>
    <tr><td class="paramname">aperture</td><td>This specifies an extent around the location co-ordinate in which to search for the entity. This is in internal TMC units.</td></tr>
    <tr><td class="paramname">depth</td><td>Specifies how deep to look before returning a pointer to an object. If the depth is 0 it searches at the highest level in the model (that is it will return a Group rather than an entity within the Group).</td></tr>
    <tr><td class="paramname">featureName</td><td>If not NULL, the entity returned will be of this feature.</td></tr>
    <tr><td class="paramname">drawingSurfaceID</td><td>ID of drawing surface to use when querying entity extents. This is required when multiple drawingSurfaces are in use and when non-default drawing surface ID's have been used. If the default is used then the extents of symbol and text objects may be defaulted to their origin point. This also has an effect on groups containing such entities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> if found, NULL otherwise. </dd></dl>

</div>
</div>
<a id="afe90ad7a643c8cb39dac461e1ba9d367" name="afe90ad7a643c8cb39dac461e1ba9d367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe90ad7a643c8cb39dac461e1ba9d367">&#9670;&#160;</a></span>findFile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::findFile </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundPath</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search for a file. If a loader has been added to the layer then that is used, otherwise a blocking loader is created.</p>
<p>If a pathlist has been added to the layer then it is used, otherwise the filename must be fully qualified. In the case of the MapDataLayer, an internal pathlist may also exist, created by loadData; if so then any pathlist added is tried first and then the internal one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to search for.</td></tr>
    <tr><td class="paramname">foundPath</td><td>This will be populated with the path that the file is found at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the full path is found, false otherwise. </dd></dl>

</div>
</div>
<a id="ab953980469594aab11575009626c00b3" name="ab953980469594aab11575009626c00b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab953980469594aab11575009626c00b3">&#9670;&#160;</a></span>flashbackToTimestamp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDataLayer::flashbackToTimestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a></td>          <td class="paramname"><span class="paramname"><em>timestamp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#gaf92bab978dd0ee67b6781c3ca417e233">TSLLayerArchiveCallback</a></td>          <td class="paramname"><span class="paramname"><em>archiveCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the version of the layer that is to be loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>The timestamp at which the layer is required. </td></tr>
    <tr><td class="paramname">archiveCallback</td><td>A callback which allows the application to provide the archive location of a layer. If this is 0, then the flashback will not be activated. </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument that will be passed to the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>This call has no effect if no map data has been loaded. Call <a class="el" href="#a996e6ca3e3b9b10fc0f6fbe714a525a0">loadData()</a> before calling flashback().</li>
<li>Both the memory and persistent caches will be cleared. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a4c24847ea318be6604ec34d1d242aa62" name="a4c24847ea318be6604ec34d1d242aa62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c24847ea318be6604ec34d1d242aa62">&#9670;&#160;</a></span>flashbackToTimestamp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDataLayer::flashbackToTimestamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a></td>          <td class="paramname"><span class="paramname"><em>timestamp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga40ea9a3893d69e5865dc7c72f62b9ae2">TSLLayerArchiveTileCallback</a></td>          <td class="paramname"><span class="paramname"><em>archiveTileCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the version of the layer that is to be loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>The timestamp at which the layer is required. </td></tr>
    <tr><td class="paramname">archiveTileCallback</td><td>A callback which allows the application to provide the archive location of a layer. If this is 0, then the flashback will not be activated. </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument that will be passed to the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>This call has no effect if no map data has been loaded. Call <a class="el" href="#a996e6ca3e3b9b10fc0f6fbe714a525a0">loadData()</a> before calling flashback().</li>
<li>Both the memory and persistent caches will be cleared. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="abd072130777b87c3ef6db086749845e5" name="abd072130777b87c3ef6db086749845e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd072130777b87c3ef6db086749845e5">&#9670;&#160;</a></span>flashbackToVersion() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDataLayer::flashbackToVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a></td>          <td class="paramname"><span class="paramname"><em>version</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#gaf92bab978dd0ee67b6781c3ca417e233">TSLLayerArchiveCallback</a></td>          <td class="paramname"><span class="paramname"><em>archiveCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the version of the layer that is to be loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>The version at which the layer is required. </td></tr>
    <tr><td class="paramname">archiveCallback</td><td>A callback which allows the application to provide the archive location of a layer. If this is 0, then the flashback will not be activated. </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument that will be passed to the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>This call has no effect if no map data has been loaded. Call <a class="el" href="#a996e6ca3e3b9b10fc0f6fbe714a525a0">loadData()</a> before calling flashback().</li>
<li>Both the memory and persistent caches will be cleared. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a14e8441c8c13520930ddb118c0fae0c0" name="a14e8441c8c13520930ddb118c0fae0c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e8441c8c13520930ddb118c0fae0c0">&#9670;&#160;</a></span>flashbackToVersion() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDataLayer::flashbackToVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a></td>          <td class="paramname"><span class="paramname"><em>version</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga40ea9a3893d69e5865dc7c72f62b9ae2">TSLLayerArchiveTileCallback</a></td>          <td class="paramname"><span class="paramname"><em>archiveTileCallback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Selects the version of the layer that is to be loaded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>The version at which the layer is required. </td></tr>
    <tr><td class="paramname">archiveTileCallback</td><td>A callback which allows the application to provide the archive location of a layer. If this is 0, then the flashback will not be activated. </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument that will be passed to the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd><ol type="1">
<li>This call has no effect if no map data has been loaded. Call <a class="el" href="#a996e6ca3e3b9b10fc0f6fbe714a525a0">loadData()</a> before calling flashback().</li>
<li>Both the memory and persistent caches will be cleared. </li>
</ol>
</dd></dl>

</div>
</div>
<a id="a9cf439f3ddf34295b02e4a2e31eb1911" name="a9cf439f3ddf34295b02e4a2e31eb1911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf439f3ddf34295b02e4a2e31eb1911">&#9670;&#160;</a></span>getActiveLayerName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::getActiveLayerName </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>screenResolution</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>activeLayerName</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is called when the Drawing Surface needs to know what active layer the application will be drawing for a given extent and drawing surface resolution.</p>
<p>The activeLayerName is basically a name given to a particular level of data (detail layer) being displayed, for example;</p>
<p>if you have several different scales to display with different data, you would return a different name for each scale (detail layer).</p>
<p>This allows the drawing surface the ability to detect when it needs to throw away any cached detail-layer specific tile data. This affects the Accelerator and 3D drawing surfaces.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>extent of the area that is being queried</td></tr>
    <tr><td class="paramname">screenResolution</td><td>The TMC units per Device Unit.</td></tr>
    <tr><td class="paramname">activeLayerName</td><td>The layer name for the extent and screenResolution is returned in this parameter.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>, true ok, false if we fail. </dd></dl>

</div>
</div>
<a id="a37b71c959052cf95ffcdbd00d0912603" name="a37b71c959052cf95ffcdbd00d0912603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37b71c959052cf95ffcdbd00d0912603">&#9670;&#160;</a></span>getCoordinateSystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> * TSLDataLayer::getCoordinateSystem </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query for the coordinate system used by this layer to convert between map units and lat/long.</p>
<p>This method requests the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> to return a <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> object which allows the user to access information concerning the transforms used to create the map.</p>
<p>The method has slightly different behaviour depending on which type of <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> derived class the layer is. Typically this method will return the coordinate system of any data loaded into the layer.</p>
<p>Some layers allow the application to set a coordinate system, which will affect how the data is displayed within the drawing surface.</p>
<p>The behaviour of this method when called for a <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> is as follows:</p><ul>
<li>The <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> is only valid as long as no new map has been loaded into the layer since last obtaining the component.</li>
<li>If runtime projection is in use, this will be the same object as returned from queryRuntimeCoordinateSystem() on the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a>.</li>
<li>If runtime projection is not in use, this will be the same object as returned from queryMapCoordinateSystem().</li>
</ul>
<p>The <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> returned by this method should not be modified. If you need to modify the coordinate system take a clone and modify the clone.</p>
<dl class="section return"><dt>Returns</dt><dd>The <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> of the data, or as set by the user. NULL is returned to indicate that the layer does not have a <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a>. </dd></dl>

</div>
</div>
<a id="ad62b5809179e31d019dec790177d42a6" name="ad62b5809179e31d019dec790177d42a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62b5809179e31d019dec790177d42a6">&#9670;&#160;</a></span>getEntityIterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_entity_iterator.html">TSLEntityIterator</a> * TSLDataLayer::getEntityIterator </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>detailLayer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_selector.html">TSLSelector</a> *</td>          <td class="paramname"><span class="paramname"><em>selector</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> *</td>          <td class="paramname"><span class="paramname"><em>extent</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>splitOptimisedPrimitives</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a <a class="el" href="class_t_s_l_entity_iterator.html">TSLEntityIterator</a> which allows a user to iterate through the entities in a layer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">detailLayer</td><td>the name of the detail layer to return entities from.</td></tr>
    <tr><td class="paramname">selector</td><td>A selector to chose which entities are to be returned - if NULL then all entities are returned.</td></tr>
    <tr><td class="paramname">extent</td><td>A <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> within which to return entities - if NULL all entities are returned.</td></tr>
    <tr><td class="paramname">splitOptimisedPrimitives</td><td>should Optimised Entities be split into primitives or not</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>an iterator. If the returned value is NULL then this concept is not supported by the layer. </dd></dl>

</div>
</div>
<a id="a6a98dc01354ecec9c65eac5de8795e59" name="a6a98dc01354ecec9c65eac5de8795e59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a98dc01354ecec9c65eac5de8795e59">&#9670;&#160;</a></span>getFeatureRendering() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::getFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a></td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets rendering for a specified feature class.</p>
<p>For further information about the attributes available, see the setRendering methods on <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">attribute</td><td>Type of rendering attribute to get</td></tr>
    <tr><td class="paramname">result</td><td>Storage for returned rendering attribute value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attribute successfully read and stored in result, false otherwise. </dd></dl>

</div>
</div>
<a id="af0232b2f236064f89665f1776dca140b" name="af0232b2f236064f89665f1776dca140b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0232b2f236064f89665f1776dca140b">&#9670;&#160;</a></span>getFeatureRendering() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::getFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a></td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets rendering for a specified feature class.</p>
<p>For further information about the attributes available, see the setRendering methods on <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">attribute</td><td>Type of rendering attribute to get</td></tr>
    <tr><td class="paramname">result</td><td>Storage for returned rendering attribute value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attribute successfully read and stored in result, false otherwise. </dd></dl>

</div>
</div>
<a id="a75b6bf865d0afde06a262fc7fb0edc43" name="a75b6bf865d0afde06a262fc7fb0edc43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b6bf865d0afde06a262fc7fb0edc43">&#9670;&#160;</a></span>getFeatureRendering() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::getFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a></td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets rendering for a specified feature class.</p>
<p>For further information about the attributes available, see the setRendering methods on <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">attribute</td><td>Type of rendering attribute to get</td></tr>
    <tr><td class="paramname">result</td><td>Storage for returned rendering attribute value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attribute successfully read and stored in result, false otherwise. </dd></dl>

</div>
</div>
<a id="a3fae08a54978e8e2b0aa2344caeedf2d" name="a3fae08a54978e8e2b0aa2344caeedf2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fae08a54978e8e2b0aa2344caeedf2d">&#9670;&#160;</a></span>getFeatureRendering() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::getFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets rendering for a specified feature class.</p>
<p>Where possible, it is more efficient for an application to use the featureID directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">result</td><td>Storage for returned rendering attribute values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attributes successfully read and stored in result, false otherwise. </dd></dl>

</div>
</div>
<a id="a35de696e1cd209e428c8da6c2f4e300b" name="a35de696e1cd209e428c8da6c2f4e300b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35de696e1cd209e428c8da6c2f4e300b">&#9670;&#160;</a></span>getLoader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> * TSLDataLayer::getLoader </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns either the loader added by addLoader or the default static loader. If no static loader exists it is created. </p>

</div>
</div>
<a id="a34074a432614a62093d349838dcdbfd2" name="a34074a432614a62093d349838dcdbfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34074a432614a62093d349838dcdbfd2">&#9670;&#160;</a></span>getMUExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::getMUExtent </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>drawingSurfaceID</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the Map Unit extent of the layer.</p>
<p>This method requests the full extent of the area covered by the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Storage for bottom left co-ordinate of the extent.</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for top right co-ordinate of the extent.</td></tr>
    <tr><td class="paramname">drawingSurfaceID</td><td>ID of drawing surface to use when querying entity extents. If the default is used then the extents of symbol and text objects may be defaulted to their origin point. This also has an effect on groups containing such entities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the layer is not a coordinate providing layer (e.g. if the layer is a <a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a>) or has no data loaded, this method false. </dd></dl>

</div>
</div>
<a id="a7677906c203b52b4dde95807202e21f2" name="a7677906c203b52b4dde95807202e21f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7677906c203b52b4dde95807202e21f2">&#9670;&#160;</a></span>getTMCExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::getTMCExtent </td>
          <td>(</td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>drawingSurfaceID</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query for TMC extent of data.</p>
<p>This method requests the full extent of the area covered by the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>. The returned values will be in internal TMC co-ordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Storage for bottom left co-ordinate of the extent.</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for top right co-ordinate of the extent.</td></tr>
    <tr><td class="paramname">drawingSurfaceID</td><td>ID of drawing surface to use when querying entity extents. If the default is used then the extents of symbol and text objects may be defaulted to their origin point. This also has an effect on groups containing such entities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false if no data is loaded. </dd></dl>

</div>
</div>
<a id="ab0bf18c76d0d8c476eb5ce835f16b69f" name="ab0bf18c76d0d8c476eb5ce835f16b69f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bf18c76d0d8c476eb5ce835f16b69f">&#9670;&#160;</a></span>getUUExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::getUUExtent </td>
          <td>(</td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *</td>          <td class="paramname"><span class="paramname"><em>drawingSurface</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query extent in user units.</p>
<p>This method requests the full extent of the area covered by the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>. The returned values will be in user units.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>Storage for bottom left co-ordinate of the extent.</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for top right co-ordinate of the extent.</td></tr>
    <tr><td class="paramname">drawingSurface</td><td><a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> to which the Data Layer is attached. This is necessary since each drawingSurface that the Data Layer is attached to may have different User Unit specifications.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false if no data is loaded. </dd></dl>

</div>
</div>
<a id="a43f186469525c8fb0b4cc9c415546492" name="a43f186469525c8fb0b4cc9c415546492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f186469525c8fb0b4cc9c415546492">&#9670;&#160;</a></span>importHistory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::importHistory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a></td>          <td class="paramname"><span class="paramname"><em>mapVersion</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a></td>          <td class="paramname"><span class="paramname"><em>timestamp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_history_import_set.html">TSLHistoryImportSet</a> *</td>          <td class="paramname"><span class="paramname"><em>historySet</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method allows importing of history into a map without the associated import of data. This means that map versions and their corresponding timestamps can be added and retrieved via the vesionHistory and queryVersionHistory methods without needing to update the contents of the map and checkpoint each version.</p>
<p>Calling this method multiple times for the same version will append the additional information to any existing history information.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapVersion</td><td>The version to use for the layer. </td></tr>
    <tr><td class="paramname">timestamp</td><td>The timestamp to associate with this version. </td></tr>
    <tr><td class="paramname">historySet</td><td>A list of tile history information to import into the map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a242fafc67323bf7489430a1b1cf20a15" name="a242fafc67323bf7489430a1b1cf20a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242fafc67323bf7489430a1b1cf20a15">&#9670;&#160;</a></span>latLongToTMC() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::latLongToTMC </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>latitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>longitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from latitude/longitude to internal TMC co-ordinate.</p>
<p>This operation will use the current Coordinate System to perform the conversion. This will usually be defined only for TSLMapDatalayers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(latitude,longitude)</td><td>Point to convert.</td></tr>
    <tr><td class="paramname">(x,y)</td><td>Storage for internal TMC co-ordinate.</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the latitude and longitude are in the local datum, or WGS84.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a049b9cb6c75049b976a44a63a4fda83f" name="a049b9cb6c75049b976a44a63a4fda83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049b9cb6c75049b976a44a63a4fda83f">&#9670;&#160;</a></span>latLongToTMC() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::latLongToTMC </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>latitudes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>longitudes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>xs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>ys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from latitude/longitude to internal TMC co-ordinates.</p>
<p>This operation will use the current Coordinate System to perform the conversion. This will usually be defined only for TSLMapDatalayers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(num)</td><td>Number of points to convert</td></tr>
    <tr><td class="paramname">(latitudes,longitudes)</td><td>Arrays of points to convert.</td></tr>
    <tr><td class="paramname">(xs,ys)</td><td>Storage array for internal TMC co-ordinates. The arrays should be large enough to hold num elements.</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the latitude and longitude are in the local datum, or WGS84.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all co-ordinates successfully transformed, false otherwise. </dd></dl>

</div>
</div>
<a id="acc060243cb1337c3b8709c1cec683720" name="acc060243cb1337c3b8709c1cec683720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc060243cb1337c3b8709c1cec683720">&#9670;&#160;</a></span>layerType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apigroup__api.html#gaf8bedcb6358f6ef60075d2bbca8fe118">TSLDataLayerTypeEnum</a> TSLDataLayer::layerType </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the type of this <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>. For more information see the documentation for the <a class="el" href="group__apigroup__api.html#gaf8bedcb6358f6ef60075d2bbca8fe118">TSLDataLayerTypeEnum</a> enumeration. </p>

</div>
</div>
<a id="a996e6ca3e3b9b10fc0f6fbe714a525a0" name="a996e6ca3e3b9b10fc0f6fbe714a525a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996e6ca3e3b9b10fc0f6fbe714a525a0">&#9670;&#160;</a></span>loadData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::loadData </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load data from a file for the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>. The filename should either be fully qualified or should be found using a pathlist added with addPathList.</p>
<p>If data is already loaded into this <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> then it will be removed from memory and all references to it deleted.</p>
<p>For a <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a>, the file should be a '.map' file, usually generated by the MapLink Processing Tool. If no pathlist has been added with addPathList, then an internal pathlist is created, initialised to the root path of the map file given, and will be used to find map data. It is initialised from the pathlist file associated with the map file, if present. In this case, the palette file associated with the map will also be loaded.</p>
<p>For a <a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a>, the file should be a '.tmf' file.</p>
<p>For a <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a> this method will return false. Files must first be analysed using <a class="el" href="class_t_s_l_direct_import_data_layer.html#aed4b5b513fd02cc2fe98eb78ad2c4d55">TSLDirectImportDataLayer::createDataSets</a> and may then be loaded through <a class="el" href="class_t_s_l_direct_import_data_layer.html#a1a96e295488d4c0ac7f397b8154fb762">TSLDirectImportDataLayer::loadData</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the file from which to load the data.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success , false otherwise. </dd></dl>

</div>
</div>
<a id="ad5882d7ca1362bf7dce2ceff2e08d5b1" name="ad5882d7ca1362bf7dce2ceff2e08d5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5882d7ca1362bf7dce2ceff2e08d5b1">&#9670;&#160;</a></span>loadRendering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::loadRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load feature rendering file. The filename should either be fully qualified or should be found using a pathlist added with addPathList.</p>
<p>This method allows the user to load a set of rendering data from a given file. Each <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> may, optionally, render data types in different ways from another <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>.</p>
<p>When MapLink is rendering a feature, it first looks at whether the entity has an attribute set. If so, then it tries to apply that attribute set and render the entity. If not, then it uses the feature id of the entity to index into the rendering information loaded into the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. If there is no rendering information in the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>, then it defaults to the rendering information stored with the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>.</p>
<p>If an entity has no attribute set or feature id, then the parent is recursively queried for attribute set and feature code.</p>
<p>If neither an entity, nor any of its parents have attribute sets or feature id, then the entity will not be rendered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the rendering data file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if file successfully loaded, false otherwise. </dd></dl>

</div>
</div>
<a id="a05b87a4127970755ed66caaf44e48de9" name="a05b87a4127970755ed66caaf44e48de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05b87a4127970755ed66caaf44e48de9">&#9670;&#160;</a></span>notifyChanged()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDataLayer::notifyChanged </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>changed</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Notifies the data layer that its contents have been changed.</p>
<p>If the data layer contents change (e.g. objects move in a <a class="el" href="class_t_s_l_object_data_layer.html">TSLObjectDataLayer</a>) then by calling this method, clients will ensure that a subsequent 'draw' on the drawing surface will force the updated contents to be correctly displayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">changed</td><td>true (default), if layer contents have changed, false otherwise. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1794ff9ca4ebbea2ee17986729de0b3c" name="a1794ff9ca4ebbea2ee17986729de0b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1794ff9ca4ebbea2ee17986729de0b3c">&#9670;&#160;</a></span>query() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> * TSLDataLayer::query </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>drawingSurfaceID</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query for entities in extent.</p>
<p>The detail layer used is chosen by the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a>, based on the extent.</p>
<p>This method requests the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> to return a <a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> object which allows the user to access the data tiles required for the display of the specified area. The <a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> for a <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> is only valid for immediate use since the data tiles to which they refer may be removed from memory if the cache is flushed.</p>
<p>In the default case, all tiles whose extent intersects the specified extent will be returned. These will include all entities within those tiles, even though some individual entities may not be within the extent.</p>
<p>Alternatively, if a depth is specified, then the query recurses into the tiles and returns only those individual entities that intersect the region. An optional feature name may also be specified.</p>
<p>Please note: The query function will not flush the cache if the cache limit is exceeded. Thus, if you are performing repetitive queries in a tight loop, where each query is requesting a different geographic region and returning large amounts of data, it is recommended to periodically call clearCache() yourself to ensure that the cache limit is not exceeded. Failure to do so may result in out of memory in extreme cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>The bottom left co-ordinate of the specified area (in internal TMC units)</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>the top right co-ordinate of the specified area (in internal TMC units)</td></tr>
    <tr><td class="paramname">depth</td><td>Specifies how deep to look before returning a pointer to an object. If the depth is -1, then all entities are returned. If the depth is 0 it searches at the highest level in the tile (that is it may return a Group rather than an entity within the Group). Pass a large number, such as 9999, if individual entities are required.</td></tr>
    <tr><td class="paramname">featureName</td><td>If not NULL, only entities of this feature name will be checked.</td></tr>
    <tr><td class="paramname">drawingSurfaceID</td><td>ID of drawing surface to use when querying entity extents. This is required when multiple drawingSurfaces are in use and when non-default drawing surface ID's have been used. If the default is used then the extents of symbol and text objects may be defaulted to their origin point. This also has an effect on groups containing such entities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to a <a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> object. If NULL, it indicates that no tiles were found for the specified area. </dd></dl>

</div>
</div>
<a id="a80490627af3ab4871812115802c56359" name="a80490627af3ab4871812115802c56359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80490627af3ab4871812115802c56359">&#9670;&#160;</a></span>query() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> * TSLDataLayer::query </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_selector.html">TSLSelector</a> *</td>          <td class="paramname"><span class="paramname"><em>selector</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>drawingSurfaceID</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query for entities in extent based on a client-supplied search criteria.</p>
<p>The detail layer used is chosen by the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a>, based on the extent.</p>
<p>This method requests the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> to return a <a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> object which allows the user to access the data tiles required for the display of the specified area. The <a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> for a <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> is only valid for immediate use since the data tiles to which they refer may be removed from memory if the cache is flushed.</p>
<p>The client must specify the selection policy through a suitable TSLSelector-derived object.</p>
<p>NOTE: When querying an Optimised map the query may return objects that can not be further analysed.</p>
<p>Please note: The query function will not flush the cache if the cache limit is exceeded. Thus, if you are performing repetitive queries in a tight loop, where each query is requesting a different geographic region and returning large amounts of data, it is recommended to periodically call clearCache() yourself to ensure that the cache limit is not exceeded. Failure to do so may result in out of memory in extreme cases.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x1,y1)</td><td>The bottom left co-ordinate of the specified area (in internal TMC units)</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>the top right co-ordinate of the specified area (in internal TMC units)</td></tr>
    <tr><td class="paramname">selector</td><td>pointer to a TSLSelector-derived object which specifies the selection criteria.</td></tr>
    <tr><td class="paramname">drawingSurfaceID</td><td>ID of drawing surface to use when querying entity extents. This is required when multiple drawingSurfaces are in use and when non-default drawing surface ID's have been used. If the default is used then the extents of symbol and text objects may be defaulted to their origin point. This also has an effect on groups containing such entities.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the query results. </dd></dl>

</div>
</div>
<a id="a36ad614ec1fb35434810d08e6a8ba8b5" name="a36ad614ec1fb35434810d08e6a8ba8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ad614ec1fb35434810d08e6a8ba8b5">&#9670;&#160;</a></span>queryVersionHistory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::queryVersionHistory </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_version_history_set.html">TSLVersionHistorySet</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>history</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the version history for the given area.</p>
<p>For each tile that overlaps the given area, query its version history. If the associated change area overlaps the given area, add the history to the given version history set.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>The area that is being queried. </td></tr>
    <tr><td class="paramname">history</td><td>The resulting version history for the area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the change area has any history, false otherwise. </dd></dl>

</div>
</div>
<a id="aad29ab355dbb41a0fcd809dcc7b11337" name="aad29ab355dbb41a0fcd809dcc7b11337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad29ab355dbb41a0fcd809dcc7b11337">&#9670;&#160;</a></span>refreshFlashback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDataLayer::refreshFlashback </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Refreshes the history information. </p>

</div>
</div>
<a id="ac4f727d73219da9ab2b94e0329a74607" name="ac4f727d73219da9ab2b94e0329a74607"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4f727d73219da9ab2b94e0329a74607">&#9670;&#160;</a></span>releaseResources()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDataLayer::releaseResources </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>surfaceID</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is for use when an Optimised Drawing Surface is used (future capability).</p>
<p>This method should be called when the Drawing Surface invalidates its native drawing resources.</p>
<p>This method only needs to be called if the layer is contained by a class which has been derived from <a class="el" href="class_t_s_l_client_custom_data_layer.html">TSLClientCustomDataLayer</a>.</p>
<p>This method does not need to be called if the layer has been added to a drawing surface or the layer has not been used for drawing.</p>
<p>The user should call this method from the <a class="el" href="class_t_s_l_client_custom_data_layer.html#ae5cad762a6345cf1a5231f8277f5dbff">TSLClientCustomDataLayer::releaseResources</a> method passing through the surfaceID.</p>
<p>The method should only be called from the same thread the Drawing Surface is being used in (Graphics API context issues).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surfaceID</td><td>A unique surface number. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7de8beee6ba358591a22c0a2dd567a0" name="ab7de8beee6ba358591a22c0a2dd567a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7de8beee6ba358591a22c0a2dd567a0">&#9670;&#160;</a></span>removeData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::removeData </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method allows the user to remove data from memory.</p>
<p>Clears all data attached to this <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>, rendition classes etc.</p>
<p>Returns true on success , false otherwise. </p>

</div>
</div>
<a id="a7b668fab4184d186d48ba860b7ca41ab" name="a7b668fab4184d186d48ba860b7ca41ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b668fab4184d186d48ba860b7ca41ab">&#9670;&#160;</a></span>saveRendering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::saveRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a></td>          <td class="paramname"><span class="paramname"><em>ver</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__apigroup__common.html#gga8141b1e165228e088c49024076e13758a0ecdea6c91f1d3104d6166d69b57c88d">TSL_CURRENT_MAPLINK_VERSION</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save rendering file.</p>
<p>This method allows any rendering information that the user has set up for a <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> to be saved to the specified file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the rendering data file.</td></tr>
    <tr><td class="paramname">ver</td><td>MapLink version to save as</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success , false otherwise. </dd></dl>

</div>
</div>
<a id="a8c58b8475acb63c5a3f031e0cac28449" name="a8c58b8475acb63c5a3f031e0cac28449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c58b8475acb63c5a3f031e0cac28449">&#9670;&#160;</a></span>setCoordinateSystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::setCoordinateSystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *</td>          <td class="paramname"><span class="paramname"><em>coordinateSystem</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method setCoordinateSystem sets the <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> on the layer for use by the coordinate conversion methods.</p>
<p>The method can not set a <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> on a layer that has one automatically created, such as a <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a>.</p>
<p>The <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> that is set via this method is not currently saved when the layer is saved.</p>
<p><a class="el" href="class_t_s_l_filter_data_layer.html">TSLFilterDataLayer</a> behaviour differences</p><ul>
<li>The method sets the output coordinate system to use to project the data loaded on the data layer.</li>
<li>By passing NULL to this method then the default coordinate system will be used.</li>
<li>Changing the output coordinate system will cause all display items to require re-processing.</li>
</ul>
<p><a class="el" href="class_t_s_l_k_m_l_data_layer.html">TSLKMLDataLayer</a> behaviour differences</p><ul>
<li>Coordinates in KML are stored as latitude/longitude/altitude, and must be converted on load in order to display correctly on top of a coordinate providing layer.</li>
<li>Because of this, the layer must have a coordinate system before loading any data.</li>
<li>The layer will use this coordinate system if present, or if not will use the coordinate system from the drawing surface.</li>
</ul>
<p><a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a> behaviour differences</p><ul>
<li>All data loaded into the layer will be reprojected into this coordinate system before it is displayed.</li>
<li>This coordinate system may only be set once. To change it the application must create a new <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a>.</li>
<li>The provided coordinate system must have an appropriate TMC per MU value set.<ul>
<li>For coordinate systems in meters, 50 TMC per MU is recommended.</li>
<li>For coordinate systems in lat/lon, 5,000,000 TMC per MU is recommended.</li>
</ul>
</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">coordinateSystem</td><td>the <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> to use. A clone is taken of the coordinateSystem. If the parameter is NULL the current user set <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> is deleted.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the coordinateSystem has been set, false otherwise. </dd></dl>

</div>
</div>
<a id="a1527856e58de4618ad218424738c6986" name="a1527856e58de4618ad218424738c6986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1527856e58de4618ad218424738c6986">&#9670;&#160;</a></span>setFeatureRendering() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::setFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a></td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets rendering for a specified feature class.</p>
<p>For further information about the attributes available, see the setRendering methods on <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">attribute</td><td>Type of rendering attribute to set</td></tr>
    <tr><td class="paramname">value</td><td>New value for rendering attribute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attribute successfully set, false otherwise. </dd></dl>

</div>
</div>
<a id="a01692e748c350a23675ad3d78807e684" name="a01692e748c350a23675ad3d78807e684"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01692e748c350a23675ad3d78807e684">&#9670;&#160;</a></span>setFeatureRendering() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::setFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a></td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets rendering for a specified feature class.</p>
<p>For further information about the attributes available, see the setRendering methods on <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">attribute</td><td>Type of rendering attribute to set</td></tr>
    <tr><td class="paramname">value</td><td>New value for rendering attribute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attribute successfully set, false otherwise. </dd></dl>

</div>
</div>
<a id="a15b60a990c7763ccb582dc2b59aa769f" name="a15b60a990c7763ccb582dc2b59aa769f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b60a990c7763ccb582dc2b59aa769f">&#9670;&#160;</a></span>setFeatureRendering() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::setFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a></td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets rendering for a specified feature class.</p>
<p>For further information about the attributes available, see the setRendering methods on <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">attribute</td><td>Type of rendering attribute to set</td></tr>
    <tr><td class="paramname">value</td><td>New value for rendering attribute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attribute successfully set, false otherwise. </dd></dl>

</div>
</div>
<a id="a74ac4671ad4be33730b564240532754b" name="a74ac4671ad4be33730b564240532754b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ac4671ad4be33730b564240532754b">&#9670;&#160;</a></span>setFeatureRendering() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::setFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets rendering for a specified feature class.</p>
<p>Where possible, it is more efficient for an application to use the featureID directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">value</td><td>New value for rendering attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attributes successfully set, false otherwise. </dd></dl>

</div>
</div>
<a id="a568048fa9c27f7100df84bb1d08524fa" name="a568048fa9c27f7100df84bb1d08524fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a568048fa9c27f7100df84bb1d08524fa">&#9670;&#160;</a></span>TMCToLatLong() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::TMCToLatLong </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>num</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>xs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>ys</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>latitudes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>longitudes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts set of points from internal TMC co-ordinate to latitude/longitude.</p>
<p>This operation will use the current Coordinate System to perform the conversion. This will usually be defined only for TSLMapDatalayers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(num)</td><td>Number of points to convert</td></tr>
    <tr><td class="paramname">(xs,ys)</td><td>Arrays of internal TMC co-ordinates of the points to convert.</td></tr>
    <tr><td class="paramname">latitudes</td><td>Storage for latitudes of the points. Should be large enough to hold num values.</td></tr>
    <tr><td class="paramname">longitudes</td><td>Storage for longitudes of the points. Should be large enough to hold num values.</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the latitude and longitude are in the local datum, or WGS84.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if all co-ordinates are successfully transformed, false otherwise. </dd></dl>

</div>
</div>
<a id="a4ab580b6f9a6e8a6615937256304489f" name="a4ab580b6f9a6e8a6615937256304489f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab580b6f9a6e8a6615937256304489f">&#9670;&#160;</a></span>TMCToLatLong() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDataLayer::TMCToLatLong </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>latitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>longitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>local</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>boundCheck</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert from internal TMC co-ordinate to latitude/longitude.</p>
<p>This operation will use the current Coordinate System to perform the conversion. This will usually be defined only for TSLMapDatalayers.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y)</td><td>Internal TMC co-ordinate of the point to convert.</td></tr>
    <tr><td class="paramname">latitude</td><td>Storage for latitude of the point</td></tr>
    <tr><td class="paramname">longitude</td><td>Storage for longitude of the point</td></tr>
    <tr><td class="paramname">local</td><td>Indicates whether the latitude and longitude are in the local datum, or WGS84.</td></tr>
    <tr><td class="paramname">boundCheck</td><td>If true, the function will fail if the calculated values are outside the valid Latitude/Longitude range</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a19803bde4b29d406445dd7a4b9aab850" name="a19803bde4b29d406445dd7a4b9aab850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19803bde4b29d406445dd7a4b9aab850">&#9670;&#160;</a></span>versionHistory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_version_history_set.html">TSLVersionHistorySet</a> * TSLDataLayer::versionHistory </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the layer for its version history set. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.1.1.0. | Documentation created Fri Feb 14 2025 19:42:19 | Generated with <a href="http://www.doxygen.org/index.html">Doxygen 1.13.2</a> | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
