<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLDirectImportDataLayer Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.2</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_direct_import_data_layer.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_t_s_l_direct_import_data_layer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLDirectImportDataLayer Class Reference<div class="ingroups"><a class="el" href="group__apigroup__maplink__pro__developers__toolkit.html">MapLink Pro Developer Toolkit</a> &raquo; <a class="el" href="group__group__directimport.html">Direct Import API</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for TSLDirectImportDataLayer:</div>
<div class="dyncontent">
<div class="center"><img src="class_t_s_l_direct_import_data_layer__inherit__graph.png" border="0" usemap="#a_t_s_l_direct_import_data_layer_inherit__map" alt="Inheritance graph"/></div>
<map name="a_t_s_l_direct_import_data_layer_inherit__map" id="a_t_s_l_direct_import_data_layer_inherit__map">
<area shape="rect" title=" " alt="" coords="5,76,155,99"/>
<area shape="rect" href="class_t_s_l_data_layer.html" title=" " alt="" coords="35,5,125,28"/>
<area shape="poly" title=" " alt="" coords="83,41,83,76,77,76,77,41"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This data layer allows direct loading of geospatial data.</p>
<h1><a class="anchor" id="autotoc_md77"></a>
Supported Data Formats</h1>
<p>The <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a> does not impose any restrictions on file formats. Instead these are determined by the available implementations of <a class="el" href="class_t_s_l_direct_import_driver.html">TSLDirectImportDriver</a>.</p>
<p>A list of formats supported by Envitia please see the MapLink Pro Developer's Guide.</p>
<p>Each <a class="el" href="class_t_s_l_direct_import_driver.html">TSLDirectImportDriver</a> may support a range of configuration options. These options may be set globally via the configuration files under the MapLink config directory/directimport.</p>
<h1><a class="anchor" id="autotoc_md78"></a>
Data Layout and scale bands</h1>
<p>The <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a> may load a mixture of raster and vector data, which may be displayed in any order.</p>
<p>One data path (a file path, web service URL or other data identifier) may correspond to multiple instances of <a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a>, with each data set corresponding to a sub-layer within the data. Simple formats such as shapefiles will only contain a single dataset, which will correspond to the vector feature within the data. These data sets are handled independently of each other, and as such may be loaded on a selective basis. Data sets may also be loaded with different per-dataset settings such as feature rendering, and raster adjustments.</p>
<p>In order to load a data set, the application must call addScaleBand at least once. Each scale band within the data layer functions in a similar way to detail layers in a map, or layers within a MapLink Studio project.</p><ul>
<li>Only one scale band will be displayed by the data layer at a time.</li>
<li>The selection of scale bands is based upon a calculated display scale, such as 1:100,000. In order for this to be accurate the application should set the parameters of the display via TSLDrawingSurfaceBase::setDeviceCapabilities. On some platforms these capabilities may be set automatically by the drawing surface.</li>
<li>A data set may be loaded into multiple scale bands. This may be used to display data as a background for all display scales. For raster data, overview datasets may be loaded if present in the original data. These are reduced resolution versions of the data set suitable for loading into overview layers.</li>
<li>Data loaded into a scale band will be split into tiles for processing/display. These tiling levels may either be set by the application, or calculated automatically. The automatic tiling calculation is based upon the minimum display scale of the band, and will create more tiles for more detailed scales. Applications must ensure that data is loaded at an appropriate scale in order to maintain performance.</li>
</ul>
<h1><a class="anchor" id="autotoc_md79"></a>
Data Processing and Display</h1>
<p>When a data set is loaded into the layer it will be split into a number of tiles (based on the scale band configuration), and processed asynchronously by default. Once a tile has been processed it will be stored in the on disk cache, and displayed. If the data needs to be reloaded after this point it will be loaded from the on disk cache.</p>
<p>Data will be scheduled for loading based on the current view extent, and the extentExpansion setting of the layer. The application may also request that a specific extent be processed, by calling preprocessData.</p>
<p>Complex vector data, or large amounts of raster data may take a long time to process. It is advisable to call preprocessData for these datasets prior to the point they need to be displayed in order to pre-process the data into the on disk cache.</p>
<p>If enabled via <a class="el" href="class_t_s_l_drawing_surface_base.html#afe537ed2746b65ecf6349f9efd967173">TSLDrawingSurfaceBase::setDataLayerProps</a>, progressive display will be enabled for the following dataset types:</p><ul>
<li><a class="el" href="class_t_s_l_direct_import_data_set_multi_level_raster.html">TSLDirectImportDataSetMultiLevelRaster</a></li>
</ul>
<p>If enabled via <a class="el" href="#a2f1410e04c8d61d943e1fbe5dd59e8a9">TSLDirectImportDataLayer::synchronousDisplay</a>, data will not be processed asynchronously, and will instead load all data within the view extent before drawing it.</p>
<h1><a class="anchor" id="autotoc_md80"></a>
Callbacks</h1>
<p>The <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a> is fully asynchronous by default, and will rarely block the calling thread for any significant amount of time.</p>
<p>In order to achieve this the following callback classes are provided:</p><ul>
<li><a class="el" href="class_t_s_l_direct_import_data_layer_callbacks.html">TSLDirectImportDataLayerCallbacks</a> - The application should always provide an implementation of this class. It provides the application with feedback on data processing, and is used to request that the application redraws the drawing surface.</li>
<li><a class="el" href="class_t_s_l_direct_import_data_layer_analysis_callbacks.html">TSLDirectImportDataLayerAnalysisCallbacks</a> - The application should provide an implementation of this class when performing data analysis operations. An implementation of this class is not required when loading data for display.</li>
</ul>
<h1><a class="anchor" id="autotoc_md81"></a>
Vector specific settings and styling</h1>
<p>Other than styling/feature rendering information, vector specific settings are provided via <a class="el" href="class_t_s_l_direct_import_vector_settings.html">TSLDirectImportVectorSettings</a>.</p>
<p>Styling information for vector data is provided as a <a class="el" href="class_t_s_l_feature_class_config.html">TSLFeatureClassConfig</a>. This information may be set on a per data set basis, and may include rendering specific to each scale band. A feature configuration may be created through the MapLink API, or by exporting a MapLink Studio feature book.</p>
<p>The <a class="el" href="class_t_s_l_feature_class_config.html">TSLFeatureClassConfig</a> and associated classes provide many of the concepts used by MapLink Studio, including:</p><ul>
<li>A hierarchical list of features</li>
<li>Different configuration for features based on product specification/detail level. When used in the Direct Import SDK, product specifications must be set on the dataset prior to loading via <a class="el" href="class_t_s_l_direct_import_data_set.html#a901aae36d7b92ccd3ed38391015d5f36">TSLDirectImportDataSet::product</a>.</li>
<li>Feature masking</li>
<li>Automatic feature classification, for example with either a single feature per attribute value or classification based on a range of values</li>
<li>Multiple levels of feature classification</li>
<li>Text label generation based on attribute values</li>
</ul>
<h2><a class="anchor" id="autotoc_md82"></a>
Data Analysis</h2>
<p>The direct import layer provides functionality to analyse a dataset and produce an initial <a class="el" href="class_t_s_l_feature_class_config.html">TSLFeatureClassConfig</a>. This will populate the feature configuration with a list of features found in the data.</p>
<p>If present in the data, and supported by the direct import driver, the feature configuration may include feature classification, masking and rendering information.</p>
<p>This analysis can often take a long time as it requires iterating over all of the source data. This should be performed as an offline process, in order to produce a feature configuration for the data or product. Alternatively the feature configuration may be exported from the MapLink Studio feature book.</p>
<h2><a class="anchor" id="autotoc_md83"></a>
Data Attributes</h2>
<p>In a similar fashion to MapLink Studio, the Direct Import layer will preserve attributes present in the source data. These may be accessed through the <a class="el" href="class_t_s_l_data_set.html">TSLDataSet</a> class in a similar manner to other MapLink layers.</p>
<p>However:</p><ul>
<li>Where other layer types have a single data handler, the Direct Import layer will have many (At least one per dataset).</li>
<li>As such, calling <a class="el" href="class_t_s_l_data_layer.html#ab8761e162ed667836db6f6ec2f21f1d8">TSLDataLayer::dataHandler</a> on this layer will always return null.</li>
<li>The data handler for each dataset may be accessed via <a class="el" href="class_t_s_l_data_set.html#ac25cc8e778f82f73b7b2a857669bdefd">TSLDataSet::dataHandler</a>. Information about attribute fields should be read through the <a class="el" href="class_t_s_l_data_set.html">TSLDataSet</a> class.#</li>
</ul>
<h1><a class="anchor" id="autotoc_md84"></a>
Raster specific settings</h1>
<p>Any raster specific settings for a data set are provided via <a class="el" href="class_t_s_l_direct_import_raster_settings.html">TSLDirectImportRasterSettings</a>.</p>
<h1><a class="anchor" id="autotoc_md85"></a>
Caching</h1>
<h2><a class="anchor" id="autotoc_md86"></a>
In Memory Cache</h2>
<p>The in memory cache will store processed and displayed data in memory. Data will be prioritised based on the most recently drawn area of the world, and will automatically be swapped to the on disk cache when required. The cache size will directly affect the display of vector data, and processing of both vector and raster data. If the in memory cache size is too small it may trigger a high amount of disk IO when panning the map display.</p>
<h2><a class="anchor" id="autotoc_md87"></a>
On Disk Cache</h2>
<p>The on disk cache will store processed data on disk, along with the parameters used to create the data. Like the in memory cache data will be prioritised based on the most recently drawn area of the world. This cache may be left on disk once the data layer is destroyed, and re-used in a future run of the application. Any data which is loaded with the same settings as before will be loaded from disk, instead of being processed from the source data. The cache size will affect the amount of disk space used by the layer. If the on disk cache size is too small it will cause the data to be processed from source, which may delay the appearance of data on the display.</p>
<h2><a class="anchor" id="autotoc_md88"></a>
Raster Draw Cache</h2>
<p>The raster draw cache is used to cache raster data when drawing. The cache size will affect the amount of raster data which can be displayed at a time. If the raster draw cache size is too small raster data may not be drawn, and will greatly reduce performance of the map display. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_t_s_l_direct_import_data_layer_1_1_destroy_data_sets.html">DestroyDataSets</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aecd1a177ad390b43e02829d7ed95bd47" id="r_aecd1a177ad390b43e02829d7ed95bd47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecd1a177ad390b43e02829d7ed95bd47">TSLDirectImportDataLayer</a> (unsigned int maxProcessingThreads=1, unsigned int maxCacheSizeMemory=256 *1024, const char *onDiskCachePath=NULL, unsigned int maxCacheSizeDisk=0, bool flushDiskOnExit=true)</td></tr>
<tr class="separator:aecd1a177ad390b43e02829d7ed95bd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4b5b513fd02cc2fe98eb78ad2c4d55" id="r_aed4b5b513fd02cc2fe98eb78ad2c4d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_lvector.html">TSLvector</a>&lt; <a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a> * &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed4b5b513fd02cc2fe98eb78ad2c4d55">createDataSets</a> (const char *data, <a class="el" href="class_t_s_l_direct_import_driver.html#ad47a9ebdce73ec596c6d2c359e855bb0">TSLDirectImportDriver::OverviewType</a> overviewTypes=<a class="el" href="class_t_s_l_direct_import_driver.html#ad47a9ebdce73ec596c6d2c359e855bb0aac924a5f9ba983e976367be569de2ed7">TSLDirectImportDriver::OverviewTypeAny</a>)</td></tr>
<tr class="separator:aed4b5b513fd02cc2fe98eb78ad2c4d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14892a7f8be512e5342e1b369688a8f1" id="r_a14892a7f8be512e5342e1b369688a8f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14892a7f8be512e5342e1b369688a8f1">extentExpansion</a> (double expansion)</td></tr>
<tr class="separator:a14892a7f8be512e5342e1b369688a8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae00088f8897f8b3c42202a9cb49b72cc" id="r_ae00088f8897f8b3c42202a9cb49b72cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae00088f8897f8b3c42202a9cb49b72cc">enableDrawPerformanceTweaks</a> (bool enable)</td></tr>
<tr class="separator:ae00088f8897f8b3c42202a9cb49b72cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdc43169bbab67aea4f9858db64e5b2" id="r_a2fdc43169bbab67aea4f9858db64e5b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fdc43169bbab67aea4f9858db64e5b2">analyseData</a> (<a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a> *dataSet)</td></tr>
<tr class="separator:a2fdc43169bbab67aea4f9858db64e5b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956351626be4470f9a13824fd39ea866" id="r_a956351626be4470f9a13824fd39ea866"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a956351626be4470f9a13824fd39ea866">analyseData</a> (const <a class="el" href="class_t_s_lvector.html">TSLvector</a>&lt; <a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a> * &gt; *dataSets)</td></tr>
<tr class="separator:a956351626be4470f9a13824fd39ea866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a96e295488d4c0ac7f397b8154fb762" id="r_a1a96e295488d4c0ac7f397b8154fb762"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a96e295488d4c0ac7f397b8154fb762">loadData</a> (<a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a> *dataSet, const <a class="el" href="class_t_s_l_feature_class_config.html">TSLFeatureClassConfig</a> *config=NULL)</td></tr>
<tr class="separator:a1a96e295488d4c0ac7f397b8154fb762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76917950eb91678f2d18d5c437a53dbf" id="r_a76917950eb91678f2d18d5c437a53dbf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76917950eb91678f2d18d5c437a53dbf">preprocessData</a> (const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent, <a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a> *dataSet=NULL, <a class="el" href="class_t_s_l_direct_import_scale_band.html">TSLDirectImportScaleBand</a> *scaleBand=NULL, double minScale=0.0, double maxScale=(std::numeric_limits&lt; double &gt;::max)())</td></tr>
<tr class="separator:a76917950eb91678f2d18d5c437a53dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c139dd8b014db21a2a537018471146" id="r_a92c139dd8b014db21a2a537018471146"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92c139dd8b014db21a2a537018471146">numScaleBands</a> () const</td></tr>
<tr class="separator:a92c139dd8b014db21a2a537018471146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1202bc7f6a347a4adef9009c39926d6f" id="r_a1202bc7f6a347a4adef9009c39926d6f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_direct_import_scale_band.html">TSLDirectImportScaleBand</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1202bc7f6a347a4adef9009c39926d6f">addScaleBand</a> (double minScale, const char *bandName, unsigned int tilesX=0, unsigned int tilesY=0)</td></tr>
<tr class="separator:a1202bc7f6a347a4adef9009c39926d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ecba3e402861f3d32451f849680d27" id="r_aa9ecba3e402861f3d32451f849680d27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_direct_import_scale_band.html">TSLDirectImportScaleBand</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9ecba3e402861f3d32451f849680d27">getScaleBand</a> (unsigned int index) const</td></tr>
<tr class="separator:aa9ecba3e402861f3d32451f849680d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12212706e645d59a428ea7e70b9db538" id="r_a12212706e645d59a428ea7e70b9db538"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12212706e645d59a428ea7e70b9db538">numProcessingThreads</a> () const</td></tr>
<tr class="separator:a12212706e645d59a428ea7e70b9db538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30fc75e90c7d0405a32b4ad8383a93b8" id="r_a30fc75e90c7d0405a32b4ad8383a93b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30fc75e90c7d0405a32b4ad8383a93b8">numProcessingThreads</a> (unsigned int numThreads)</td></tr>
<tr class="separator:a30fc75e90c7d0405a32b4ad8383a93b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67f52efe935278620254d13ec08cb37f" id="r_a67f52efe935278620254d13ec08cb37f"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67f52efe935278620254d13ec08cb37f">maxMemoryCacheSize</a> () const</td></tr>
<tr class="separator:a67f52efe935278620254d13ec08cb37f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1d97b005ce2d6a2dd8549503c888a4" id="r_a4c1d97b005ce2d6a2dd8549503c888a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c1d97b005ce2d6a2dd8549503c888a4">maxMemoryCacheSize</a> (unsigned int maxSize)</td></tr>
<tr class="separator:a4c1d97b005ce2d6a2dd8549503c888a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f94738758cf0738c07f20de1bea0167" id="r_a0f94738758cf0738c07f20de1bea0167"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f94738758cf0738c07f20de1bea0167">maxRasterDrawCacheSize</a> () const</td></tr>
<tr class="separator:a0f94738758cf0738c07f20de1bea0167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67a2f873a718b5bbf8ad9bf5e8191162" id="r_a67a2f873a718b5bbf8ad9bf5e8191162"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67a2f873a718b5bbf8ad9bf5e8191162">maxRasterDrawCacheSize</a> (unsigned int maxSize)</td></tr>
<tr class="separator:a67a2f873a718b5bbf8ad9bf5e8191162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482ebff34ca29e90ee74de54fa42e5b3" id="r_a482ebff34ca29e90ee74de54fa42e5b3"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a482ebff34ca29e90ee74de54fa42e5b3">maxDiskCacheSize</a> () const</td></tr>
<tr class="separator:a482ebff34ca29e90ee74de54fa42e5b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec3fe3109a7e03cbefed9269453f0f81" id="r_aec3fe3109a7e03cbefed9269453f0f81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aec3fe3109a7e03cbefed9269453f0f81">maxDiskCacheSize</a> (unsigned int maxSize)</td></tr>
<tr class="separator:aec3fe3109a7e03cbefed9269453f0f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d5478ca39d2bc5323008307136ccec2" id="r_a3d5478ca39d2bc5323008307136ccec2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d5478ca39d2bc5323008307136ccec2">diskCachePath</a> () const</td></tr>
<tr class="separator:a3d5478ca39d2bc5323008307136ccec2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19fc8cabd65a8f6f0d3e9187ffa777a1" id="r_a19fc8cabd65a8f6f0d3e9187ffa777a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a19fc8cabd65a8f6f0d3e9187ffa777a1">flushDiskCacheOnExit</a> (bool flush)</td></tr>
<tr class="separator:a19fc8cabd65a8f6f0d3e9187ffa777a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d5943cc5eeecd6eb7be1bd2b796ca9" id="r_a41d5943cc5eeecd6eb7be1bd2b796ca9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41d5943cc5eeecd6eb7be1bd2b796ca9">setCallbacks</a> (<a class="el" href="class_t_s_l_direct_import_data_layer_callbacks.html">TSLDirectImportDataLayerCallbacks</a> *callbacks)</td></tr>
<tr class="separator:a41d5943cc5eeecd6eb7be1bd2b796ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3345ae7d7009dc76eb6ea105bd4f64ec" id="r_a3345ae7d7009dc76eb6ea105bd4f64ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3345ae7d7009dc76eb6ea105bd4f64ec">setAnalysisCallbacks</a> (<a class="el" href="class_t_s_l_direct_import_data_layer_analysis_callbacks.html">TSLDirectImportDataLayerAnalysisCallbacks</a> *callbacks)</td></tr>
<tr class="separator:a3345ae7d7009dc76eb6ea105bd4f64ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784ab3b2348fbb9cba3c5422cdcdd529" id="r_a784ab3b2348fbb9cba3c5422cdcdd529"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a784ab3b2348fbb9cba3c5422cdcdd529">operator new</a> (size_t size) TSL_NO_THROW</td></tr>
<tr class="memdesc:a784ab3b2348fbb9cba3c5422cdcdd529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocation override for API redirection.  <br /></td></tr>
<tr class="separator:a784ab3b2348fbb9cba3c5422cdcdd529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c10af9539022bccce85a1ffe0eb2552" id="r_a0c10af9539022bccce85a1ffe0eb2552"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c10af9539022bccce85a1ffe0eb2552">operator new</a> (size_t size, char *filename, int line)</td></tr>
<tr class="separator:a0c10af9539022bccce85a1ffe0eb2552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1410e04c8d61d943e1fbe5dd59e8a9" id="r_a2f1410e04c8d61d943e1fbe5dd59e8a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2f1410e04c8d61d943e1fbe5dd59e8a9">synchronousDisplay</a> (bool synchronous)</td></tr>
<tr class="separator:a2f1410e04c8d61d943e1fbe5dd59e8a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af66d9b8b7914f50ec685d13b4c804a2c" id="r_af66d9b8b7914f50ec685d13b4c804a2c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af66d9b8b7914f50ec685d13b4c804a2c">synchronousDisplay</a> () const</td></tr>
<tr class="separator:af66d9b8b7914f50ec685d13b4c804a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_t_s_l_data_layer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_t_s_l_data_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a></td></tr>
<tr class="memitem:a4fbc03b97523bbe9eb21cfefb8b545de inherit pub_methods_class_t_s_l_data_layer" id="r_a4fbc03b97523bbe9eb21cfefb8b545de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a4fbc03b97523bbe9eb21cfefb8b545de">addDrawingCallback</a> (<a class="el" href="class_t_s_l_data_layer_drawing_callback.html">TSLDataLayerDrawingCallback</a> *drawingCallback)</td></tr>
<tr class="separator:a4fbc03b97523bbe9eb21cfefb8b545de inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e9a5296f10a07340cc465b5ca9466f inherit pub_methods_class_t_s_l_data_layer" id="r_a10e9a5296f10a07340cc465b5ca9466f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a10e9a5296f10a07340cc465b5ca9466f">addFeatureRendering</a> (const char *featureName, TSLFeatureID featureID)</td></tr>
<tr class="separator:a10e9a5296f10a07340cc465b5ca9466f inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f31630e6fda8c34be66ef6dc987ff0 inherit pub_methods_class_t_s_l_data_layer" id="r_a17f31630e6fda8c34be66ef6dc987ff0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a17f31630e6fda8c34be66ef6dc987ff0">addLoader</a> (<a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *loader, <a class="el" href="group__apigroup__api.html#ga48f96f9ef6e81104016f6904e8883230">TSLLoaderAppCallback</a> callback, void *arg, <a class="el" href="group__apigroup__api.html#ga11aea432930000091575dc2fefca227d">TSLAllLoadedCallback</a> allLoadedCallback=0, void *arg2=0)</td></tr>
<tr class="separator:a17f31630e6fda8c34be66ef6dc987ff0 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d9f8234df5031730501c6371e12d88 inherit pub_methods_class_t_s_l_data_layer" id="r_ac2d9f8234df5031730501c6371e12d88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ac2d9f8234df5031730501c6371e12d88">addPathList</a> (const <a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> *path_list)</td></tr>
<tr class="separator:ac2d9f8234df5031730501c6371e12d88 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3105441039ed9fb09713165dad545d9c inherit pub_methods_class_t_s_l_data_layer" id="r_a3105441039ed9fb09713165dad545d9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a3105441039ed9fb09713165dad545d9c">cancelFlashback</a> ()</td></tr>
<tr class="separator:a3105441039ed9fb09713165dad545d9c inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991b7cfea7d673b7b3d9f9f4c64d5cfd inherit pub_methods_class_t_s_l_data_layer" id="r_a991b7cfea7d673b7b3d9f9f4c64d5cfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a991b7cfea7d673b7b3d9f9f4c64d5cfd">clearFeatureRendering</a> (const char *featureName, TSLFeatureID featureID)</td></tr>
<tr class="separator:a991b7cfea7d673b7b3d9f9f4c64d5cfd inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4acea014d2126ae89eeb777cbebb26 inherit pub_methods_class_t_s_l_data_layer" id="r_a8d4acea014d2126ae89eeb777cbebb26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a8d4acea014d2126ae89eeb777cbebb26">createDataHandler</a> (const char *config_file=0)</td></tr>
<tr class="separator:a8d4acea014d2126ae89eeb777cbebb26 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f02a7ea00e2ea18861508ffec7b024 inherit pub_methods_class_t_s_l_data_layer" id="r_a02f02a7ea00e2ea18861508ffec7b024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a02f02a7ea00e2ea18861508ffec7b024">currentVersion</a> () const</td></tr>
<tr class="separator:a02f02a7ea00e2ea18861508ffec7b024 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8761e162ed667836db6f6ec2f21f1d8 inherit pub_methods_class_t_s_l_data_layer" id="r_ab8761e162ed667836db6f6ec2f21f1d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ab8761e162ed667836db6f6ec2f21f1d8">dataHandler</a> ()</td></tr>
<tr class="separator:ab8761e162ed667836db6f6ec2f21f1d8 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab86eea288d1ecae6b630954038ba1a2 inherit pub_methods_class_t_s_l_data_layer" id="r_aab86eea288d1ecae6b630954038ba1a2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#aab86eea288d1ecae6b630954038ba1a2">dataHandler</a> () const</td></tr>
<tr class="separator:aab86eea288d1ecae6b630954038ba1a2 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cffcfd0ac1e02c02e845fc46411a25e inherit pub_methods_class_t_s_l_data_layer" id="r_a4cffcfd0ac1e02c02e845fc46411a25e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a4cffcfd0ac1e02c02e845fc46411a25e">destroy</a> ()</td></tr>
<tr class="separator:a4cffcfd0ac1e02c02e845fc46411a25e inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c73aeed7bdbabd90e656b4db0d8ecb inherit pub_methods_class_t_s_l_data_layer" id="r_ad7c73aeed7bdbabd90e656b4db0d8ecb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ad7c73aeed7bdbabd90e656b4db0d8ecb">entityIsVisible</a> (const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *entity, const <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *drawingSurface) const</td></tr>
<tr class="separator:ad7c73aeed7bdbabd90e656b4db0d8ecb inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194db4f2f5e2c20b9b75285abaa8841b inherit pub_methods_class_t_s_l_data_layer" id="r_a194db4f2f5e2c20b9b75285abaa8841b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_feature_class_list.html">TSLFeatureClassList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a194db4f2f5e2c20b9b75285abaa8841b">featureList</a> () const</td></tr>
<tr class="separator:a194db4f2f5e2c20b9b75285abaa8841b inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af587d2e872c15803342eef1973cec1bb inherit pub_methods_class_t_s_l_data_layer" id="r_af587d2e872c15803342eef1973cec1bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_feature_class_list.html">TSLFeatureClassList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#af587d2e872c15803342eef1973cec1bb">featureList</a> (const char *detailLayerName) const</td></tr>
<tr class="separator:af587d2e872c15803342eef1973cec1bb inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8997d0cbd428a6aa9783a4fd45a70cb5 inherit pub_methods_class_t_s_l_data_layer" id="r_a8997d0cbd428a6aa9783a4fd45a70cb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a8997d0cbd428a6aa9783a4fd45a70cb5">fileModificationTime</a> (const char *filename, TSLTimeType &amp;lastModificationTime)</td></tr>
<tr class="separator:a8997d0cbd428a6aa9783a4fd45a70cb5 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd7da13f831401661e0a63e19c52a64 inherit pub_methods_class_t_s_l_data_layer" id="r_abfd7da13f831401661e0a63e19c52a64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#abfd7da13f831401661e0a63e19c52a64">findEntity</a> (TSLTMC x, TSLTMC y, TSLTMC aperture, int depth, const char *featureName=0, int drawingSurfaceID=-1)</td></tr>
<tr class="separator:abfd7da13f831401661e0a63e19c52a64 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe90ad7a643c8cb39dac461e1ba9d367 inherit pub_methods_class_t_s_l_data_layer" id="r_afe90ad7a643c8cb39dac461e1ba9d367"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#afe90ad7a643c8cb39dac461e1ba9d367">findFile</a> (const char *filename, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;foundPath) const</td></tr>
<tr class="separator:afe90ad7a643c8cb39dac461e1ba9d367 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab953980469594aab11575009626c00b3 inherit pub_methods_class_t_s_l_data_layer" id="r_ab953980469594aab11575009626c00b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ab953980469594aab11575009626c00b3">flashbackToTimestamp</a> (<a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a> timestamp, <a class="el" href="group__apigroup__api.html#gaf92bab978dd0ee67b6781c3ca417e233">TSLLayerArchiveCallback</a> archiveCallback, void *arg=0)</td></tr>
<tr class="separator:ab953980469594aab11575009626c00b3 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c24847ea318be6604ec34d1d242aa62 inherit pub_methods_class_t_s_l_data_layer" id="r_a4c24847ea318be6604ec34d1d242aa62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a4c24847ea318be6604ec34d1d242aa62">flashbackToTimestamp</a> (<a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a> timestamp, <a class="el" href="group__apigroup__api.html#ga40ea9a3893d69e5865dc7c72f62b9ae2">TSLLayerArchiveTileCallback</a> archiveTileCallback, void *arg=0)</td></tr>
<tr class="separator:a4c24847ea318be6604ec34d1d242aa62 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd072130777b87c3ef6db086749845e5 inherit pub_methods_class_t_s_l_data_layer" id="r_abd072130777b87c3ef6db086749845e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#abd072130777b87c3ef6db086749845e5">flashbackToVersion</a> (<a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a> version, <a class="el" href="group__apigroup__api.html#gaf92bab978dd0ee67b6781c3ca417e233">TSLLayerArchiveCallback</a> archiveCallback, void *arg=0)</td></tr>
<tr class="separator:abd072130777b87c3ef6db086749845e5 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e8441c8c13520930ddb118c0fae0c0 inherit pub_methods_class_t_s_l_data_layer" id="r_a14e8441c8c13520930ddb118c0fae0c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a14e8441c8c13520930ddb118c0fae0c0">flashbackToVersion</a> (<a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a> version, <a class="el" href="group__apigroup__api.html#ga40ea9a3893d69e5865dc7c72f62b9ae2">TSLLayerArchiveTileCallback</a> archiveTileCallback, void *arg=0)</td></tr>
<tr class="separator:a14e8441c8c13520930ddb118c0fae0c0 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf439f3ddf34295b02e4a2e31eb1911 inherit pub_methods_class_t_s_l_data_layer" id="r_a9cf439f3ddf34295b02e4a2e31eb1911"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a9cf439f3ddf34295b02e4a2e31eb1911">getActiveLayerName</a> (const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent, double screenResolution, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;activeLayerName) const</td></tr>
<tr class="separator:a9cf439f3ddf34295b02e4a2e31eb1911 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62b5809179e31d019dec790177d42a6 inherit pub_methods_class_t_s_l_data_layer" id="r_ad62b5809179e31d019dec790177d42a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity_iterator.html">TSLEntityIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ad62b5809179e31d019dec790177d42a6">getEntityIterator</a> (const char *detailLayer, <a class="el" href="class_t_s_l_selector.html">TSLSelector</a> *selector=NULL, <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> *extent=NULL, bool splitOptimisedPrimitives=true)</td></tr>
<tr class="separator:ad62b5809179e31d019dec790177d42a6 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b6bf865d0afde06a262fc7fb0edc43 inherit pub_methods_class_t_s_l_data_layer" id="r_a75b6bf865d0afde06a262fc7fb0edc43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a75b6bf865d0afde06a262fc7fb0edc43">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a> attribute, int *result) const</td></tr>
<tr class="separator:a75b6bf865d0afde06a262fc7fb0edc43 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0232b2f236064f89665f1776dca140b inherit pub_methods_class_t_s_l_data_layer" id="r_af0232b2f236064f89665f1776dca140b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#af0232b2f236064f89665f1776dca140b">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a> attribute, double *result) const</td></tr>
<tr class="separator:af0232b2f236064f89665f1776dca140b inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a98dc01354ecec9c65eac5de8795e59 inherit pub_methods_class_t_s_l_data_layer" id="r_a6a98dc01354ecec9c65eac5de8795e59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a6a98dc01354ecec9c65eac5de8795e59">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a> attribute, bool *result) const</td></tr>
<tr class="separator:a6a98dc01354ecec9c65eac5de8795e59 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fae08a54978e8e2b0aa2344caeedf2d inherit pub_methods_class_t_s_l_data_layer" id="r_a3fae08a54978e8e2b0aa2344caeedf2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a3fae08a54978e8e2b0aa2344caeedf2d">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *result) const</td></tr>
<tr class="separator:a3fae08a54978e8e2b0aa2344caeedf2d inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35de696e1cd209e428c8da6c2f4e300b inherit pub_methods_class_t_s_l_data_layer" id="r_a35de696e1cd209e428c8da6c2f4e300b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a35de696e1cd209e428c8da6c2f4e300b">getLoader</a> ()</td></tr>
<tr class="separator:a35de696e1cd209e428c8da6c2f4e300b inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34074a432614a62093d349838dcdbfd2 inherit pub_methods_class_t_s_l_data_layer" id="r_a34074a432614a62093d349838dcdbfd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a34074a432614a62093d349838dcdbfd2">getMUExtent</a> (double *x1, double *y1, double *x2, double *y2, int drawingSurfaceID=-1) const</td></tr>
<tr class="separator:a34074a432614a62093d349838dcdbfd2 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7677906c203b52b4dde95807202e21f2 inherit pub_methods_class_t_s_l_data_layer" id="r_a7677906c203b52b4dde95807202e21f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a7677906c203b52b4dde95807202e21f2">getTMCExtent</a> (TSLTMC *x1, TSLTMC *y1, TSLTMC *x2, TSLTMC *y2, int drawingSurfaceID=-1) const</td></tr>
<tr class="separator:a7677906c203b52b4dde95807202e21f2 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bf18c76d0d8c476eb5ce835f16b69f inherit pub_methods_class_t_s_l_data_layer" id="r_ab0bf18c76d0d8c476eb5ce835f16b69f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ab0bf18c76d0d8c476eb5ce835f16b69f">getUUExtent</a> (double *x1, double *y1, double *x2, double *y2, const <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *drawingSurface) const</td></tr>
<tr class="separator:ab0bf18c76d0d8c476eb5ce835f16b69f inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f186469525c8fb0b4cc9c415546492 inherit pub_methods_class_t_s_l_data_layer" id="r_a43f186469525c8fb0b4cc9c415546492"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a43f186469525c8fb0b4cc9c415546492">importHistory</a> (<a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a> mapVersion, <a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a> timestamp, <a class="el" href="class_t_s_l_history_import_set.html">TSLHistoryImportSet</a> *historySet)</td></tr>
<tr class="separator:a43f186469525c8fb0b4cc9c415546492 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242fafc67323bf7489430a1b1cf20a15 inherit pub_methods_class_t_s_l_data_layer" id="r_a242fafc67323bf7489430a1b1cf20a15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a242fafc67323bf7489430a1b1cf20a15">latLongToTMC</a> (double latitude, double longitude, TSLTMC *x, TSLTMC *y, bool local=false) const</td></tr>
<tr class="separator:a242fafc67323bf7489430a1b1cf20a15 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049b9cb6c75049b976a44a63a4fda83f inherit pub_methods_class_t_s_l_data_layer" id="r_a049b9cb6c75049b976a44a63a4fda83f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a049b9cb6c75049b976a44a63a4fda83f">latLongToTMC</a> (int num, double *latitudes, double *longitudes, TSLTMC *xs, TSLTMC *ys, bool local=false) const</td></tr>
<tr class="separator:a049b9cb6c75049b976a44a63a4fda83f inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc060243cb1337c3b8709c1cec683720 inherit pub_methods_class_t_s_l_data_layer" id="r_acc060243cb1337c3b8709c1cec683720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apigroup__api.html#gaf8bedcb6358f6ef60075d2bbca8fe118">TSLDataLayerTypeEnum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#acc060243cb1337c3b8709c1cec683720">layerType</a> () const</td></tr>
<tr class="separator:acc060243cb1337c3b8709c1cec683720 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996e6ca3e3b9b10fc0f6fbe714a525a0 inherit pub_methods_class_t_s_l_data_layer" id="r_a996e6ca3e3b9b10fc0f6fbe714a525a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a996e6ca3e3b9b10fc0f6fbe714a525a0">loadData</a> (const char *filename)</td></tr>
<tr class="separator:a996e6ca3e3b9b10fc0f6fbe714a525a0 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5882d7ca1362bf7dce2ceff2e08d5b1 inherit pub_methods_class_t_s_l_data_layer" id="r_ad5882d7ca1362bf7dce2ceff2e08d5b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ad5882d7ca1362bf7dce2ceff2e08d5b1">loadRendering</a> (const char *filename)</td></tr>
<tr class="separator:ad5882d7ca1362bf7dce2ceff2e08d5b1 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b87a4127970755ed66caaf44e48de9 inherit pub_methods_class_t_s_l_data_layer" id="r_a05b87a4127970755ed66caaf44e48de9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a05b87a4127970755ed66caaf44e48de9">notifyChanged</a> (bool changed=true)</td></tr>
<tr class="separator:a05b87a4127970755ed66caaf44e48de9 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1794ff9ca4ebbea2ee17986729de0b3c inherit pub_methods_class_t_s_l_data_layer" id="r_a1794ff9ca4ebbea2ee17986729de0b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a1794ff9ca4ebbea2ee17986729de0b3c">query</a> (TSLTMC x1, TSLTMC y1, TSLTMC x2, TSLTMC y2, int depth=-1, const char *featureName=NULL, int drawingSurfaceID=-1) const</td></tr>
<tr class="separator:a1794ff9ca4ebbea2ee17986729de0b3c inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80490627af3ab4871812115802c56359 inherit pub_methods_class_t_s_l_data_layer" id="r_a80490627af3ab4871812115802c56359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a80490627af3ab4871812115802c56359">query</a> (TSLTMC x1, TSLTMC y1, TSLTMC x2, TSLTMC y2, <a class="el" href="class_t_s_l_selector.html">TSLSelector</a> *selector, int drawingSurfaceID=-1) const</td></tr>
<tr class="separator:a80490627af3ab4871812115802c56359 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b71c959052cf95ffcdbd00d0912603 inherit pub_methods_class_t_s_l_data_layer" id="r_a37b71c959052cf95ffcdbd00d0912603"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a37b71c959052cf95ffcdbd00d0912603">getCoordinateSystem</a> () const</td></tr>
<tr class="separator:a37b71c959052cf95ffcdbd00d0912603 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ad614ec1fb35434810d08e6a8ba8b5 inherit pub_methods_class_t_s_l_data_layer" id="r_a36ad614ec1fb35434810d08e6a8ba8b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a36ad614ec1fb35434810d08e6a8ba8b5">queryVersionHistory</a> (const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent, <a class="el" href="class_t_s_l_version_history_set.html">TSLVersionHistorySet</a> &amp;history)</td></tr>
<tr class="separator:a36ad614ec1fb35434810d08e6a8ba8b5 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad29ab355dbb41a0fcd809dcc7b11337 inherit pub_methods_class_t_s_l_data_layer" id="r_aad29ab355dbb41a0fcd809dcc7b11337"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#aad29ab355dbb41a0fcd809dcc7b11337">refreshFlashback</a> ()</td></tr>
<tr class="separator:aad29ab355dbb41a0fcd809dcc7b11337 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7de8beee6ba358591a22c0a2dd567a0 inherit pub_methods_class_t_s_l_data_layer" id="r_ab7de8beee6ba358591a22c0a2dd567a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ab7de8beee6ba358591a22c0a2dd567a0">removeData</a> ()</td></tr>
<tr class="separator:ab7de8beee6ba358591a22c0a2dd567a0 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f727d73219da9ab2b94e0329a74607 inherit pub_methods_class_t_s_l_data_layer" id="r_ac4f727d73219da9ab2b94e0329a74607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ac4f727d73219da9ab2b94e0329a74607">releaseResources</a> (int surfaceID)</td></tr>
<tr class="separator:ac4f727d73219da9ab2b94e0329a74607 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b668fab4184d186d48ba860b7ca41ab inherit pub_methods_class_t_s_l_data_layer" id="r_a7b668fab4184d186d48ba860b7ca41ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a7b668fab4184d186d48ba860b7ca41ab">saveRendering</a> (const char *filename, <a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a> ver=<a class="el" href="group__apigroup__common.html#gga8141b1e165228e088c49024076e13758a0ecdea6c91f1d3104d6166d69b57c88d">TSL_CURRENT_MAPLINK_VERSION</a>)</td></tr>
<tr class="separator:a7b668fab4184d186d48ba860b7ca41ab inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c58b8475acb63c5a3f031e0cac28449 inherit pub_methods_class_t_s_l_data_layer" id="r_a8c58b8475acb63c5a3f031e0cac28449"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a8c58b8475acb63c5a3f031e0cac28449">setCoordinateSystem</a> (const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *coordinateSystem)</td></tr>
<tr class="separator:a8c58b8475acb63c5a3f031e0cac28449 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b60a990c7763ccb582dc2b59aa769f inherit pub_methods_class_t_s_l_data_layer" id="r_a15b60a990c7763ccb582dc2b59aa769f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a15b60a990c7763ccb582dc2b59aa769f">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a> attribute, int value)</td></tr>
<tr class="separator:a15b60a990c7763ccb582dc2b59aa769f inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01692e748c350a23675ad3d78807e684 inherit pub_methods_class_t_s_l_data_layer" id="r_a01692e748c350a23675ad3d78807e684"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a01692e748c350a23675ad3d78807e684">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a> attribute, double value)</td></tr>
<tr class="separator:a01692e748c350a23675ad3d78807e684 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1527856e58de4618ad218424738c6986 inherit pub_methods_class_t_s_l_data_layer" id="r_a1527856e58de4618ad218424738c6986"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a1527856e58de4618ad218424738c6986">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a> attribute, bool value)</td></tr>
<tr class="separator:a1527856e58de4618ad218424738c6986 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ac4671ad4be33730b564240532754b inherit pub_methods_class_t_s_l_data_layer" id="r_a74ac4671ad4be33730b564240532754b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a74ac4671ad4be33730b564240532754b">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *value)</td></tr>
<tr class="separator:a74ac4671ad4be33730b564240532754b inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab580b6f9a6e8a6615937256304489f inherit pub_methods_class_t_s_l_data_layer" id="r_a4ab580b6f9a6e8a6615937256304489f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a4ab580b6f9a6e8a6615937256304489f">TMCToLatLong</a> (TSLTMC x, TSLTMC y, double *latitude, double *longitude, bool local=false, bool boundCheck=true) const</td></tr>
<tr class="separator:a4ab580b6f9a6e8a6615937256304489f inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568048fa9c27f7100df84bb1d08524fa inherit pub_methods_class_t_s_l_data_layer" id="r_a568048fa9c27f7100df84bb1d08524fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a568048fa9c27f7100df84bb1d08524fa">TMCToLatLong</a> (int num, TSLTMC *xs, TSLTMC *ys, double *latitudes, double *longitudes, bool local=false) const</td></tr>
<tr class="separator:a568048fa9c27f7100df84bb1d08524fa inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19803bde4b29d406445dd7a4b9aab850 inherit pub_methods_class_t_s_l_data_layer" id="r_a19803bde4b29d406445dd7a4b9aab850"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_version_history_set.html">TSLVersionHistorySet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a19803bde4b29d406445dd7a4b9aab850">versionHistory</a> () const</td></tr>
<tr class="separator:a19803bde4b29d406445dd7a4b9aab850 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a842c421c0d56a05dd4e1c89ae2cae7f7" id="r_a842c421c0d56a05dd4e1c89ae2cae7f7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a842c421c0d56a05dd4e1c89ae2cae7f7">destroyDataSets</a> (<a class="el" href="class_t_s_lvector.html">TSLvector</a>&lt; <a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a> * &gt; *dataSets)</td></tr>
<tr class="separator:a842c421c0d56a05dd4e1c89ae2cae7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa627269818051e33d2d628ea5d345b46" id="r_aa627269818051e33d2d628ea5d345b46"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa627269818051e33d2d628ea5d345b46">numDrivers</a> ()</td></tr>
<tr class="separator:aa627269818051e33d2d628ea5d345b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9bfdb04c24ebabb3f8b1ea1c1bff04" id="r_afe9bfdb04c24ebabb3f8b1ea1c1bff04"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_s_l_direct_import_driver.html">TSLDirectImportDriver</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe9bfdb04c24ebabb3f8b1ea1c1bff04">getDriver</a> (unsigned int index)</td></tr>
<tr class="separator:afe9bfdb04c24ebabb3f8b1ea1c1bff04"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aecd1a177ad390b43e02829d7ed95bd47" name="aecd1a177ad390b43e02829d7ed95bd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd1a177ad390b43e02829d7ed95bd47">&#9670;&#160;</a></span>TSLDirectImportDataLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLDirectImportDataLayer::TSLDirectImportDataLayer </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>maxProcessingThreads</em></span><span class="paramdefsep"> = </span><span class="paramdefval">1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>maxCacheSizeMemory</em></span><span class="paramdefsep"> = </span><span class="paramdefval">256&#160;*1024</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>onDiskCachePath</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>maxCacheSizeDisk</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flushDiskOnExit</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor</p>
<p>If flushDiskOnExit is set to false the application must ensure the datalayer is properly destroyed. If the datalayer is not destroyed before the program exits the on-disk cache indexes will not be saved. This will cause any persistent data to be discarded the next time the cache is used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxProcessingThreads</td><td>The maximum number of threads to use when processing data. If 0 the datalayer will use 1 thread for each CPU core. By default the datalayer will use 1 processing thread in order to reduce memory usage. </td></tr>
    <tr><td class="paramname">maxCacheSizeMemory</td><td>The maximum in-memory cache size in KB. </td></tr>
    <tr><td class="paramname">onDiskCachePath</td><td>If set the datalayer will cache processed data on disk, under this folder. If NULL the on-disk cache will be placed under the system's temporary directory. The on-disk cache may not be shared between multiple datalayers. </td></tr>
    <tr><td class="paramname">maxCacheSizeDisk</td><td>The maximum on-disk cache size in KB. A value of 0 means unlimited. </td></tr>
    <tr><td class="paramname">flushDiskOnExit</td><td>If true the on-disk cache will be deleted when the datalayer is destroyed. If false the data will persist and may be used when the application is restarted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1202bc7f6a347a4adef9009c39926d6f" name="a1202bc7f6a347a4adef9009c39926d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1202bc7f6a347a4adef9009c39926d6f">&#9670;&#160;</a></span>addScaleBand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_direct_import_scale_band.html">TSLDirectImportScaleBand</a> * TSLDirectImportDataLayer::addScaleBand </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>minScale</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>bandName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>tilesX</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>tilesY</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a scale band to the layer</p>
<p>A scale band specifies a sub layer within the <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a>.</p>
<p>The provided scale values will be used to enable/disable display of each scale band based on the current view scale. Example scale values:</p><ul>
<li>1:25K : 0.00004</li>
<li>1:50K : 0.00002</li>
<li>1:100K : 0.00001</li>
</ul>
<p>To ensure that scale band selection is accurate the application must ensure that TSLDrawingSurfaceBase::setDeviceCapabilities has been called. On some platforms these capabilities may be set automatically by the drawing surface.</p>
<p>Data may be automatically placed in an appropriate based on scale by calling loadData. Data may also be loaded into a specific scale band by calling <a class="el" href="class_t_s_l_direct_import_scale_band.html#a71c3d78eebb7b03b076f6d12cf4e66d4">TSLDirectImportScaleBand::loadData</a>.</p>
<p>If tiling values are specified by the application the tilesX parameter should usually be tilesY * 2. This is due to the fact that a global extent is 360 x 180 degrees.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minScale</td><td>The minimum (least detailed) scale for this band </td></tr>
    <tr><td class="paramname">bandName</td><td>The name of this band. </td></tr>
    <tr><td class="paramname">tilesX</td><td>The desired number of horizontal tiles across a global extent. If 0 tiling will be automatically calculated based on the device capabilities and minScale. </td></tr>
    <tr><td class="paramname">tilesY</td><td>The desired number of vertical tiles across a global extent. If 0 tiling will be automatically calculated based on the device capabilities and minScale. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The created scale band, or NULL on error. The band may be modified but remains owned by the <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a>. </dd></dl>

</div>
</div>
<a id="a956351626be4470f9a13824fd39ea866" name="a956351626be4470f9a13824fd39ea866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956351626be4470f9a13824fd39ea866">&#9670;&#160;</a></span>analyseData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDirectImportDataLayer::analyseData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_lvector.html">TSLvector</a>&lt; <a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>dataSets</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open some data, and analyse the features within it</p>
<p>This is an expensive operation and will be performed asynchronously. The result of the analysis process will be provided to the application via <a class="el" href="class_t_s_l_direct_import_data_layer_analysis_callbacks.html#af4f8f07c778d97792847b68b40446fff">TSLDirectImportDataLayerAnalysisCallbacks::onAnalysisComplete</a>.</p>
<p>The <a class="el" href="class_t_s_l_feature_class_config.html">TSLFeatureClassConfig</a> may then be modified by the application in order to setup feature masking/classification. This feature configuration should be saved by the application to avoid re-analysis and will be required when calling loadData.</p>
<p>If no callback class has been provided to the layer, this method will return NULL. If an analysis process is already scheduled for the data, this method will return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataSets</td><td>The data to analyse. The application will receive a separate set of callbacks for each data set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any analysis was scheduled, false otherwise. </dd></dl>

</div>
</div>
<a id="a2fdc43169bbab67aea4f9858db64e5b2" name="a2fdc43169bbab67aea4f9858db64e5b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdc43169bbab67aea4f9858db64e5b2">&#9670;&#160;</a></span>analyseData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDirectImportDataLayer::analyseData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a> *</td>          <td class="paramname"><span class="paramname"><em>dataSet</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a data set, and analyse the features within it</p>
<p>This is an expensive operation and will be performed asynchronously. The result of the analysis process will be provided to the application via <a class="el" href="class_t_s_l_direct_import_data_layer_analysis_callbacks.html#af4f8f07c778d97792847b68b40446fff">TSLDirectImportDataLayerAnalysisCallbacks::onAnalysisComplete</a>.</p>
<p>The <a class="el" href="class_t_s_l_feature_class_config.html">TSLFeatureClassConfig</a> may then be modified by the application in order to setup feature masking/classification. This feature configuration should be saved by the application to avoid re-analysis and will be required when calling loadData.</p>
<p>If no callback class has been provided to the layer, this method will return NULL. If an analysis process is already scheduled for the data, this method will return NULL.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataSet</td><td>The data to analyse. This object may be created by calling createDataSets. The application retains ownership of this object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the analysis was scheduled, false otherwise. </dd></dl>

</div>
</div>
<a id="aed4b5b513fd02cc2fe98eb78ad2c4d55" name="aed4b5b513fd02cc2fe98eb78ad2c4d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4b5b513fd02cc2fe98eb78ad2c4d55">&#9670;&#160;</a></span>createDataSets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_lvector.html">TSLvector</a>&lt; <a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a> * &gt; * TSLDirectImportDataLayer::createDataSets </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_direct_import_driver.html#ad47a9ebdce73ec596c6d2c359e855bb0">TSLDirectImportDriver::OverviewType</a></td>          <td class="paramname"><span class="paramname"><em>overviewTypes</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="class_t_s_l_direct_import_driver.html#ad47a9ebdce73ec596c6d2c359e855bb0aac924a5f9ba983e976367be569de2ed7">TSLDirectImportDriver::OverviewTypeAny</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create data sets from a given data path</p>
<p>This method will check whether the data can be opened by the direct import layer and perform a basic analysis. Calling this method will not load any data into the layer for display, or perform any in-depth processing.</p>
<p>One data path may contain multiple data sets. Often these map to 'sub-layers' in the data.</p>
<p>For a detailed analysis of features within the data see <a class="el" href="#a2fdc43169bbab67aea4f9858db64e5b2">TSLDirectImportDataLayer::analyseData</a>.</p>
<p>To load the data for display see <a class="el" href="#a1a96e295488d4c0ac7f397b8154fb762">TSLDirectImportDataLayer::loadData</a> and <a class="el" href="class_t_s_l_direct_import_scale_band.html#a71c3d78eebb7b03b076f6d12cf4e66d4">TSLDirectImportScaleBand::loadData</a>.</p>
<p>If the direct import driver is unable extract coordinate system and extent information from the data these will be requested through <a class="el" href="class_t_s_l_direct_import_data_layer_callbacks.html">TSLDirectImportDataLayerCallbacks</a>. The application must provide this information in order to load the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data path to analyse. This may be a file, URL, or other path supported by the available drivers. </td></tr>
    <tr><td class="paramname">overviewTypes</td><td>A bitmask specifying which overview types to return. Usually <a class="el" href="class_t_s_l_direct_import_driver.html#ad47a9ebdce73ec596c6d2c359e855bb0abc70d1044fca850258858747b6f8efc0">TSLDirectImportDriver::OverviewTypeNone</a> or <a class="el" href="class_t_s_l_direct_import_driver.html#ad47a9ebdce73ec596c6d2c359e855bb0aac924a5f9ba983e976367be569de2ed7">TSLDirectImportDriver::OverviewTypeAny</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Basic information about the data, or NULL if the basic analysis couldn't be performed. The application is responsible for deleting the returned vector and its contents. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="#a842c421c0d56a05dd4e1c89ae2cae7f7">destroyDataSets</a>. </dd></dl>

</div>
</div>
<a id="a842c421c0d56a05dd4e1c89ae2cae7f7" name="a842c421c0d56a05dd4e1c89ae2cae7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842c421c0d56a05dd4e1c89ae2cae7f7">&#9670;&#160;</a></span>destroyDataSets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TSLDirectImportDataLayer::destroyDataSets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_lvector.html">TSLvector</a>&lt; <a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a> * &gt; *</td>          <td class="paramname"><span class="paramname"><em>dataSets</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete one or more datasets</p>
<p>This utility function will delete the provided vector and all data sets within it.</p>
<p>This function will not affect the <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a>'s state in any way.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataSets</td><td>A vector of datasets, returned from createDataSets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d5478ca39d2bc5323008307136ccec2" name="a3d5478ca39d2bc5323008307136ccec2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d5478ca39d2bc5323008307136ccec2">&#9670;&#160;</a></span>diskCachePath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * TSLDirectImportDataLayer::diskCachePath </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the on-disk cache path</p>
<dl class="section return"><dt>Returns</dt><dd>The location of the on-disk cache. </dd></dl>

</div>
</div>
<a id="ae00088f8897f8b3c42202a9cb49b72cc" name="ae00088f8897f8b3c42202a9cb49b72cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae00088f8897f8b3c42202a9cb49b72cc">&#9670;&#160;</a></span>enableDrawPerformanceTweaks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDataLayer::enableDrawPerformanceTweaks </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enable</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enable performance tweaks for data processing and display</p>
<p>By default this flag is false.</p>
<p>This flag should be enabled if an application constantly redraws the map display. The <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a> will limit the number of operations performed during a draw in order to maintain higher framerates and reduce visual stutter.</p>
<p>The following may happen if this flag is enabled</p><ul>
<li>Additional redraw requests will be made via <a class="el" href="class_t_s_l_direct_import_data_layer_callbacks.html#a158d7fbcc186c36ad0117f20d432166a">TSLDirectImportDataLayerCallbacks::requestRedraw</a>. The application should either respect these requests, or constantly redraw the map display.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enable</td><td>true to enable performance tweaks, false otherwise </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a14892a7f8be512e5342e1b369688a8f1" name="a14892a7f8be512e5342e1b369688a8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14892a7f8be512e5342e1b369688a8f1">&#9670;&#160;</a></span>extentExpansion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDataLayer::extentExpansion </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>expansion</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the layer's extent expansion</p>
<p>A value &gt; 0.0 will cause the layer to load/process tiles over a larger area than is specified. This may be useful when performing fast pan operations on the drawing surface, while loading complex data.</p>
<p>This expansion will not affect the rendering of the tiles themselves, only when they are loaded/processed into the tile cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">expansion</td><td>The expansion amount as a percentage i.e 10.0 == 10%. If &lt;= 0.0 extent expansion will be disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a19fc8cabd65a8f6f0d3e9187ffa777a1" name="a19fc8cabd65a8f6f0d3e9187ffa777a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19fc8cabd65a8f6f0d3e9187ffa777a1">&#9670;&#160;</a></span>flushDiskCacheOnExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDataLayer::flushDiskCacheOnExit </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>flush</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set whether the datalayer should flush the on-disk cache when it is destroyed</p>
<p>If the on-disk cache is not flushed, it may be re-used on subsequent runs of an application. Data will only be loaded from the on-disk cache if all scale band and dataset settings are the same.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flush</td><td>true if the layer should delete the on-disk cache when it is destroyed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe9bfdb04c24ebabb3f8b1ea1c1bff04" name="afe9bfdb04c24ebabb3f8b1ea1c1bff04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9bfdb04c24ebabb3f8b1ea1c1bff04">&#9670;&#160;</a></span>getDriver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_s_l_direct_import_driver.html">TSLDirectImportDriver</a> * TSLDirectImportDataLayer::getDriver </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query an instance of a direct import driver</p>
<dl class="section note"><dt>Note</dt><dd>The returned driver instance is owned by the application </dd>
<dd>
The datalayer will create additional driver instances when importing data. Setting a parameter on the returned driver instance will not affect the import process </dd></dl>

</div>
</div>
<a id="aa9ecba3e402861f3d32451f849680d27" name="aa9ecba3e402861f3d32451f849680d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ecba3e402861f3d32451f849680d27">&#9670;&#160;</a></span>getScaleBand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_direct_import_scale_band.html">TSLDirectImportScaleBand</a> * TSLDirectImportDataLayer::getScaleBand </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query a scale band from the layer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>The index of the scale band </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The requested scale band, or NULL on error. The band may be modified but remains owned by the <a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a>. </dd></dl>

</div>
</div>
<a id="a1a96e295488d4c0ac7f397b8154fb762" name="a1a96e295488d4c0ac7f397b8154fb762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a96e295488d4c0ac7f397b8154fb762">&#9670;&#160;</a></span>loadData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDirectImportDataLayer::loadData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a> *</td>          <td class="paramname"><span class="paramname"><em>dataSet</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_feature_class_config.html">TSLFeatureClassConfig</a> *</td>          <td class="paramname"><span class="paramname"><em>config</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load and display a data set.</p>
<p>The provided <a class="el" href="class_t_s_l_feature_class_config.html">TSLFeatureClassConfig</a> will be used to determine feature masking, classification, and rendering of the data.</p>
<p>The provided data will be scheduled to load asynchronously. The application must provide an implementation of <a class="el" href="class_t_s_l_direct_import_data_layer_callbacks.html">TSLDirectImportDataLayerCallbacks</a> in order to be notified when the load/processing has completed.</p>
<p>The data will be loaded into an appropriate scale band, based on the scale of the data. This scale calculation will not normally be performed for vector data sets, so applications must ensure <a class="el" href="class_t_s_l_direct_import_data_set.html#a01c1bcbcd43cec5a57e2be36c6e174d0">TSLDirectImportDataSet::scale</a> is correct when using this method.</p>
<p>Data may be loaded into a specific scale band by calling <a class="el" href="class_t_s_l_direct_import_scale_band.html#a71c3d78eebb7b03b076f6d12cf4e66d4">TSLDirectImportScaleBand::loadData</a>.</p>
<p><a class="el" href="class_t_s_l_direct_import_data_set.html#a518a186d8b9b71ad09d7e73320def4cc">TSLDirectImportDataSet::minDisplayScale</a> and <a class="el" href="class_t_s_l_direct_import_data_set.html#a4623d82d57218fb2194862efc64a4b65">TSLDirectImportDataSet::maxDisplayScale</a> may be used to further limit the display of the dataset within the band.</p>
<p>If a <a class="el" href="class_t_s_l_direct_import_data_set_multi_level_raster.html">TSLDirectImportDataSetMultiLevelRaster</a> is loaded then any child data sets will be used in order to provide efficient processing/display within the scale band. The min/max display scale of the base data set and each child will be set accordingly in order to achieve this.</p>
<p>Features will be rendered based on the provided <a class="el" href="class_t_s_l_feature_class_config.html">TSLFeatureClassConfig</a>. If the features within the configuration belong to a product specification this will need to be set on the dataset via <a class="el" href="class_t_s_l_direct_import_data_set.html#a901aae36d7b92ccd3ed38391015d5f36">TSLDirectImportDataSet::product</a> prior to loading.</p>
<p>Rendering may be specified on a per-dataset basis using product specifications, and multiple feature configurations. Rendering may be specified on a per-scale band basis using multiple feature configurations.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataSet</td><td>The data to load. This object may be created by calling createDataSets. The application retains ownership of this object. </td></tr>
    <tr><td class="paramname">config</td><td>The feature configuration object to use. This must be provided for vector datasets.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the loaded dataset, or NULL on error. </dd></dl>

</div>
</div>
<a id="a482ebff34ca29e90ee74de54fa42e5b3" name="a482ebff34ca29e90ee74de54fa42e5b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482ebff34ca29e90ee74de54fa42e5b3">&#9670;&#160;</a></span>maxDiskCacheSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TSLDirectImportDataLayer::maxDiskCacheSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the maximum cache size for on-disk data</p>
<dl class="section return"><dt>Returns</dt><dd>The maximum cache size in KB </dd></dl>

</div>
</div>
<a id="aec3fe3109a7e03cbefed9269453f0f81" name="aec3fe3109a7e03cbefed9269453f0f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec3fe3109a7e03cbefed9269453f0f81">&#9670;&#160;</a></span>maxDiskCacheSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDataLayer::maxDiskCacheSize </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>maxSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the maximum cache size for on-disk data</p>
<p>This setting will directly affect load/processing performance. If it is too low, the datalayer will need to reprocess from source data in order to display a tile.</p>
<p>By default there is no limit for the on-disk cache.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxSize</td><td>The maximum cache size in KB. A setting of 0 means unlimited. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a67f52efe935278620254d13ec08cb37f" name="a67f52efe935278620254d13ec08cb37f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67f52efe935278620254d13ec08cb37f">&#9670;&#160;</a></span>maxMemoryCacheSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TSLDirectImportDataLayer::maxMemoryCacheSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the maximum cache size for in-memory data</p>
<dl class="section return"><dt>Returns</dt><dd>The maximum cache size in KB </dd></dl>

</div>
</div>
<a id="a4c1d97b005ce2d6a2dd8549503c888a4" name="a4c1d97b005ce2d6a2dd8549503c888a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1d97b005ce2d6a2dd8549503c888a4">&#9670;&#160;</a></span>maxMemoryCacheSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDataLayer::maxMemoryCacheSize </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>maxSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the maximum cache size for in-memory data</p>
<p>This setting will directly affect the number of tiles which can be displayed at a time. If this setting is too low the datalayer may not draw all of the tiles within the drawing surface's view. This setting will also affect load/processing performance, especially if the on-disk cache is small. By default this settings is 256MB</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxSize</td><td>The maximum cache size in KB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0f94738758cf0738c07f20de1bea0167" name="a0f94738758cf0738c07f20de1bea0167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f94738758cf0738c07f20de1bea0167">&#9670;&#160;</a></span>maxRasterDrawCacheSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TSLDirectImportDataLayer::maxRasterDrawCacheSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the maximum size of the raster draw cache</p>
<dl class="section return"><dt>Returns</dt><dd>The maximum cache size in KB </dd></dl>

</div>
</div>
<a id="a67a2f873a718b5bbf8ad9bf5e8191162" name="a67a2f873a718b5bbf8ad9bf5e8191162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67a2f873a718b5bbf8ad9bf5e8191162">&#9670;&#160;</a></span>maxRasterDrawCacheSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDataLayer::maxRasterDrawCacheSize </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>maxSize</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the maximum cache size for the raster draw cache</p>
<p>This setting will limit the maximum amount of processed raster data loaded into memory at a time If this limit is exceeded, raster data may not be displayed, and may stall the map display while data is loaded from disk.</p>
<p>This setting will only affect the drawing of raster data, and will have no impact on data processing. By default this setting is 256MB</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxSize</td><td>The maximum cache size in KB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa627269818051e33d2d628ea5d345b46" name="aa627269818051e33d2d628ea5d345b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa627269818051e33d2d628ea5d345b46">&#9670;&#160;</a></span>numDrivers()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int TSLDirectImportDataLayer::numDrivers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Query the number of available direct import drivers </p>

</div>
</div>
<a id="a12212706e645d59a428ea7e70b9db538" name="a12212706e645d59a428ea7e70b9db538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12212706e645d59a428ea7e70b9db538">&#9670;&#160;</a></span>numProcessingThreads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TSLDirectImportDataLayer::numProcessingThreads </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the number processing threads</p>
<dl class="section return"><dt>Returns</dt><dd>The number of threads used by the layer to load/process data. </dd></dl>

</div>
</div>
<a id="a30fc75e90c7d0405a32b4ad8383a93b8" name="a30fc75e90c7d0405a32b4ad8383a93b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30fc75e90c7d0405a32b4ad8383a93b8">&#9670;&#160;</a></span>numProcessingThreads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDataLayer::numProcessingThreads </td>
          <td>(</td>
          <td class="paramtype">unsigned int</td>          <td class="paramname"><span class="paramname"><em>numThreads</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the number of processing threads</p>
<p>By default the layer will use 1 processing thread.</p>
<p>Increasing the number of processing threads will allow the data layer to process data faster, however may cause a large increase in the amount of memory used. This depends on the direct import driver being used, and the source data type. For most applications 1 or 2 processing threads should be enough.</p>
<p>A value of zero will set the number of threads to 1 per CPU core.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">numThreads</td><td>The number of threads to use for processing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a92c139dd8b014db21a2a537018471146" name="a92c139dd8b014db21a2a537018471146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c139dd8b014db21a2a537018471146">&#9670;&#160;</a></span>numScaleBands()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int TSLDirectImportDataLayer::numScaleBands </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the number of scale bands within the layer</p>
<dl class="section return"><dt>Returns</dt><dd>The number of scale bands configured on this layer </dd></dl>

</div>
</div>
<a id="a784ab3b2348fbb9cba3c5422cdcdd529" name="a784ab3b2348fbb9cba3c5422cdcdd529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784ab3b2348fbb9cba3c5422cdcdd529">&#9670;&#160;</a></span>operator new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLDirectImportDataLayer::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocation override for API redirection. </p>

</div>
</div>
<a id="a0c10af9539022bccce85a1ffe0eb2552" name="a0c10af9539022bccce85a1ffe0eb2552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c10af9539022bccce85a1ffe0eb2552">&#9670;&#160;</a></span>operator new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLDirectImportDataLayer::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When included in an MFC application in debug mode, the debug new expects this to be here. Override it and return the same as the normal one. The library must include it when compiled in release mode, since the user's application may be in debug mode. </p>

</div>
</div>
<a id="a76917950eb91678f2d18d5c437a53dbf" name="a76917950eb91678f2d18d5c437a53dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76917950eb91678f2d18d5c437a53dbf">&#9670;&#160;</a></span>preprocessData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDirectImportDataLayer::preprocessData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>extent</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_direct_import_data_set.html">TSLDirectImportDataSet</a> *</td>          <td class="paramname"><span class="paramname"><em>dataSet</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_direct_import_scale_band.html">TSLDirectImportScaleBand</a> *</td>          <td class="paramname"><span class="paramname"><em>scaleBand</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>minScale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>maxScale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">(std::numeric_limits&lt;&#160;double&#160;&gt;::max)()</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manually pre-process/schedule tiles</p>
<p>By default the layer will create and schedule tiles as needed when the layer is drawn. This can result in a noticeable delay before data appears, while the data is being processed.</p>
<p>This method is provided to allow an application to pre-process data into the cache in order to minimise this delay.</p>
<p>This method should only be used for pre-processing and should not be called while the application is interacting with the map display.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">extent</td><td>The extent to schedule tiles within. </td></tr>
    <tr><td class="paramname">dataSet</td><td>The dataset to schedule tiles for. If NULL tiles will be scheduled for all datasets. </td></tr>
    <tr><td class="paramname">scaleBand</td><td>The scale band to schedule tiles for. If NULL tiles will be scheduled for all scale bands. </td></tr>
    <tr><td class="paramname">minScale</td><td>The minimum display scale to schedule tiles for. </td></tr>
    <tr><td class="paramname">maxScale</td><td>The maximum display scale to schedule tiles for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if any tiles were scheduled, false otherwise. </dd></dl>

</div>
</div>
<a id="a3345ae7d7009dc76eb6ea105bd4f64ec" name="a3345ae7d7009dc76eb6ea105bd4f64ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3345ae7d7009dc76eb6ea105bd4f64ec">&#9670;&#160;</a></span>setAnalysisCallbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDataLayer::setAnalysisCallbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_direct_import_data_layer_analysis_callbacks.html">TSLDirectImportDataLayerAnalysisCallbacks</a> *</td>          <td class="paramname"><span class="paramname"><em>callbacks</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the callback object for data analysis operations</p>
<p>This object will be used to return data to the application from <a class="el" href="#a2fdc43169bbab67aea4f9858db64e5b2">TSLDirectImportDataLayer::analyseData</a>.</p>
<p>If no analysis callback is set, <a class="el" href="#a2fdc43169bbab67aea4f9858db64e5b2">TSLDirectImportDataLayer::analyseData</a> will always return false.</p>
<dl class="section note"><dt>Note</dt><dd>If the application-provided callback object is destroyed the application must call setCallbacks(NULL). </dd>
<dd>
Any application-provided callback must not be destroyed before the datalayer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbacks</td><td>The callback object to use. Passing NULL will reset the callback to the default behaviour. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41d5943cc5eeecd6eb7be1bd2b796ca9" name="a41d5943cc5eeecd6eb7be1bd2b796ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d5943cc5eeecd6eb7be1bd2b796ca9">&#9670;&#160;</a></span>setCallbacks()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDataLayer::setCallbacks </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_direct_import_data_layer_callbacks.html">TSLDirectImportDataLayerCallbacks</a> *</td>          <td class="paramname"><span class="paramname"><em>callbacks</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the callback object</p>
<p>This object will be used to notify the application of progress, and when additional information is required to complete an operation.</p>
<p>If no callbacks are set, the datalayer will use a default implementation.</p>
<dl class="section note"><dt>Note</dt><dd>If the application-provided callback object is destroyed the application must call setCallbacks(NULL). </dd>
<dd>
Any application-provided callback must not be destroyed before the datalayer.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callbacks</td><td>The callback object to use. Passing NULL will reset the callbacks to the default behaviour. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af66d9b8b7914f50ec685d13b4c804a2c" name="af66d9b8b7914f50ec685d13b4c804a2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af66d9b8b7914f50ec685d13b4c804a2c">&#9670;&#160;</a></span>synchronousDisplay() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDirectImportDataLayer::synchronousDisplay </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get whether the layer will use synchronous display.</p>
<p>This is disabled by default.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the layer uses synchronous display, false otherwise. </dd></dl>

</div>
</div>
<a id="a2f1410e04c8d61d943e1fbe5dd59e8a9" name="a2f1410e04c8d61d943e1fbe5dd59e8a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1410e04c8d61d943e1fbe5dd59e8a9">&#9670;&#160;</a></span>synchronousDisplay() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDirectImportDataLayer::synchronousDisplay </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>synchronous</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables/disables synchronous display.</p>
<p>This is disabled by default.</p>
<p>If enabled, the application will not return from the draw function until all data has been processed and displayed. This ensures that no blank areas will appear on the screen while panning/zooming.</p>
<dl class="section note"><dt>Note</dt><dd>When enabled, the layer will switch to using a <a class="el" href="class_t_s_l_file_loader_blocking.html">TSLFileLoaderBlocking</a>. When disabled, it will use a <a class="el" href="class_t_s_l_file_loader_m_t.html">TSLFileLoaderMT</a>. </dd>
<dd>
Enabling this when loading large amounts of data may cause your application to stutter.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">synchronous</td><td>true enables synchronous display, false disables it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_direct_import_data_layer.html">TSLDirectImportDataLayer</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.2 | Documentation created Wed Jul 23 2025 18:04:00 | Generated with <a href="http://www.doxygen.org/index.html">Doxygen 1.13.2</a> | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
