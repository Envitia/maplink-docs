<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLMapDataLayer Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.2</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_map_data_layer.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="class_t_s_l_map_data_layer-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLMapDataLayer Class Reference<div class="ingroups"><a class="el" href="group__apigroup__maplink__pro__developers__toolkit.html">MapLink Pro Developer Toolkit</a> &raquo; <a class="el" href="group__apigroup__api.html">Core API</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for TSLMapDataLayer:</div>
<div class="dyncontent">
<div class="center"><img src="class_t_s_l_map_data_layer__inherit__graph.png" border="0" usemap="#a_t_s_l_map_data_layer_inherit__map" alt="Inheritance graph"/></div>
<map name="a_t_s_l_map_data_layer_inherit__map" id="a_t_s_l_map_data_layer_inherit__map">
<area shape="rect" title=" " alt="" coords="5,76,115,99"/>
<area shape="rect" href="class_t_s_l_data_layer.html" title=" " alt="" coords="15,5,105,28"/>
<area shape="poly" title=" " alt="" coords="63,41,63,76,57,76,57,41"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Specialist data layer for the manipulation of map data.</p>
<p>The <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> component handles map data manipulation. Map data is read-only and modification of this layer by the user is limited to changing the rendering of the entities within it.</p>
<p>The following capabilities are available through the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> component:</p><ul>
<li>Loading data</li>
<li>Cache management</li>
<li>Rendering</li>
<li>Miscellaneous</li>
</ul>
<p>The methods 'loadData' and 'removeData' (inherited from <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>) allow complete maps to be loaded into and removed from the map layer.</p>
<p>Cache management is an important area for the map layer since it is not normally possible to hold a complete map in memory. The cache functions allows the user to fine tune the performance of a map layer by setting aside memory to hold recently accessed areas of the map so that they do not need to be loaded from disk when requested. The following cache properties are available:</p><ul>
<li>cacheSize , which determines how much memory to use for the cache</li>
<li>cacheFlushLimit which determines how many map models to leave in memory when the cache needs to be flushed.</li>
<li>clearCache method will clear all map models from memory.</li>
</ul>
<p>Instances of this class should be destroyed using the destroy method. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2ccca01cfd9b6783380cd8e3d48941e1" id="r_a2ccca01cfd9b6783380cd8e3d48941e1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ccca01cfd9b6783380cd8e3d48941e1">TSLMapDataLayer</a> ()</td></tr>
<tr class="separator:a2ccca01cfd9b6783380cd8e3d48941e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a710fa5bac0c7ac3537779a5f06376b35" id="r_a710fa5bac0c7ac3537779a5f06376b35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a710fa5bac0c7ac3537779a5f06376b35">cacheFlushLimit</a> (int flush_limit)</td></tr>
<tr class="separator:a710fa5bac0c7ac3537779a5f06376b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276b47f0fdeadbad6d2789b76129026e" id="r_a276b47f0fdeadbad6d2789b76129026e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a276b47f0fdeadbad6d2789b76129026e">cacheFlushLimit</a> () const</td></tr>
<tr class="separator:a276b47f0fdeadbad6d2789b76129026e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d8a03ed726fd48ee2ccc35a49653210" id="r_a8d8a03ed726fd48ee2ccc35a49653210"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d8a03ed726fd48ee2ccc35a49653210">cacheSize</a> (int new_size)</td></tr>
<tr class="separator:a8d8a03ed726fd48ee2ccc35a49653210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44756b5b6afb559440fa46007b609c4" id="r_ac44756b5b6afb559440fa46007b609c4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac44756b5b6afb559440fa46007b609c4">cacheSize</a> () const</td></tr>
<tr class="separator:ac44756b5b6afb559440fa46007b609c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21fa54d37d885cd1ad96e6b8eef4bbbc" id="r_a21fa54d37d885cd1ad96e6b8eef4bbbc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21fa54d37d885cd1ad96e6b8eef4bbbc">clearCache</a> ()</td></tr>
<tr class="separator:a21fa54d37d885cd1ad96e6b8eef4bbbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af07f429196bc524aeb46c9007243d5da" id="r_af07f429196bc524aeb46c9007243d5da"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af07f429196bc524aeb46c9007243d5da">clearRuntimeProjection</a> ()</td></tr>
<tr class="separator:af07f429196bc524aeb46c9007243d5da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5094eaca7fafdd693186eee20ba72d3b" id="r_a5094eaca7fafdd693186eee20ba72d3b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5094eaca7fafdd693186eee20ba72d3b">configurePersistentCache</a> (const <a class="el" href="class_t_s_l_persistent_cache_data.html">TSLPersistentCacheData</a> *settings, <a class="el" href="group__apigroup__api.html#ga18dead260efa2e858acfd1b9e021a761">TSLTileValidationFn</a> validationFn=NULL, void *arg=NULL)</td></tr>
<tr class="separator:a5094eaca7fafdd693186eee20ba72d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a906282893732ec6e00ebe0748042c4ba" id="r_a906282893732ec6e00ebe0748042c4ba"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a906282893732ec6e00ebe0748042c4ba">copyRasterFeatures</a> (<a class="el" href="class_t_s_l_raster_data_layer.html">TSLRasterDataLayer</a> *rasterDataLayer, const char *destPath, const char *layerName=NULL, TSLFeatureID featureID=0, <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> *envelope=NULL, <a class="el" href="group__apigroup__api.html#gab0b9f8e5dfebf451f2944aee7dfa0b8d">TSLCopyFilesCallback</a> progressCallback=NULL, void *arg=NULL)</td></tr>
<tr class="separator:a906282893732ec6e00ebe0748042c4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b9ac87a18507f210b9a7c9ff17cd10" id="r_a87b9ac87a18507f210b9a7c9ff17cd10"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a87b9ac87a18507f210b9a7c9ff17cd10">findEntityID</a> (TSLEntityID entityID, <a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> *handler)</td></tr>
<tr class="separator:a87b9ac87a18507f210b9a7c9ff17cd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a44e3b6cf9e67c66d922b38910e788" id="r_a98a44e3b6cf9e67c66d922b38910e788"><td class="memItemLeft" align="right" valign="top">TSLStyleID&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98a44e3b6cf9e67c66d922b38910e788">getBackgroundColour</a> () const</td></tr>
<tr class="separator:a98a44e3b6cf9e67c66d922b38910e788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a294e5a3c3397604d3fcf97b12e70e495" id="r_a294e5a3c3397604d3fcf97b12e70e495"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a294e5a3c3397604d3fcf97b12e70e495">getDetailLayerMUExtent</a> (const char *layer_name, double *x1, double *y1, double *x2, double *y2) const</td></tr>
<tr class="separator:a294e5a3c3397604d3fcf97b12e70e495"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28a0a5258240811064564fd0cd470c87" id="r_a28a0a5258240811064564fd0cd470c87"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a28a0a5258240811064564fd0cd470c87">getDetailLayerName</a> (int nth) const</td></tr>
<tr class="separator:a28a0a5258240811064564fd0cd470c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb4b22ccf312646c7c07522d4aa4d1ae" id="r_acb4b22ccf312646c7c07522d4aa4d1ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb4b22ccf312646c7c07522d4aa4d1ae">getDetailLayerTMCExtent</a> (const char *layer_name, TSLTMC *x1, TSLTMC *y1, TSLTMC *x2, TSLTMC *y2) const</td></tr>
<tr class="separator:acb4b22ccf312646c7c07522d4aa4d1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72834e897afe7158d697bc8e82dab73c" id="r_a72834e897afe7158d697bc8e82dab73c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72834e897afe7158d697bc8e82dab73c">getDynamicRendererFeatureBookSection</a> (int indexOfRenderer, int indexOfFeatureBookSection, int &amp;featureBookSectionNumber, const char *&amp;featureBookSectionName) const</td></tr>
<tr class="separator:a72834e897afe7158d697bc8e82dab73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30d6a19763ef8bee47ac9736ae6141ef" id="r_a30d6a19763ef8bee47ac9736ae6141ef"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a30d6a19763ef8bee47ac9736ae6141ef">getDynamicRendererHint</a> (int index) const</td></tr>
<tr class="separator:a30d6a19763ef8bee47ac9736ae6141ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6150a3a0e8e147f34655997df5edbac" id="r_ac6150a3a0e8e147f34655997df5edbac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6150a3a0e8e147f34655997df5edbac">getLayerLoadingThreshold</a> (const char *layerName, double *upperThreshold, double *lowerThreshold) const</td></tr>
<tr class="separator:ac6150a3a0e8e147f34655997df5edbac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7f293743c448bfaf2136bbb81d6e6e" id="r_a7b7f293743c448bfaf2136bbb81d6e6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b7f293743c448bfaf2136bbb81d6e6e">getNumDetailLayers</a> () const</td></tr>
<tr class="separator:a7b7f293743c448bfaf2136bbb81d6e6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022af641b67109e7314b22eeea6e8bdf" id="r_a022af641b67109e7314b22eeea6e8bdf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a022af641b67109e7314b22eeea6e8bdf">getNumDynamicRendererFeatureBookSections</a> (int indexOfRenderer) const</td></tr>
<tr class="separator:a022af641b67109e7314b22eeea6e8bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a789dd579537d175aab8c1d4147f2bc7d" id="r_a789dd579537d175aab8c1d4147f2bc7d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a789dd579537d175aab8c1d4147f2bc7d">getNumDynamicRendererHints</a> () const</td></tr>
<tr class="separator:a789dd579537d175aab8c1d4147f2bc7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cce35134867eee864a3ee69d50c81c7" id="r_a4cce35134867eee864a3ee69d50c81c7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4cce35134867eee864a3ee69d50c81c7">getOverviewLayer</a> () const</td></tr>
<tr class="separator:a4cce35134867eee864a3ee69d50c81c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad637096fd1cb42dd7963f8e24a7e9113" id="r_ad637096fd1cb42dd7963f8e24a7e9113"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad637096fd1cb42dd7963f8e24a7e9113">getPaletteFilename</a> (<a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;filename) const</td></tr>
<tr class="separator:ad637096fd1cb42dd7963f8e24a7e9113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc73734d65213ee2f916fa97ebb40ced" id="r_adc73734d65213ee2f916fa97ebb40ced"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc73734d65213ee2f916fa97ebb40ced">getPathlistFilename</a> (<a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;filename) const</td></tr>
<tr class="separator:adc73734d65213ee2f916fa97ebb40ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3478ffe6864846ffe3e03fcd19b6df3" id="r_af3478ffe6864846ffe3e03fcd19b6df3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af3478ffe6864846ffe3e03fcd19b6df3">getSynchronousLoading</a> () const</td></tr>
<tr class="separator:af3478ffe6864846ffe3e03fcd19b6df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e325759b914ca805a882a394e28ba9" id="r_a02e325759b914ca805a882a394e28ba9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02e325759b914ca805a882a394e28ba9">isRuntimeProjected</a> () const</td></tr>
<tr class="separator:a02e325759b914ca805a882a394e28ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee9566d06a292591ef3954e8f4b789f" id="r_a6ee9566d06a292591ef3954e8f4b789f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6ee9566d06a292591ef3954e8f4b789f">metadata</a> (int pos, char **fileName)</td></tr>
<tr class="separator:a6ee9566d06a292591ef3954e8f4b789f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac62b1846a86977da2c4fd0133c109b31" id="r_ac62b1846a86977da2c4fd0133c109b31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac62b1846a86977da2c4fd0133c109b31">metadata</a> (int sourceID, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;filename) const</td></tr>
<tr class="separator:ac62b1846a86977da2c4fd0133c109b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331795bd9d7475cc53f859fa209bc46e" id="r_a331795bd9d7475cc53f859fa209bc46e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a331795bd9d7475cc53f859fa209bc46e">metadataCount</a> () const</td></tr>
<tr class="separator:a331795bd9d7475cc53f859fa209bc46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bdd26a710e89b7822de17189a9e7076" id="r_a6bdd26a710e89b7822de17189a9e7076"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6bdd26a710e89b7822de17189a9e7076">MUToTMC</a> (double x1, double y1, TSLTMC *x2, TSLTMC *y2) const</td></tr>
<tr class="separator:a6bdd26a710e89b7822de17189a9e7076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c00175179efc3b7241349e818fdbb77" id="r_a5c00175179efc3b7241349e818fdbb77"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c00175179efc3b7241349e818fdbb77">queryMapCoordinateSystem</a> () const</td></tr>
<tr class="separator:a5c00175179efc3b7241349e818fdbb77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d9052de8b13f19648072d900134b74" id="r_a40d9052de8b13f19648072d900134b74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a40d9052de8b13f19648072d900134b74">queryRuntimeCoordinateSystem</a> () const</td></tr>
<tr class="separator:a40d9052de8b13f19648072d900134b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac55fac41609f745dd4dffdcd042cfb27" id="r_ac55fac41609f745dd4dffdcd042cfb27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac55fac41609f745dd4dffdcd042cfb27">removeLayer</a> (const char *layer_name)</td></tr>
<tr class="separator:ac55fac41609f745dd4dffdcd042cfb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd1ba15e2307d95ac906437273ca44c" id="r_accd1ba15e2307d95ac906437273ca44c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accd1ba15e2307d95ac906437273ca44c">setLayerLoadingThreshold</a> (const char *layerName, double upperThreshold, double lowerThreshold=0.0)</td></tr>
<tr class="separator:accd1ba15e2307d95ac906437273ca44c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cf5e003b473c98afedb233ce88a482a" id="r_a7cf5e003b473c98afedb233ce88a482a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7cf5e003b473c98afedb233ce88a482a">setOverrideCol</a> (TSLStyleID override_colour=0)</td></tr>
<tr class="separator:a7cf5e003b473c98afedb233ce88a482a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c7714ee46fde54dd4dc0b05433c019c" id="r_a8c7714ee46fde54dd4dc0b05433c019c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c7714ee46fde54dd4dc0b05433c019c">setRuntimeProjection</a> (const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *projection, double greatCircleDistance, <a class="el" href="group__apigroup__api.html#ga7888cf9886effdc2859c911f4771dfcd">TSLRuntimeProjectionChangedCallback</a> callback, void *arg)</td></tr>
<tr class="separator:a8c7714ee46fde54dd4dc0b05433c019c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fc66b1e309a850b07267a794c1634ea" id="r_a3fc66b1e309a850b07267a794c1634ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fc66b1e309a850b07267a794c1634ea">setRuntimeProjectionOrigin</a> (double latitude, double longitude, <a class="el" href="group__apigroup__api.html#ga7888cf9886effdc2859c911f4771dfcd">TSLRuntimeProjectionChangedCallback</a> callback, void *arg)</td></tr>
<tr class="separator:a3fc66b1e309a850b07267a794c1634ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef0f8b8714df83f50ee67b70c3bc4a78" id="r_aef0f8b8714df83f50ee67b70c3bc4a78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef0f8b8714df83f50ee67b70c3bc4a78">setRuntimeProjectionParameters</a> (TSLTMC initialTMCperMU=50, TSLTMC tmcPerMUFactor=10, bool detailedExtentCheck=false, int quickCheckGrid=3, int quickCheckPoints=32, int detailedCheckGrid=16, int detailedCheckPoints=128, double tileExtentGrowthScale=0.005)</td></tr>
<tr class="separator:aef0f8b8714df83f50ee67b70c3bc4a78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb145d4db4c419aeebd578e549738dbf" id="r_acb145d4db4c419aeebd578e549738dbf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acb145d4db4c419aeebd578e549738dbf">setSynchronousLoading</a> (bool synchronous)</td></tr>
<tr class="separator:acb145d4db4c419aeebd578e549738dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1484346e0cad2b8dbd40f9ead7d488" id="r_ade1484346e0cad2b8dbd40f9ead7d488"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ade1484346e0cad2b8dbd40f9ead7d488">setTransparent</a> (bool trans_mode=false, TSLStyleID trans_colour=0)</td></tr>
<tr class="separator:ade1484346e0cad2b8dbd40f9ead7d488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6471adbcd47524e55f5453aeba0fa02f" id="r_a6471adbcd47524e55f5453aeba0fa02f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6471adbcd47524e55f5453aeba0fa02f">TMCperMU</a> () const</td></tr>
<tr class="separator:a6471adbcd47524e55f5453aeba0fa02f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8624a2855a49009008dfbdd4c347c33" id="r_ae8624a2855a49009008dfbdd4c347c33"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae8624a2855a49009008dfbdd4c347c33">TMCToMU</a> (TSLTMC x1, TSLTMC y1, double *x2, double *y2) const</td></tr>
<tr class="separator:ae8624a2855a49009008dfbdd4c347c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f4e478d6022e77537ae5a71a3f6bc0" id="r_a50f4e478d6022e77537ae5a71a3f6bc0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a50f4e478d6022e77537ae5a71a3f6bc0">validateCache</a> ()</td></tr>
<tr class="separator:a50f4e478d6022e77537ae5a71a3f6bc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b656957f317b5c0c94328f44b7003b" id="r_a49b656957f317b5c0c94328f44b7003b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49b656957f317b5c0c94328f44b7003b">operator new</a> (size_t size) TSL_NO_THROW</td></tr>
<tr class="separator:a49b656957f317b5c0c94328f44b7003b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a45506d61b8a6e11c67e0208d99e14" id="r_ad6a45506d61b8a6e11c67e0208d99e14"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6a45506d61b8a6e11c67e0208d99e14">operator new</a> (size_t size, char *filename, int line)</td></tr>
<tr class="separator:ad6a45506d61b8a6e11c67e0208d99e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_t_s_l_data_layer"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_class_t_s_l_data_layer')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a></td></tr>
<tr class="memitem:a4fbc03b97523bbe9eb21cfefb8b545de inherit pub_methods_class_t_s_l_data_layer" id="r_a4fbc03b97523bbe9eb21cfefb8b545de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a4fbc03b97523bbe9eb21cfefb8b545de">addDrawingCallback</a> (<a class="el" href="class_t_s_l_data_layer_drawing_callback.html">TSLDataLayerDrawingCallback</a> *drawingCallback)</td></tr>
<tr class="separator:a4fbc03b97523bbe9eb21cfefb8b545de inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10e9a5296f10a07340cc465b5ca9466f inherit pub_methods_class_t_s_l_data_layer" id="r_a10e9a5296f10a07340cc465b5ca9466f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a10e9a5296f10a07340cc465b5ca9466f">addFeatureRendering</a> (const char *featureName, TSLFeatureID featureID)</td></tr>
<tr class="separator:a10e9a5296f10a07340cc465b5ca9466f inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f31630e6fda8c34be66ef6dc987ff0 inherit pub_methods_class_t_s_l_data_layer" id="r_a17f31630e6fda8c34be66ef6dc987ff0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a17f31630e6fda8c34be66ef6dc987ff0">addLoader</a> (<a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *loader, <a class="el" href="group__apigroup__api.html#ga48f96f9ef6e81104016f6904e8883230">TSLLoaderAppCallback</a> callback, void *arg, <a class="el" href="group__apigroup__api.html#ga11aea432930000091575dc2fefca227d">TSLAllLoadedCallback</a> allLoadedCallback=0, void *arg2=0)</td></tr>
<tr class="separator:a17f31630e6fda8c34be66ef6dc987ff0 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2d9f8234df5031730501c6371e12d88 inherit pub_methods_class_t_s_l_data_layer" id="r_ac2d9f8234df5031730501c6371e12d88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ac2d9f8234df5031730501c6371e12d88">addPathList</a> (const <a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> *path_list)</td></tr>
<tr class="separator:ac2d9f8234df5031730501c6371e12d88 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3105441039ed9fb09713165dad545d9c inherit pub_methods_class_t_s_l_data_layer" id="r_a3105441039ed9fb09713165dad545d9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a3105441039ed9fb09713165dad545d9c">cancelFlashback</a> ()</td></tr>
<tr class="separator:a3105441039ed9fb09713165dad545d9c inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a991b7cfea7d673b7b3d9f9f4c64d5cfd inherit pub_methods_class_t_s_l_data_layer" id="r_a991b7cfea7d673b7b3d9f9f4c64d5cfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a991b7cfea7d673b7b3d9f9f4c64d5cfd">clearFeatureRendering</a> (const char *featureName, TSLFeatureID featureID)</td></tr>
<tr class="separator:a991b7cfea7d673b7b3d9f9f4c64d5cfd inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d4acea014d2126ae89eeb777cbebb26 inherit pub_methods_class_t_s_l_data_layer" id="r_a8d4acea014d2126ae89eeb777cbebb26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a8d4acea014d2126ae89eeb777cbebb26">createDataHandler</a> (const char *config_file=0)</td></tr>
<tr class="separator:a8d4acea014d2126ae89eeb777cbebb26 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02f02a7ea00e2ea18861508ffec7b024 inherit pub_methods_class_t_s_l_data_layer" id="r_a02f02a7ea00e2ea18861508ffec7b024"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a02f02a7ea00e2ea18861508ffec7b024">currentVersion</a> () const</td></tr>
<tr class="separator:a02f02a7ea00e2ea18861508ffec7b024 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8761e162ed667836db6f6ec2f21f1d8 inherit pub_methods_class_t_s_l_data_layer" id="r_ab8761e162ed667836db6f6ec2f21f1d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ab8761e162ed667836db6f6ec2f21f1d8">dataHandler</a> ()</td></tr>
<tr class="separator:ab8761e162ed667836db6f6ec2f21f1d8 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab86eea288d1ecae6b630954038ba1a2 inherit pub_methods_class_t_s_l_data_layer" id="r_aab86eea288d1ecae6b630954038ba1a2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_data_handler.html">TSLDataHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#aab86eea288d1ecae6b630954038ba1a2">dataHandler</a> () const</td></tr>
<tr class="separator:aab86eea288d1ecae6b630954038ba1a2 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cffcfd0ac1e02c02e845fc46411a25e inherit pub_methods_class_t_s_l_data_layer" id="r_a4cffcfd0ac1e02c02e845fc46411a25e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a4cffcfd0ac1e02c02e845fc46411a25e">destroy</a> ()</td></tr>
<tr class="separator:a4cffcfd0ac1e02c02e845fc46411a25e inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7c73aeed7bdbabd90e656b4db0d8ecb inherit pub_methods_class_t_s_l_data_layer" id="r_ad7c73aeed7bdbabd90e656b4db0d8ecb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ad7c73aeed7bdbabd90e656b4db0d8ecb">entityIsVisible</a> (const <a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *entity, const <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *drawingSurface) const</td></tr>
<tr class="separator:ad7c73aeed7bdbabd90e656b4db0d8ecb inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194db4f2f5e2c20b9b75285abaa8841b inherit pub_methods_class_t_s_l_data_layer" id="r_a194db4f2f5e2c20b9b75285abaa8841b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_feature_class_list.html">TSLFeatureClassList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a194db4f2f5e2c20b9b75285abaa8841b">featureList</a> () const</td></tr>
<tr class="separator:a194db4f2f5e2c20b9b75285abaa8841b inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af587d2e872c15803342eef1973cec1bb inherit pub_methods_class_t_s_l_data_layer" id="r_af587d2e872c15803342eef1973cec1bb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_feature_class_list.html">TSLFeatureClassList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#af587d2e872c15803342eef1973cec1bb">featureList</a> (const char *detailLayerName) const</td></tr>
<tr class="separator:af587d2e872c15803342eef1973cec1bb inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8997d0cbd428a6aa9783a4fd45a70cb5 inherit pub_methods_class_t_s_l_data_layer" id="r_a8997d0cbd428a6aa9783a4fd45a70cb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a8997d0cbd428a6aa9783a4fd45a70cb5">fileModificationTime</a> (const char *filename, TSLTimeType &amp;lastModificationTime)</td></tr>
<tr class="separator:a8997d0cbd428a6aa9783a4fd45a70cb5 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd7da13f831401661e0a63e19c52a64 inherit pub_methods_class_t_s_l_data_layer" id="r_abfd7da13f831401661e0a63e19c52a64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#abfd7da13f831401661e0a63e19c52a64">findEntity</a> (TSLTMC x, TSLTMC y, TSLTMC aperture, int depth, const char *featureName=0, int drawingSurfaceID=-1)</td></tr>
<tr class="separator:abfd7da13f831401661e0a63e19c52a64 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe90ad7a643c8cb39dac461e1ba9d367 inherit pub_methods_class_t_s_l_data_layer" id="r_afe90ad7a643c8cb39dac461e1ba9d367"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#afe90ad7a643c8cb39dac461e1ba9d367">findFile</a> (const char *filename, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;foundPath) const</td></tr>
<tr class="separator:afe90ad7a643c8cb39dac461e1ba9d367 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab953980469594aab11575009626c00b3 inherit pub_methods_class_t_s_l_data_layer" id="r_ab953980469594aab11575009626c00b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ab953980469594aab11575009626c00b3">flashbackToTimestamp</a> (<a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a> timestamp, <a class="el" href="group__apigroup__api.html#gaf92bab978dd0ee67b6781c3ca417e233">TSLLayerArchiveCallback</a> archiveCallback, void *arg=0)</td></tr>
<tr class="separator:ab953980469594aab11575009626c00b3 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c24847ea318be6604ec34d1d242aa62 inherit pub_methods_class_t_s_l_data_layer" id="r_a4c24847ea318be6604ec34d1d242aa62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a4c24847ea318be6604ec34d1d242aa62">flashbackToTimestamp</a> (<a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a> timestamp, <a class="el" href="group__apigroup__api.html#ga40ea9a3893d69e5865dc7c72f62b9ae2">TSLLayerArchiveTileCallback</a> archiveTileCallback, void *arg=0)</td></tr>
<tr class="separator:a4c24847ea318be6604ec34d1d242aa62 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd072130777b87c3ef6db086749845e5 inherit pub_methods_class_t_s_l_data_layer" id="r_abd072130777b87c3ef6db086749845e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#abd072130777b87c3ef6db086749845e5">flashbackToVersion</a> (<a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a> version, <a class="el" href="group__apigroup__api.html#gaf92bab978dd0ee67b6781c3ca417e233">TSLLayerArchiveCallback</a> archiveCallback, void *arg=0)</td></tr>
<tr class="separator:abd072130777b87c3ef6db086749845e5 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e8441c8c13520930ddb118c0fae0c0 inherit pub_methods_class_t_s_l_data_layer" id="r_a14e8441c8c13520930ddb118c0fae0c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a14e8441c8c13520930ddb118c0fae0c0">flashbackToVersion</a> (<a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a> version, <a class="el" href="group__apigroup__api.html#ga40ea9a3893d69e5865dc7c72f62b9ae2">TSLLayerArchiveTileCallback</a> archiveTileCallback, void *arg=0)</td></tr>
<tr class="separator:a14e8441c8c13520930ddb118c0fae0c0 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf439f3ddf34295b02e4a2e31eb1911 inherit pub_methods_class_t_s_l_data_layer" id="r_a9cf439f3ddf34295b02e4a2e31eb1911"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a9cf439f3ddf34295b02e4a2e31eb1911">getActiveLayerName</a> (const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent, double screenResolution, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;activeLayerName) const</td></tr>
<tr class="separator:a9cf439f3ddf34295b02e4a2e31eb1911 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62b5809179e31d019dec790177d42a6 inherit pub_methods_class_t_s_l_data_layer" id="r_ad62b5809179e31d019dec790177d42a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_entity_iterator.html">TSLEntityIterator</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ad62b5809179e31d019dec790177d42a6">getEntityIterator</a> (const char *detailLayer, <a class="el" href="class_t_s_l_selector.html">TSLSelector</a> *selector=NULL, <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> *extent=NULL, bool splitOptimisedPrimitives=true)</td></tr>
<tr class="separator:ad62b5809179e31d019dec790177d42a6 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b6bf865d0afde06a262fc7fb0edc43 inherit pub_methods_class_t_s_l_data_layer" id="r_a75b6bf865d0afde06a262fc7fb0edc43"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a75b6bf865d0afde06a262fc7fb0edc43">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a> attribute, int *result) const</td></tr>
<tr class="separator:a75b6bf865d0afde06a262fc7fb0edc43 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0232b2f236064f89665f1776dca140b inherit pub_methods_class_t_s_l_data_layer" id="r_af0232b2f236064f89665f1776dca140b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#af0232b2f236064f89665f1776dca140b">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a> attribute, double *result) const</td></tr>
<tr class="separator:af0232b2f236064f89665f1776dca140b inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a98dc01354ecec9c65eac5de8795e59 inherit pub_methods_class_t_s_l_data_layer" id="r_a6a98dc01354ecec9c65eac5de8795e59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a6a98dc01354ecec9c65eac5de8795e59">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a> attribute, bool *result) const</td></tr>
<tr class="separator:a6a98dc01354ecec9c65eac5de8795e59 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fae08a54978e8e2b0aa2344caeedf2d inherit pub_methods_class_t_s_l_data_layer" id="r_a3fae08a54978e8e2b0aa2344caeedf2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a3fae08a54978e8e2b0aa2344caeedf2d">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *result) const</td></tr>
<tr class="separator:a3fae08a54978e8e2b0aa2344caeedf2d inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35de696e1cd209e428c8da6c2f4e300b inherit pub_methods_class_t_s_l_data_layer" id="r_a35de696e1cd209e428c8da6c2f4e300b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a35de696e1cd209e428c8da6c2f4e300b">getLoader</a> ()</td></tr>
<tr class="separator:a35de696e1cd209e428c8da6c2f4e300b inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34074a432614a62093d349838dcdbfd2 inherit pub_methods_class_t_s_l_data_layer" id="r_a34074a432614a62093d349838dcdbfd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a34074a432614a62093d349838dcdbfd2">getMUExtent</a> (double *x1, double *y1, double *x2, double *y2, int drawingSurfaceID=-1) const</td></tr>
<tr class="separator:a34074a432614a62093d349838dcdbfd2 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7677906c203b52b4dde95807202e21f2 inherit pub_methods_class_t_s_l_data_layer" id="r_a7677906c203b52b4dde95807202e21f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a7677906c203b52b4dde95807202e21f2">getTMCExtent</a> (TSLTMC *x1, TSLTMC *y1, TSLTMC *x2, TSLTMC *y2, int drawingSurfaceID=-1) const</td></tr>
<tr class="separator:a7677906c203b52b4dde95807202e21f2 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bf18c76d0d8c476eb5ce835f16b69f inherit pub_methods_class_t_s_l_data_layer" id="r_ab0bf18c76d0d8c476eb5ce835f16b69f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ab0bf18c76d0d8c476eb5ce835f16b69f">getUUExtent</a> (double *x1, double *y1, double *x2, double *y2, const <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> *drawingSurface) const</td></tr>
<tr class="separator:ab0bf18c76d0d8c476eb5ce835f16b69f inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f186469525c8fb0b4cc9c415546492 inherit pub_methods_class_t_s_l_data_layer" id="r_a43f186469525c8fb0b4cc9c415546492"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a43f186469525c8fb0b4cc9c415546492">importHistory</a> (<a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a> mapVersion, <a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a> timestamp, <a class="el" href="class_t_s_l_history_import_set.html">TSLHistoryImportSet</a> *historySet)</td></tr>
<tr class="separator:a43f186469525c8fb0b4cc9c415546492 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242fafc67323bf7489430a1b1cf20a15 inherit pub_methods_class_t_s_l_data_layer" id="r_a242fafc67323bf7489430a1b1cf20a15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a242fafc67323bf7489430a1b1cf20a15">latLongToTMC</a> (double latitude, double longitude, TSLTMC *x, TSLTMC *y, bool local=false) const</td></tr>
<tr class="separator:a242fafc67323bf7489430a1b1cf20a15 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049b9cb6c75049b976a44a63a4fda83f inherit pub_methods_class_t_s_l_data_layer" id="r_a049b9cb6c75049b976a44a63a4fda83f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a049b9cb6c75049b976a44a63a4fda83f">latLongToTMC</a> (int num, double *latitudes, double *longitudes, TSLTMC *xs, TSLTMC *ys, bool local=false) const</td></tr>
<tr class="separator:a049b9cb6c75049b976a44a63a4fda83f inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc060243cb1337c3b8709c1cec683720 inherit pub_methods_class_t_s_l_data_layer" id="r_acc060243cb1337c3b8709c1cec683720"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apigroup__api.html#gaf8bedcb6358f6ef60075d2bbca8fe118">TSLDataLayerTypeEnum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#acc060243cb1337c3b8709c1cec683720">layerType</a> () const</td></tr>
<tr class="separator:acc060243cb1337c3b8709c1cec683720 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996e6ca3e3b9b10fc0f6fbe714a525a0 inherit pub_methods_class_t_s_l_data_layer" id="r_a996e6ca3e3b9b10fc0f6fbe714a525a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a996e6ca3e3b9b10fc0f6fbe714a525a0">loadData</a> (const char *filename)</td></tr>
<tr class="separator:a996e6ca3e3b9b10fc0f6fbe714a525a0 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5882d7ca1362bf7dce2ceff2e08d5b1 inherit pub_methods_class_t_s_l_data_layer" id="r_ad5882d7ca1362bf7dce2ceff2e08d5b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ad5882d7ca1362bf7dce2ceff2e08d5b1">loadRendering</a> (const char *filename)</td></tr>
<tr class="separator:ad5882d7ca1362bf7dce2ceff2e08d5b1 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05b87a4127970755ed66caaf44e48de9 inherit pub_methods_class_t_s_l_data_layer" id="r_a05b87a4127970755ed66caaf44e48de9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a05b87a4127970755ed66caaf44e48de9">notifyChanged</a> (bool changed=true)</td></tr>
<tr class="separator:a05b87a4127970755ed66caaf44e48de9 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1794ff9ca4ebbea2ee17986729de0b3c inherit pub_methods_class_t_s_l_data_layer" id="r_a1794ff9ca4ebbea2ee17986729de0b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a1794ff9ca4ebbea2ee17986729de0b3c">query</a> (TSLTMC x1, TSLTMC y1, TSLTMC x2, TSLTMC y2, int depth=-1, const char *featureName=NULL, int drawingSurfaceID=-1) const</td></tr>
<tr class="separator:a1794ff9ca4ebbea2ee17986729de0b3c inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80490627af3ab4871812115802c56359 inherit pub_methods_class_t_s_l_data_layer" id="r_a80490627af3ab4871812115802c56359"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_map_query.html">TSLMapQuery</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a80490627af3ab4871812115802c56359">query</a> (TSLTMC x1, TSLTMC y1, TSLTMC x2, TSLTMC y2, <a class="el" href="class_t_s_l_selector.html">TSLSelector</a> *selector, int drawingSurfaceID=-1) const</td></tr>
<tr class="separator:a80490627af3ab4871812115802c56359 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37b71c959052cf95ffcdbd00d0912603 inherit pub_methods_class_t_s_l_data_layer" id="r_a37b71c959052cf95ffcdbd00d0912603"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a37b71c959052cf95ffcdbd00d0912603">getCoordinateSystem</a> () const</td></tr>
<tr class="separator:a37b71c959052cf95ffcdbd00d0912603 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ad614ec1fb35434810d08e6a8ba8b5 inherit pub_methods_class_t_s_l_data_layer" id="r_a36ad614ec1fb35434810d08e6a8ba8b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a36ad614ec1fb35434810d08e6a8ba8b5">queryVersionHistory</a> (const <a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> &amp;extent, <a class="el" href="class_t_s_l_version_history_set.html">TSLVersionHistorySet</a> &amp;history)</td></tr>
<tr class="separator:a36ad614ec1fb35434810d08e6a8ba8b5 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad29ab355dbb41a0fcd809dcc7b11337 inherit pub_methods_class_t_s_l_data_layer" id="r_aad29ab355dbb41a0fcd809dcc7b11337"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#aad29ab355dbb41a0fcd809dcc7b11337">refreshFlashback</a> ()</td></tr>
<tr class="separator:aad29ab355dbb41a0fcd809dcc7b11337 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7de8beee6ba358591a22c0a2dd567a0 inherit pub_methods_class_t_s_l_data_layer" id="r_ab7de8beee6ba358591a22c0a2dd567a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ab7de8beee6ba358591a22c0a2dd567a0">removeData</a> ()</td></tr>
<tr class="separator:ab7de8beee6ba358591a22c0a2dd567a0 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4f727d73219da9ab2b94e0329a74607 inherit pub_methods_class_t_s_l_data_layer" id="r_ac4f727d73219da9ab2b94e0329a74607"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#ac4f727d73219da9ab2b94e0329a74607">releaseResources</a> (int surfaceID)</td></tr>
<tr class="separator:ac4f727d73219da9ab2b94e0329a74607 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b668fab4184d186d48ba860b7ca41ab inherit pub_methods_class_t_s_l_data_layer" id="r_a7b668fab4184d186d48ba860b7ca41ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a7b668fab4184d186d48ba860b7ca41ab">saveRendering</a> (const char *filename, <a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a> ver=<a class="el" href="group__apigroup__common.html#gga8141b1e165228e088c49024076e13758a0ecdea6c91f1d3104d6166d69b57c88d">TSL_CURRENT_MAPLINK_VERSION</a>)</td></tr>
<tr class="separator:a7b668fab4184d186d48ba860b7ca41ab inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c58b8475acb63c5a3f031e0cac28449 inherit pub_methods_class_t_s_l_data_layer" id="r_a8c58b8475acb63c5a3f031e0cac28449"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a8c58b8475acb63c5a3f031e0cac28449">setCoordinateSystem</a> (const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *coordinateSystem)</td></tr>
<tr class="separator:a8c58b8475acb63c5a3f031e0cac28449 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b60a990c7763ccb582dc2b59aa769f inherit pub_methods_class_t_s_l_data_layer" id="r_a15b60a990c7763ccb582dc2b59aa769f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a15b60a990c7763ccb582dc2b59aa769f">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a> attribute, int value)</td></tr>
<tr class="separator:a15b60a990c7763ccb582dc2b59aa769f inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01692e748c350a23675ad3d78807e684 inherit pub_methods_class_t_s_l_data_layer" id="r_a01692e748c350a23675ad3d78807e684"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a01692e748c350a23675ad3d78807e684">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a> attribute, double value)</td></tr>
<tr class="separator:a01692e748c350a23675ad3d78807e684 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1527856e58de4618ad218424738c6986 inherit pub_methods_class_t_s_l_data_layer" id="r_a1527856e58de4618ad218424738c6986"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a1527856e58de4618ad218424738c6986">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a> attribute, bool value)</td></tr>
<tr class="separator:a1527856e58de4618ad218424738c6986 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ac4671ad4be33730b564240532754b inherit pub_methods_class_t_s_l_data_layer" id="r_a74ac4671ad4be33730b564240532754b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a74ac4671ad4be33730b564240532754b">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *value)</td></tr>
<tr class="separator:a74ac4671ad4be33730b564240532754b inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab580b6f9a6e8a6615937256304489f inherit pub_methods_class_t_s_l_data_layer" id="r_a4ab580b6f9a6e8a6615937256304489f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a4ab580b6f9a6e8a6615937256304489f">TMCToLatLong</a> (TSLTMC x, TSLTMC y, double *latitude, double *longitude, bool local=false, bool boundCheck=true) const</td></tr>
<tr class="separator:a4ab580b6f9a6e8a6615937256304489f inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a568048fa9c27f7100df84bb1d08524fa inherit pub_methods_class_t_s_l_data_layer" id="r_a568048fa9c27f7100df84bb1d08524fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a568048fa9c27f7100df84bb1d08524fa">TMCToLatLong</a> (int num, TSLTMC *xs, TSLTMC *ys, double *latitudes, double *longitudes, bool local=false) const</td></tr>
<tr class="separator:a568048fa9c27f7100df84bb1d08524fa inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19803bde4b29d406445dd7a4b9aab850 inherit pub_methods_class_t_s_l_data_layer" id="r_a19803bde4b29d406445dd7a4b9aab850"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_version_history_set.html">TSLVersionHistorySet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_t_s_l_data_layer.html#a19803bde4b29d406445dd7a4b9aab850">versionHistory</a> () const</td></tr>
<tr class="separator:a19803bde4b29d406445dd7a4b9aab850 inherit pub_methods_class_t_s_l_data_layer"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a600dee0d5936fbae92d310dce3bb6e0e" id="r_a600dee0d5936fbae92d310dce3bb6e0e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a600dee0d5936fbae92d310dce3bb6e0e">~TSLMapDataLayer</a> ()</td></tr>
<tr class="separator:a600dee0d5936fbae92d310dce3bb6e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2ccca01cfd9b6783380cd8e3d48941e1" name="a2ccca01cfd9b6783380cd8e3d48941e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccca01cfd9b6783380cd8e3d48941e1">&#9670;&#160;</a></span>TSLMapDataLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLMapDataLayer::TSLMapDataLayer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>

</div>
</div>
<a id="a600dee0d5936fbae92d310dce3bb6e0e" name="a600dee0d5936fbae92d310dce3bb6e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a600dee0d5936fbae92d310dce3bb6e0e">&#9670;&#160;</a></span>~TSLMapDataLayer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TSLMapDataLayer::~TSLMapDataLayer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Protected destructor to stop being instantiated on the stack Forces user to use new operator and destroy method. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a276b47f0fdeadbad6d2789b76129026e" name="a276b47f0fdeadbad6d2789b76129026e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a276b47f0fdeadbad6d2789b76129026e">&#9670;&#160;</a></span>cacheFlushLimit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLMapDataLayer::cacheFlushLimit </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the current flush limit.</p>
<p>When the cache is full the system will remove the least recently used files to make room for the new data to load. The cache flush limit indicates the number of most recently used data files that the system will try keep in memory while flushing the cache. If the system cannot free enough memory and keep the flush limit number of files it will temporarily halve the flush limit until the cache memory usage is below 90% of the allowable cache size.</p>
<p>Returns the current flush limit. </p>

</div>
</div>
<a id="a710fa5bac0c7ac3537779a5f06376b35" name="a710fa5bac0c7ac3537779a5f06376b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a710fa5bac0c7ac3537779a5f06376b35">&#9670;&#160;</a></span>cacheFlushLimit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLMapDataLayer::cacheFlushLimit </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>flush_limit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets cache flush limit.</p>
<p>This method allows the user to set the cache flush limit for the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a>. When the cache is full the system will remove the least recently used files to make room for the new data to load. The cache flush limit indicates the number of most recently used data files that the system will try keep in memory while flushing the cache. If the system cannot free enough memory and keep the flush limit number of files it will temporarily halve the flush limit until the cache memory usage is below 90% of the allowable cache size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flush_limit</td><td>Number of most recently used data files that the system will try to keep in memory while flushing the cache. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac44756b5b6afb559440fa46007b609c4" name="ac44756b5b6afb559440fa46007b609c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44756b5b6afb559440fa46007b609c4">&#9670;&#160;</a></span>cacheSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLMapDataLayer::cacheSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the amount of memory that the cache may currently use, in Kilobytes. </p>

</div>
</div>
<a id="a8d8a03ed726fd48ee2ccc35a49653210" name="a8d8a03ed726fd48ee2ccc35a49653210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d8a03ed726fd48ee2ccc35a49653210">&#9670;&#160;</a></span>cacheSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLMapDataLayer::cacheSize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>new_size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set maximum size of the tile cache.</p>
<p>This method allows the user to set the amount of memory that the tile cache can use. To operate more efficiently the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> holds data in memory so that it does not need to reload data from disk every time a draw request is made. The larger the cache size the more data can be held in memory and draw requests are handled much more efficiently. However the client application must find a compromise between a large cache size and the memory requirements of the application itself.</p>
<p>The default tile cache is 32Mb (32768 KB)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">new_size</td><td>Size of the cache in kilobytes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a21fa54d37d885cd1ad96e6b8eef4bbbc" name="a21fa54d37d885cd1ad96e6b8eef4bbbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21fa54d37d885cd1ad96e6b8eef4bbbc">&#9670;&#160;</a></span>clearCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::clearCache </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the tile cache for this <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a>.</p>
<p>This method requests the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> to clear all cached data from memory and delete the files from the persistent cache (if used). After a call to clearCache any draw operation involving the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> will re-load all required map data from its original location.</p>
<p>Returns true on success, false otherwise. </p>

</div>
</div>
<a id="af07f429196bc524aeb46c9007243d5da" name="af07f429196bc524aeb46c9007243d5da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af07f429196bc524aeb46c9007243d5da">&#9670;&#160;</a></span>clearRuntimeProjection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::clearRuntimeProjection </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears any runtime projection set with 'setRuntimeProjection'.</p>
<p>Returns true on success, false otherwise. </p>

</div>
</div>
<a id="a5094eaca7fafdd693186eee20ba72d3b" name="a5094eaca7fafdd693186eee20ba72d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5094eaca7fafdd693186eee20ba72d3b">&#9670;&#160;</a></span>configurePersistentCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::configurePersistentCache </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_persistent_cache_data.html">TSLPersistentCacheData</a> *</td>          <td class="paramname"><span class="paramname"><em>settings</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga18dead260efa2e858acfd1b9e021a761">TSLTileValidationFn</a></td>          <td class="paramname"><span class="paramname"><em>validationFn</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds and configures a persistent tile cache.</p>
<p>A persistent tile cache may be used to speed up the loading of tiles which have been downloaded via a slow connection, eg. web-based.</p>
<p>A persistent tile cache works in parallel to the memory tile cache. If a tile is not found in memory, then the persistent tile cache is searched. If it is found in the persistent tile cache, then the (optional) tile validation function is called to verify that the file is up-to-date. If so, then the tile is loaded and added to the memory tile cache. If the tile is not found in the persistent tile cache, then if configured, a local search may be performed using the <a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> added to the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>. If the tile is found locally or is invalid, it is added to the memory cache and optionally to the persistent cache. If the tile is not found locally, then it may be returned in the failure list of the draw function, if specified.</p>
<p>In releases of MapLink later than 4.6 SP1, the persistent cache will also store relevant configuration files for the map - e.g. the .map, .pal, .dtl and .pth files.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settings</td><td>A <a class="el" href="class_t_s_l_persistent_cache_data.html">TSLPersistentCacheData</a> object containing the settings to use for the persistent cache.</td></tr>
    <tr><td class="paramname">validationFn</td><td>This is an optional function that may be used to validate any tiles that are in the cache, prior to them being used. If not specified, then all tiles in the cache are deemed to be valid.</td></tr>
    <tr><td class="paramname">arg</td><td>An optional argument that will be passed to the user's validation function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a906282893732ec6e00ebe0748042c4ba" name="a906282893732ec6e00ebe0748042c4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a906282893732ec6e00ebe0748042c4ba">&#9670;&#160;</a></span>copyRasterFeatures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::copyRasterFeatures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_raster_data_layer.html">TSLRasterDataLayer</a> *</td>          <td class="paramname"><span class="paramname"><em>rasterDataLayer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>destPath</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_envelope.html">TSLEnvelope</a> *</td>          <td class="paramname"><span class="paramname"><em>envelope</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#gab0b9f8e5dfebf451f2944aee7dfa0b8d">TSLCopyFilesCallback</a></td>          <td class="paramname"><span class="paramname"><em>progressCallback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the raster files associated with a layer into the destination directory and then adds them to the supplied <a class="el" href="class_t_s_l_raster_data_layer.html">TSLRasterDataLayer</a>.</p>
<p>Note: This method is not thread safe.</p>
<p>Parameters:</p>
<p>RasterDataLayer * - The layer to add the rasters to. NOTE this must have a pathlist set.</p>
<p>DestPath - the folder to copy the raster files into. If this does not exist it will be created. This folder gets added to the TSLRasterDataLayers pathlist</p>
<p>LayerName - name of the detail layer to copy from. If not set then the active layer is used.</p>
<p>featureID - only copy the rasters that match this feature ID. If not set then all are copied</p>
<p>envelope - only copy rasters that intersect the area. If not set then all are copied</p>
<p>progressCallback - optional callback to retrieve progress. If false is returned then copying is cancelled.</p>
<p>arg: user-defined argument, returned in callback. </p>

</div>
</div>
<a id="a87b9ac87a18507f210b9a7c9ff17cd10" name="a87b9ac87a18507f210b9a7c9ff17cd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b9ac87a18507f210b9a7c9ff17cd10">&#9670;&#160;</a></span>findEntityID()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_entity.html">TSLEntity</a> * TSLMapDataLayer::findEntityID </td>
          <td>(</td>
          <td class="paramtype">TSLEntityID</td>          <td class="paramname"><span class="paramname"><em>entityID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>handler</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find an entity in a seamless layer, given its ID.</p>
<p>This method returns a pointer to the first visible, selectable entity matching the given ID, If the map does not contain a seamless layer or if no such entity exists in the seamless layer, NULL is returned.</p>
<p>Entities are marked as visible or selectable via TSLRenderingAttributeVisible and TSLRenderingAttributeSelectable.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entityID</td><td>the entity ID </td></tr>
    <tr><td class="paramname">handler</td><td>the entity reference handler</td></tr>
  </table>
  </dd>
</dl>
<p>The entity reference handler must be configured appropriately otherwise this method will return NULL; in particular, if the handler has no associated seamless configuration object, then NULL will be returned. </p>

</div>
</div>
<a id="a98a44e3b6cf9e67c66d922b38910e788" name="a98a44e3b6cf9e67c66d922b38910e788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a44e3b6cf9e67c66d922b38910e788">&#9670;&#160;</a></span>getBackgroundColour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLStyleID TSLMapDataLayer::getBackgroundColour </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns the background colour index for the loaded map.</p>
<p>Returns the background colour index of the map or -1 if the colour is not defined. The return value will either be a colour index or a composed RGB value. See tslcolourhelper.h for information on determining the type and in the case of an RGB value uncomposing it back into its respective components. </p>

</div>
</div>
<a id="a294e5a3c3397604d3fcf97b12e70e495" name="a294e5a3c3397604d3fcf97b12e70e495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a294e5a3c3397604d3fcf97b12e70e495">&#9670;&#160;</a></span>getDetailLayerMUExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::getDetailLayerMUExtent </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layer_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query extent of detail layer.</p>
<p>This method allows the user to get the extent of a particular detail layer of the map. The extent returned is in Map Unit co-ordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer_name</td><td>Layer for which the extent are returned</td></tr>
    <tr><td class="paramname">(x1,y1)</td><td>Storage for bottom left corner</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for top right corner</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a28a0a5258240811064564fd0cd470c87" name="a28a0a5258240811064564fd0cd470c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28a0a5258240811064564fd0cd470c87">&#9670;&#160;</a></span>getDetailLayerName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * TSLMapDataLayer::getDetailLayerName </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>nth</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns name of the 'nth' detail layer.</p>
<p>The name is stored in an internal buffer which may be overwritten by subsequent calls to this method.</p>
<p>Returns a pointer to the name of the 'nth' detail layer, NULL if no detail layers are loaded. </p>

</div>
</div>
<a id="acb4b22ccf312646c7c07522d4aa4d1ae" name="acb4b22ccf312646c7c07522d4aa4d1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4b22ccf312646c7c07522d4aa4d1ae">&#9670;&#160;</a></span>getDetailLayerTMCExtent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::getDetailLayerTMCExtent </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layer_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query extent of detail layer.</p>
<p>This method allows the user to get the extent of a particular detail layer of the map. The extent returned is in internal TMC co-ordinates.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer_name</td><td>Layer for which the extent are returned</td></tr>
    <tr><td class="paramname">(x1,y1)</td><td>Storage for bottom left corner</td></tr>
    <tr><td class="paramname">(x2,y2)</td><td>Storage for top right corner</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a72834e897afe7158d697bc8e82dab73c" name="a72834e897afe7158d697bc8e82dab73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72834e897afe7158d697bc8e82dab73c">&#9670;&#160;</a></span>getDynamicRendererFeatureBookSection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::getDynamicRendererFeatureBookSection </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>indexOfRenderer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>indexOfFeatureBookSection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>featureBookSectionNumber</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&amp;</td>          <td class="paramname"><span class="paramname"><em>featureBookSectionName</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method returns the feature book section number and name for the dynamic renderer index and feature book index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexOfRenderer</td><td>the index of the renderer. </td></tr>
    <tr><td class="paramname">indexOfFeatureBookSection</td><td>the index of the feature book section. </td></tr>
    <tr><td class="paramname">featureBookSectionNumber</td><td>returns for the feature book section number. </td></tr>
    <tr><td class="paramname">featureBookSectionName</td><td>returns the feature book section name.</td></tr>
  </table>
  </dd>
</dl>
<p>Return false if the index values are invalid. </p>

</div>
</div>
<a id="a30d6a19763ef8bee47ac9736ae6141ef" name="a30d6a19763ef8bee47ac9736ae6141ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30d6a19763ef8bee47ac9736ae6141ef">&#9670;&#160;</a></span>getDynamicRendererHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * TSLMapDataLayer::getDynamicRendererHint </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>index</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns the name of a <a class="el" href="class_t_s_l_dynamic_renderer.html">TSLDynamicRenderer</a> associated with the map.</p>
<p>The name can be used to workout which dynamic renderer to load.</p>
<p>Currently only a map created using the S-57 Dataset specifically configured for S-52 will have a <a class="el" href="class_t_s_l_dynamic_renderer.html">TSLDynamicRenderer</a> name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>index to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the name of the <a class="el" href="class_t_s_l_dynamic_renderer.html">TSLDynamicRenderer</a> or NULL if one does not exist. </dd></dl>

</div>
</div>
<a id="ac6150a3a0e8e147f34655997df5edbac" name="ac6150a3a0e8e147f34655997df5edbac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6150a3a0e8e147f34655997df5edbac">&#9670;&#160;</a></span>getLayerLoadingThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::getLayerLoadingThreshold </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>upperThreshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>lowerThreshold</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows the top and bottom thresholds for which a particular layer is displayed to be queried at runtime.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerName</td><td>The name of the layer to query. </td></tr>
    <tr><td class="paramname">lowerThreshold</td><td>The lower value in Map Units per Pixel. </td></tr>
    <tr><td class="paramname">upperThreshold</td><td>The upper value in Map Units per Pixel.</td></tr>
  </table>
  </dd>
</dl>
<p>Return true on success, false otherwise. </p>

</div>
</div>
<a id="a7b7f293743c448bfaf2136bbb81d6e6e" name="a7b7f293743c448bfaf2136bbb81d6e6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7f293743c448bfaf2136bbb81d6e6e">&#9670;&#160;</a></span>getNumDetailLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLMapDataLayer::getNumDetailLayers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns the number of detail layers in the currently loaded map.</p>
<p>Returns number of detail layers in the currently loaded map. 0 if no map is loaded </p>

</div>
</div>
<a id="a022af641b67109e7314b22eeea6e8bdf" name="a022af641b67109e7314b22eeea6e8bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022af641b67109e7314b22eeea6e8bdf">&#9670;&#160;</a></span>getNumDynamicRendererFeatureBookSections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLMapDataLayer::getNumDynamicRendererFeatureBookSections </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>indexOfRenderer</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method getNumDynamicRendererFeatureBookSections returns the number of feature book sections for the given dynamic renderer index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexOfRenderer</td><td>index of the dynamic renderer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of feature book sections for the given dynamic renderer index. </dd></dl>

</div>
</div>
<a id="a789dd579537d175aab8c1d4147f2bc7d" name="a789dd579537d175aab8c1d4147f2bc7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a789dd579537d175aab8c1d4147f2bc7d">&#9670;&#160;</a></span>getNumDynamicRendererHints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLMapDataLayer::getNumDynamicRendererHints </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of <a class="el" href="class_t_s_l_dynamic_renderer.html">TSLDynamicRenderer</a> names. </p>

</div>
</div>
<a id="a4cce35134867eee864a3ee69d50c81c7" name="a4cce35134867eee864a3ee69d50c81c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cce35134867eee864a3ee69d50c81c7">&#9670;&#160;</a></span>getOverviewLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * TSLMapDataLayer::getOverviewLayer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns name of a layer to be used for an overview.</p>
<p>At present, this method will return "thumbnail" or "overview" if those detail layers exist. Otherwise it returns that detail layer with the largest extent. In a future release, it may be possible to tag a detail layer to be used via MapLink Studio.</p>
<p>Returns a pointer to the name of the overview detail layer, NULL if no detail layers are loaded. </p>

</div>
</div>
<a id="ad637096fd1cb42dd7963f8e24a7e9113" name="ad637096fd1cb42dd7963f8e24a7e9113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad637096fd1cb42dd7963f8e24a7e9113">&#9670;&#160;</a></span>getPaletteFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::getPaletteFilename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method queries the full path to the palette file associated with this map data layer if one exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>This will be populated with the palette filename should one be associated</td></tr>
  </table>
  </dd>
</dl>
<p>Return true if the filename parameter was populated with the paletted filename, false otherwise. </p>

</div>
</div>
<a id="adc73734d65213ee2f916fa97ebb40ced" name="adc73734d65213ee2f916fa97ebb40ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc73734d65213ee2f916fa97ebb40ced">&#9670;&#160;</a></span>getPathlistFilename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::getPathlistFilename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method queries the full path to the pathlist definition file associated with this map data layer if one exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>This will be populated with the pathlist definition file path should one be associated</td></tr>
  </table>
  </dd>
</dl>
<p>Return true if the filename parameter was populated with the pathlist filename, false otherwise. </p>

</div>
</div>
<a id="af3478ffe6864846ffe3e03fcd19b6df3" name="af3478ffe6864846ffe3e03fcd19b6df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3478ffe6864846ffe3e03fcd19b6df3">&#9670;&#160;</a></span>getSynchronousLoading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::getSynchronousLoading </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries whether the layer is currently set to synchronous loading of its data. Synchronous loading is usually only required when printing as all data that is to be drawn must be loaded before the print draw occurs. Use the setSynchronousLoading method to alter the value of this setting. </p>

</div>
</div>
<a id="a02e325759b914ca805a882a394e28ba9" name="a02e325759b914ca805a882a394e28ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e325759b914ca805a882a394e28ba9">&#9670;&#160;</a></span>isRuntimeProjected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::isRuntimeProjected </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function that informs whether the Map was built with a coordinate system that requires the projection to be set at runtime by the user.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the map coordinate system requires a projection to be set at runtime, false otherwise. </dd></dl>

</div>
</div>
<a id="a6ee9566d06a292591ef3954e8f4b789f" name="a6ee9566d06a292591ef3954e8f4b789f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee9566d06a292591ef3954e8f4b789f">&#9670;&#160;</a></span>metadata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLMapDataLayer::metadata </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pos</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **</td>          <td class="paramname"><span class="paramname"><em>fileName</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns the source ID and the full path of the associated xml file for the given position.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>the nth piece of metadata for which source ID and the xml file are required </td></tr>
    <tr><td class="paramname">fileName</td><td>the filename of the associated metadata (memory owned by the caller) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac62b1846a86977da2c4fd0133c109b31" name="ac62b1846a86977da2c4fd0133c109b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac62b1846a86977da2c4fd0133c109b31">&#9670;&#160;</a></span>metadata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLMapDataLayer::metadata </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>sourceID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The method returns the full path of the Envitia generated metadata xml file associated with the given source ID in the filename argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sourceID</td><td>sourceID for which associated metadata xml file path should be returned</td></tr>
    <tr><td class="paramname">filename</td><td>The full path to the metadata file. An empty path is returned if there was no metadata file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a331795bd9d7475cc53f859fa209bc46e" name="a331795bd9d7475cc53f859fa209bc46e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331795bd9d7475cc53f859fa209bc46e">&#9670;&#160;</a></span>metadataCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLMapDataLayer::metadataCount </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns a count of the number of metadata files associated with this layer. </p>

</div>
</div>
<a id="a6bdd26a710e89b7822de17189a9e7076" name="a6bdd26a710e89b7822de17189a9e7076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bdd26a710e89b7822de17189a9e7076">&#9670;&#160;</a></span>MUToTMC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::MUToTMC </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map unit to TMC conversion method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>input X (map units). </td></tr>
    <tr><td class="paramname">y1</td><td>input Y (map units). </td></tr>
    <tr><td class="paramname">x2</td><td>output X (TMC units). </td></tr>
    <tr><td class="paramname">y2</td><td>output Y (TMC units).</td></tr>
  </table>
  </dd>
</dl>
<p>Return true on success, false otherwise. </p>

</div>
</div>
<a id="a49b656957f317b5c0c94328f44b7003b" name="a49b656957f317b5c0c94328f44b7003b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b656957f317b5c0c94328f44b7003b">&#9670;&#160;</a></span>operator new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLMapDataLayer::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overridden allocation to redirect to MapLink </p>

</div>
</div>
<a id="ad6a45506d61b8a6e11c67e0208d99e14" name="ad6a45506d61b8a6e11c67e0208d99e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a45506d61b8a6e11c67e0208d99e14">&#9670;&#160;</a></span>operator new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLMapDataLayer::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When included in an MFC application in debug mode, the debug new expects this to be here. Override it and return the same as the normal one. The library must include it when compiled in release mode, since the user's application may be in debug mode. </p>

</div>
</div>
<a id="a5c00175179efc3b7241349e818fdbb77" name="a5c00175179efc3b7241349e818fdbb77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c00175179efc3b7241349e818fdbb77">&#9670;&#160;</a></span>queryMapCoordinateSystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> * TSLMapDataLayer::queryMapCoordinateSystem </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query for the coordinate system associated with the map that is loaded in this layer.</p>
<p>This method requests the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> to return a <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> object which allows the user to access information concerning the transforms used to create the map. The <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> is only valid as long as no new map has been loaded into the layer since last obtaining the component.</p>
<p>If runtime projection is not in use, this will be the same object as returned from queryCoordinateSystem(). If runtime projection is in use, <a class="el" href="#a40d9052de8b13f19648072d900134b74">queryRuntimeCoordinateSystem()</a> will return the transform given to <a class="el" href="#a8c7714ee46fde54dd4dc0b05433c019c">setRuntimeProjection()</a> and this method will return the transform associated with the loaded map. </p>

</div>
</div>
<a id="a40d9052de8b13f19648072d900134b74" name="a40d9052de8b13f19648072d900134b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d9052de8b13f19648072d900134b74">&#9670;&#160;</a></span>queryRuntimeCoordinateSystem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> * TSLMapDataLayer::queryRuntimeCoordinateSystem </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query for the runtime coordinate system added with setRuntimeProjection.</p>
<p>If runtime projection is not in use, this will return null. </p>

</div>
</div>
<a id="ac55fac41609f745dd4dffdcd042cfb27" name="ac55fac41609f745dd4dffdcd042cfb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55fac41609f745dd4dffdcd042cfb27">&#9670;&#160;</a></span>removeLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::removeLayer </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layer_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove existing detail layer.</p>
<p>This method requests the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> to remove the named detail layer. If the layer identified by input layer file name does not exist in the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> then this will have no effect. If the layer is currently on the display then nothing will happen until the data is redisplayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer_name</td><td>The name of the layer to be removed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the layer is removed, false otherwise. </dd></dl>

</div>
</div>
<a id="accd1ba15e2307d95ac906437273ca44c" name="accd1ba15e2307d95ac906437273ca44c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd1ba15e2307d95ac906437273ca44c">&#9670;&#160;</a></span>setLayerLoadingThreshold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::setLayerLoadingThreshold </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>upperThreshold</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>lowerThreshold</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows the top and bottom thresholds for which a particular layer is displayed to be set at runtime, rather than relying on settings via MapLink studio.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerName</td><td>The name of the layer to apply the changes. </td></tr>
    <tr><td class="paramname">upperThreshold</td><td>The upper threshold in Map Units per pixel. </td></tr>
    <tr><td class="paramname">lowerThreshold</td><td>The lower threshold in Map Units per pixel. Defaulted to 0.0.</td></tr>
  </table>
  </dd>
</dl>
<p>Return true on success, false otherwise. </p>

</div>
</div>
<a id="a7cf5e003b473c98afedb233ce88a482a" name="a7cf5e003b473c98afedb233ce88a482a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cf5e003b473c98afedb233ce88a482a">&#9670;&#160;</a></span>setOverrideCol()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::setOverrideCol </td>
          <td>(</td>
          <td class="paramtype">TSLStyleID</td>          <td class="paramname"><span class="paramname"><em>override_colour</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the colour of monochrome raster images that may be displayed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">override_colour</td><td>Colour to be used when drawing the set bits of the monochrome raster. This value is either an index in the colour table used by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> or a composed RGB value. See tslcolourhelper.h for information on how to create this value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a8c7714ee46fde54dd4dc0b05433c019c" name="a8c7714ee46fde54dd4dc0b05433c019c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c7714ee46fde54dd4dc0b05433c019c">&#9670;&#160;</a></span>setRuntimeProjection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::setRuntimeProjection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_coordinate_system.html">TSLCoordinateSystem</a> *</td>          <td class="paramname"><span class="paramname"><em>projection</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>greatCircleDistance</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga7888cf9886effdc2859c911f4771dfcd">TSLRuntimeProjectionChangedCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the current projection if using runtime projection.</p>
<p>If a callback is given, then the recalculation of the projection will happen in a background thread, and the callback will be called when it is complete. Drawing operations will fail if called during the time when the recalculation is being performed.</p>
<p>If the callback parameter is null then the calculations happen synchronously in the main thread, within this call.</p>
<p>The same callback pointer may be given to both setRuntimeProjection and setRuntimeProjectionOrigin. The reason parameter of the callback indicates the reason for the callback.</p>
<p>If the runtime projection is referenced against a different datum to that against which the map was created, then a suitable datum transform must be set on the projection before calling this method.</p>
<p>NOTE : The TMCperMU value for the specified coordinate system is currently ignored when the coordinate system is used for run-time projection. Under those circumstances the TMCperMU is calculated according to the input data extent.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">projection</td><td>the new coordinate system to use. This is copied, the pointer is not stored.</td></tr>
    <tr><td class="paramname">greatCircleDistance</td><td>a map tile will be projected if any part of the tile falls within this distance from the projection origin (metres). Set this value to the maximum geographical area the you need to view. Reducing the value makes setprojection and setProjectionOrigin work faster. Avoid values so large that the edge of the map projection becomes visible.</td></tr>
    <tr><td class="paramname">callback</td><td>callback to call when new projection calculated, or null if calculations to be synchronous</td></tr>
    <tr><td class="paramname">arg</td><td>user-defined argument, returned in callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="a3fc66b1e309a850b07267a794c1634ea" name="a3fc66b1e309a850b07267a794c1634ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fc66b1e309a850b07267a794c1634ea">&#9670;&#160;</a></span>setRuntimeProjectionOrigin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::setRuntimeProjectionOrigin </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>latitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>longitude</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga7888cf9886effdc2859c911f4771dfcd">TSLRuntimeProjectionChangedCallback</a></td>          <td class="paramname"><span class="paramname"><em>callback</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the origin of the current projection if using runtime projection.</p>
<p>If a callback is given, then the recalculation of the projection will happen in a background thread, and the callback will be called when it is complete. Drawing operations will fail if called during the time when the recalculation is being performed.</p>
<p>If the callback parameter is null then the calculations happen synchronously in the main thread, within this call.</p>
<p>The same callback pointer may be given to both setRuntimeProjection and setRuntimeProjectionOrigin. The reason parameter of the callback indicates the reason for the callback.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(latitude,longitude)</td><td>the new projection origin to be set, degrees</td></tr>
    <tr><td class="paramname">callback</td><td>callback to call when new projection calculated, or null if calculations to be synchronous</td></tr>
    <tr><td class="paramname">arg</td><td>user-defined argument, returned in callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false on failure. </dd></dl>

</div>
</div>
<a id="aef0f8b8714df83f50ee67b70c3bc4a78" name="aef0f8b8714df83f50ee67b70c3bc4a78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef0f8b8714df83f50ee67b70c3bc4a78">&#9670;&#160;</a></span>setRuntimeProjectionParameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::setRuntimeProjectionParameters </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>initialTMCperMU</em></span><span class="paramdefsep"> = </span><span class="paramdefval">50</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>tmcPerMUFactor</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>detailedExtentCheck</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>quickCheckGrid</em></span><span class="paramdefsep"> = </span><span class="paramdefval">3</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>quickCheckPoints</em></span><span class="paramdefsep"> = </span><span class="paramdefval">32</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>detailedCheckGrid</em></span><span class="paramdefsep"> = </span><span class="paramdefval">16</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>detailedCheckPoints</em></span><span class="paramdefsep"> = </span><span class="paramdefval">128</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>tileExtentGrowthScale</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.005</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method is used for defining the parameters used for runtime projection of a compatible map generated from MapLink Studio. Tweaks to these settings may dramatically improve or degrade the performance of runtime projection but may cause a trade off in terms of the correctness of viewed areas.</p>
<p>These settings are used to decide which tiles in the map may potentially be displayed for the current centre of projection and the maximum great circle distance specified to the setRuntimeProjection method. This set of tiles is independent of the current view. For certain projections, this decision process may, depending on the parameters set, compile a list that does not completely include all tiles that should be visible. This will particularly be the case where certain tiles are dramatically warped such as around the edges of the world or poles. This calculation is only performed when the projection changes, not when the displayed area changes.</p>
<p>Once the set of potentially displayable tiles have been decided upon, the actual set of tiles for display is determined when the surface is redrawn and is dependent upon the viewing area. The relatively expensive process of projecting the features within those tiles takes place when the tiles are loaded for a draw, potentially in a background thread.</p>
<p>If an application uses a defined subset of projections, adjusting these settings may be advisable, assuming the new settings are tested against these projections and target areas. On the other hand, in an application where a variable set of projections may be used, it would usually be best to leave these settings at their defaults.</p>
<p>Customers upgrading from MapLink 5.4 and earlier - which do not include this method - may need to call this to pass the earlier defaults if the new values cause issues. The settings are now also stored per layer.</p>
<p>This decision process is split into two separate stages:</p>
<ul>
<li>Determining a valid TMC per MU for the output projection. As all MapLink drawing and calculations is dependent upon a TMC per MU value for the loaded data, this must be calculated first. This is an iterative process, seeded by the initialTMCperMU parameter, where the current value is tested to see if all the projected data will fit in that output TMC space. Should the current value not fit the data, then it is multiplied by the tmcPerMUFactor parameter and tested again. This will continue until a valid value is found. Tweaking these settings is usually not necessary but in certain cases may speed up this iterative process.</li>
<li>Determining the extent of the projected map tiles. As the projection of map tile boundaries is expensive, MapLink tries to limit this process to only the tiles that may visible. It first does this by limiting the tested tiles to those that are within a Great Circle distance of the projection centre. Then it takes a small set of sample points from each tile, projects them and sees if they are within the output space. This small set is defined by the quickCheckGrid and quickCheckPoints parameters. If none of the projected points appear in the output space, then, if the detailedExtentCheck parameter is true, MapLink does a second more detailed check using a larger set of input tile points. The size of this larger set is defined by the detailedCheckGrid and detailedCheckPoints parameters. Once the projected extent has been calculated, it is expanded using the tileExtentGrowthScale value in order to cope with the situation where a tile boundary 'bulges'. The extent is then stored and during a redraw is used to decide if this particular tile intersects the display extent.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initialTMCperMU</td><td>Seed value used for determining the TMC per MU value to be used in the output projection. Must be greater than 0. Current default value is 50. Earlier MapLink versions used 1 as the default.</td></tr>
    <tr><td class="paramname">tmcPerMUFactor</td><td>Value that the current TMC per MU value is multiplied by on each iteration of the process to find a valid TMC per MU value for the projected data. Must be greater than 1. Current default value is 10. Earlier MapLink versions used 100 as the default.</td></tr>
    <tr><td class="paramname">detailedExtentCheck</td><td>For tiles where the quick sampling of points to the output projection doesn't produce and points valid in the output projection, should a more detailed check take place. Current default value is false. Earlier MapLink versions used true as the default.</td></tr>
    <tr><td class="paramname">quickCheckGrid</td><td>The number of horizontal grid lines to used for the quick sampling. Must be greater than 0. Default value is 3.</td></tr>
    <tr><td class="paramname">quickCheckPoints</td><td>The number of sample points along each horizontal grid line to used for the quick sampling. Must be greater than 0. Default value is 32.</td></tr>
    <tr><td class="paramname">detailedCheckGrid</td><td>The number of horizontal grid lines to used for the detailed sampling. Must be greater than 0. Default value is 16.</td></tr>
    <tr><td class="paramname">detailedCheckPoints</td><td>The number of sample points along each horizontal grid line to used for the detailed sampling. Must be greater than 0. Default value is 128.</td></tr>
    <tr><td class="paramname">tileExtentGrowthScale</td><td>The fraction of the full tile height/width to added to the top and bottom/left and right of the tile extent when determining the sampling grid. Default value is 0.005</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="acb145d4db4c419aeebd578e549738dbf" name="acb145d4db4c419aeebd578e549738dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb145d4db4c419aeebd578e549738dbf">&#9670;&#160;</a></span>setSynchronousLoading()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLMapDataLayer::setSynchronousLoading </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>synchronous</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call with the synchronous parameter set to true to load map data synchronously, it also inhibits callbacks after each map tile is loaded.</p>
<p>Call this during printing to ensure that all map data is loaded synchronously, as printing may use a different tile resolution from those displayed on the screen.</p>
<p>The allLoadedCallback callback (as passed in the <a class="el" href="class_t_s_l_data_layer.html#a17f31630e6fda8c34be66ef6dc987ff0">addLoader()</a> method) is always called at the end of loading all tiles, but the tile loaded callback (as passed in the <a class="el" href="class_t_s_l_data_layer.html#a17f31630e6fda8c34be66ef6dc987ff0">addLoader()</a> method) is only called for asynchronous loading. </p>

</div>
</div>
<a id="ade1484346e0cad2b8dbd40f9ead7d488" name="ade1484346e0cad2b8dbd40f9ead7d488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1484346e0cad2b8dbd40f9ead7d488">&#9670;&#160;</a></span>setTransparent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::setTransparent </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>trans_mode</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLStyleID</td>          <td class="paramname"><span class="paramname"><em>trans_colour</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set transparency mode for raster.</p>
<p>This method allows the user to set the transparency mode for monochrome raster images loaded by the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a>. The transparency mode is default to false when a raster is added to the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">trans_mode</td><td>True for the raster image to be transparent. Default value is false.</td></tr>
    <tr><td class="paramname">trans_colour</td><td>Colour of the raster image to be transparent. This value is a colour index in the colour table used by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. Default value is 0, for no colour to be transparent.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns true on success, false otherwise. </p>

</div>
</div>
<a id="a6471adbcd47524e55f5453aeba0fa02f" name="a6471adbcd47524e55f5453aeba0fa02f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6471adbcd47524e55f5453aeba0fa02f">&#9670;&#160;</a></span>TMCperMU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TSLMapDataLayer::TMCperMU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns the number of TMCs per Map Unit for the loaded map.</p>
<p>Returns the number of TMCs per Map Unit if data is loaded, 0.0 if not. </p>

</div>
</div>
<a id="ae8624a2855a49009008dfbdd4c347c33" name="ae8624a2855a49009008dfbdd4c347c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8624a2855a49009008dfbdd4c347c33">&#9670;&#160;</a></span>TMCToMU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::TMCToMU </td>
          <td>(</td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>x1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLTMC</td>          <td class="paramname"><span class="paramname"><em>y1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>x2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>y2</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TMC to map unit conversion method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>input X (TMC units). </td></tr>
    <tr><td class="paramname">y1</td><td>input Y (TMC units). </td></tr>
    <tr><td class="paramname">x2</td><td>output X (map units). </td></tr>
    <tr><td class="paramname">y2</td><td>output Y (map units).</td></tr>
  </table>
  </dd>
</dl>
<p>Return true on success, false otherwise. </p>

</div>
</div>
<a id="a50f4e478d6022e77537ae5a71a3f6bc0" name="a50f4e478d6022e77537ae5a71a3f6bc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f4e478d6022e77537ae5a71a3f6bc0">&#9670;&#160;</a></span>validateCache()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLMapDataLayer::validateCache </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Validate the tiles in the persistent tile cache for this <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a>.</p>
<p>Returns true on success, false otherwise. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.2 | Documentation created Mon Aug 4 2025 17:31:50 | Generated with <a href="http://www.doxygen.org/index.html">Doxygen 1.13.2</a> | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
