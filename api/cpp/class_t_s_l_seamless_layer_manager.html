<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLSeamlessLayerManager Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.2</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_seamless_layer_manager.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="class_t_s_l_seamless_layer_manager-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLSeamlessLayerManager Class Reference<div class="ingroups"><a class="el" href="group__apigroup__maplink__pro__developers__toolkit.html">MapLink Pro Developer Toolkit</a> &raquo; <a class="el" href="group__apigroup__api.html">Core API</a></div></div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This component allows the import, export and updating of data to &amp; from the MapLink TMF/TCF seamless tile based format.</p>
<p>Note : this class has a private destructor, to destroy instances of this class call the public function <a class="el" href="#ab745ce8ad1a3fedcf203c78e1f648ba0">destroy()</a> </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3eb9c03fad1bc41e94862a334fa15ef" id="r_ab3eb9c03fad1bc41e94862a334fa15ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3eb9c03fad1bc41e94862a334fa15ef">TSLSeamlessLayerManager</a> ()</td></tr>
<tr class="separator:ab3eb9c03fad1bc41e94862a334fa15ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe9cacbdc43f9b076a2a5a76d6a6b04" id="r_acfe9cacbdc43f9b076a2a5a76d6a6b04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acfe9cacbdc43f9b076a2a5a76d6a6b04">addLayerToMap</a> (const char *renditionFile=NULL)</td></tr>
<tr class="separator:acfe9cacbdc43f9b076a2a5a76d6a6b04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e0e474a8ade2a856b50ad35e458c95a" id="r_a8e0e474a8ade2a856b50ad35e458c95a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8e0e474a8ade2a856b50ad35e458c95a">cacheSize</a> (int size)</td></tr>
<tr class="separator:a8e0e474a8ade2a856b50ad35e458c95a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6fa2054ca23a09ff6c90627754734c" id="r_afc6fa2054ca23a09ff6c90627754734c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afc6fa2054ca23a09ff6c90627754734c">cacheSize</a> ()</td></tr>
<tr class="separator:afc6fa2054ca23a09ff6c90627754734c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88465500bb8247da74a37b0ee1ff8334" id="r_a88465500bb8247da74a37b0ee1ff8334"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a88465500bb8247da74a37b0ee1ff8334">checkpointCurrentArchive</a> (<a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a> timestamp, <a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a> &amp;nextArchiveVersion)</td></tr>
<tr class="separator:a88465500bb8247da74a37b0ee1ff8334"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3ab4f79cd57ceaf209a0badc53ec35" id="r_ace3ab4f79cd57ceaf209a0badc53ec35"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_seamless_layer_config.html">TSLSeamlessLayerConfig</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace3ab4f79cd57ceaf209a0badc53ec35">configuration</a> () const</td></tr>
<tr class="separator:ace3ab4f79cd57ceaf209a0badc53ec35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab745ce8ad1a3fedcf203c78e1f648ba0" id="r_ab745ce8ad1a3fedcf203c78e1f648ba0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab745ce8ad1a3fedcf203c78e1f648ba0">destroy</a> ()</td></tr>
<tr class="separator:ab745ce8ad1a3fedcf203c78e1f648ba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e28d555d102e3fc9643b01cbb533558" id="r_a1e28d555d102e3fc9643b01cbb533558"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1e28d555d102e3fc9643b01cbb533558">enablePublishing</a> (bool enabled, const char *directory=0)</td></tr>
<tr class="separator:a1e28d555d102e3fc9643b01cbb533558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601bf4e2990f08387c7af2b6a6d67e04" id="r_a601bf4e2990f08387c7af2b6a6d67e04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a601bf4e2990f08387c7af2b6a6d67e04">entityRefHandler</a> (<a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> *handler)</td></tr>
<tr class="separator:a601bf4e2990f08387c7af2b6a6d67e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37b4d757371a7dd64a159c1b7a412f4" id="r_ae37b4d757371a7dd64a159c1b7a412f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae37b4d757371a7dd64a159c1b7a412f4">entityRefHandler</a> ()</td></tr>
<tr class="separator:ae37b4d757371a7dd64a159c1b7a412f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af412a5d2162f44258de3fc6a81a01ba1" id="r_af412a5d2162f44258de3fc6a81a01ba1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_t_s_l_seamless_layer_tile_list.html">TSLSeamlessLayerTileList</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af412a5d2162f44258de3fc6a81a01ba1">finalise</a> ()</td></tr>
<tr class="separator:af412a5d2162f44258de3fc6a81a01ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0a076ec6a69442d5ec519745977898" id="r_afd0a076ec6a69442d5ec519745977898"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd0a076ec6a69442d5ec519745977898">importCompatibleData</a> (<a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *layer, <a class="el" href="class_t_s_l_s_l_m_import_result.html">TSLSLMImportResult</a> *results, bool allowRegression=false, <a class="el" href="class_t_s_l_s_l_m_entity_store_handler.html">TSLSLMEntityStoreHandler</a> *storeHandler=0, bool updateTiles=true)</td></tr>
<tr class="separator:afd0a076ec6a69442d5ec519745977898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e28f9859efe81a04997a256d51cf003" id="r_a4e28f9859efe81a04997a256d51cf003"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4e28f9859efe81a04997a256d51cf003">ingestData</a> (<a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *layer, bool allowRegression=false, <a class="el" href="class_t_s_l_s_l_m_entity_store_handler.html">TSLSLMEntityStoreHandler</a> *storeHandler=0, bool updateTiles=true, <a class="el" href="group__apigroup__api.html#ga365925a0698ae664858cbe7383419cd6">TSLSeamlessLayerEntityChangeCallback</a> entityChangeCallback=NULL, void *arg=NULL)</td></tr>
<tr class="separator:a4e28f9859efe81a04997a256d51cf003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5725a9a39a56cce5b44cd13e37987104" id="r_a5725a9a39a56cce5b44cd13e37987104"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5725a9a39a56cce5b44cd13e37987104">initialiseExistingLayerForIngest</a> (const char *baseDirectory, const char *layerName, const char *mapFilename=NULL)</td></tr>
<tr class="separator:a5725a9a39a56cce5b44cd13e37987104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab54ec5ea5511a4116c460709adc5bc6d" id="r_ab54ec5ea5511a4116c460709adc5bc6d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab54ec5ea5511a4116c460709adc5bc6d">initialiseNewDetailLayer</a> (const <a class="el" href="class_t_s_l_seamless_layer_config.html">TSLSeamlessLayerConfig</a> *config, const char *mapFilename=&quot;&quot;)</td></tr>
<tr class="separator:ab54ec5ea5511a4116c460709adc5bc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8340d027c3b1dae7c243738a951c0656" id="r_a8340d027c3b1dae7c243738a951c0656"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8340d027c3b1dae7c243738a951c0656">initialiseNewReplication</a> ()</td></tr>
<tr class="separator:a8340d027c3b1dae7c243738a951c0656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495b23f6502f4d50cdf140399ddd9e5a" id="r_a495b23f6502f4d50cdf140399ddd9e5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a495b23f6502f4d50cdf140399ddd9e5a">isLayerLocked</a> () const</td></tr>
<tr class="separator:a495b23f6502f4d50cdf140399ddd9e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2c408ac6a49e62026b7846ae0747cf" id="r_aca2c408ac6a49e62026b7846ae0747cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aca2c408ac6a49e62026b7846ae0747cf">lockLayer</a> ()</td></tr>
<tr class="separator:aca2c408ac6a49e62026b7846ae0747cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a4a06daab130ebe3613f2bde0beeebb" id="r_a7a4a06daab130ebe3613f2bde0beeebb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7a4a06daab130ebe3613f2bde0beeebb">publish</a> ()</td></tr>
<tr class="separator:a7a4a06daab130ebe3613f2bde0beeebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b3153dd6ad90a4960f476267820dd5" id="r_a09b3153dd6ad90a4960f476267820dd5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09b3153dd6ad90a4960f476267820dd5">publishAndArchive</a> (const char *archiveDirectory, <a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a> timestamp, bool maintainCurrentArchiveVersion=false, bool archiveEntityReferences=false)</td></tr>
<tr class="separator:a09b3153dd6ad90a4960f476267820dd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad485a8b1231e36c3c400430144f88423" id="r_ad485a8b1231e36c3c400430144f88423"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad485a8b1231e36c3c400430144f88423">publishingEnabled</a> () const</td></tr>
<tr class="separator:ad485a8b1231e36c3c400430144f88423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079e98f7d3be026c4dc74228cc35f1cf" id="r_a079e98f7d3be026c4dc74228cc35f1cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a079e98f7d3be026c4dc74228cc35f1cf">removeLayerFromMap</a> (char const *layerName, char const *mapPath)</td></tr>
<tr class="separator:a079e98f7d3be026c4dc74228cc35f1cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a232130635daf11e3a2e0b18628a23b34" id="r_a232130635daf11e3a2e0b18628a23b34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a232130635daf11e3a2e0b18628a23b34">replaceLayerInMap</a> (const char *renditionFile=NULL, bool addIfMissing=true)</td></tr>
<tr class="separator:a232130635daf11e3a2e0b18628a23b34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f15c1286e383986dbab4abbad9fe034" id="r_a4f15c1286e383986dbab4abbad9fe034"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4f15c1286e383986dbab4abbad9fe034">replicate</a> (const char *destinationDirectory)</td></tr>
<tr class="separator:a4f15c1286e383986dbab4abbad9fe034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f459100cb099c0afd676fe2fe678ed0" id="r_a5f459100cb099c0afd676fe2fe678ed0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f459100cb099c0afd676fe2fe678ed0">requiredCacheSize</a> ()</td></tr>
<tr class="separator:a5f459100cb099c0afd676fe2fe678ed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71896998106cdab900ee2bf9d280cc7e" id="r_a71896998106cdab900ee2bf9d280cc7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71896998106cdab900ee2bf9d280cc7e">requiredCacheSize</a> (int size)</td></tr>
<tr class="separator:a71896998106cdab900ee2bf9d280cc7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6a5eb29630a47b2014ae7381af47be" id="r_a9b6a5eb29630a47b2014ae7381af47be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b6a5eb29630a47b2014ae7381af47be">rollback</a> (const char *archiveDirectory)</td></tr>
<tr class="separator:a9b6a5eb29630a47b2014ae7381af47be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11673e88bac9c9af19d3a960cfe84106" id="r_a11673e88bac9c9af19d3a960cfe84106"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11673e88bac9c9af19d3a960cfe84106">setProgressListener</a> (<a class="el" href="class_t_s_l_s_l_m_progress.html">TSLSLMProgress</a> *listener)</td></tr>
<tr class="separator:a11673e88bac9c9af19d3a960cfe84106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a395fd7dd21bf808e53eed6d25817111b" id="r_a395fd7dd21bf808e53eed6d25817111b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a395fd7dd21bf808e53eed6d25817111b">unlockLayer</a> ()</td></tr>
<tr class="separator:a395fd7dd21bf808e53eed6d25817111b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c162a2f3e7d644e205e8dc36b477c29" id="r_a9c162a2f3e7d644e205e8dc36b477c29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c162a2f3e7d644e205e8dc36b477c29">update</a> ()</td></tr>
<tr class="separator:a9c162a2f3e7d644e205e8dc36b477c29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512d9dcc6bb9b6e0de8e44ca08c86aa1" id="r_a512d9dcc6bb9b6e0de8e44ca08c86aa1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a512d9dcc6bb9b6e0de8e44ca08c86aa1">updateLayerExtent</a> ()</td></tr>
<tr class="separator:a512d9dcc6bb9b6e0de8e44ca08c86aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6639dafe8b581d782894192d766b4a4" id="r_ad6639dafe8b581d782894192d766b4a4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6639dafe8b581d782894192d766b4a4">updateLayerExtent</a> (double x, double y)</td></tr>
<tr class="separator:ad6639dafe8b581d782894192d766b4a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b41a5ddfed7b38ecfa4d571ec9fd9d5" id="r_a8b41a5ddfed7b38ecfa4d571ec9fd9d5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b41a5ddfed7b38ecfa4d571ec9fd9d5">operator new</a> (size_t size) TSL_NO_THROW</td></tr>
<tr class="separator:a8b41a5ddfed7b38ecfa4d571ec9fd9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e3c43c82221efddff970df52405c9a" id="r_a08e3c43c82221efddff970df52405c9a"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a08e3c43c82221efddff970df52405c9a">operator new</a> (size_t size, char *filename, int line)</td></tr>
<tr class="separator:a08e3c43c82221efddff970df52405c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5b67f915f68313dea79c3a150141a61f" id="r_a5b67f915f68313dea79c3a150141a61f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b67f915f68313dea79c3a150141a61f">setMapLinkVersion</a> (<a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a> version)</td></tr>
<tr class="separator:a5b67f915f68313dea79c3a150141a61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab3eb9c03fad1bc41e94862a334fa15ef" name="ab3eb9c03fad1bc41e94862a334fa15ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3eb9c03fad1bc41e94862a334fa15ef">&#9670;&#160;</a></span>TSLSeamlessLayerManager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TSLSeamlessLayerManager::TSLSeamlessLayerManager </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default Constructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acfe9cacbdc43f9b076a2a5a76d6a6b04" name="acfe9cacbdc43f9b076a2a5a76d6a6b04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe9cacbdc43f9b076a2a5a76d6a6b04">&#9670;&#160;</a></span>addLayerToMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::addLayerToMap </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>renditionFile</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds the current layer being managed by the manager to the map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renditionFile</td><td>A path to a rendition file. This file will be merged with the current rendition information contained within the map and, where conflicts occur, take precedence over any entries which are already present.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="afc6fa2054ca23a09ff6c90627754734c" name="afc6fa2054ca23a09ff6c90627754734c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6fa2054ca23a09ff6c90627754734c">&#9670;&#160;</a></span>cacheSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLSeamlessLayerManager::cacheSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size, in kilobytes, of the cache used by the Seamless Layer Manager. </p>

</div>
</div>
<a id="a8e0e474a8ade2a856b50ad35e458c95a" name="a8e0e474a8ade2a856b50ad35e458c95a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e0e474a8ade2a856b50ad35e458c95a">&#9670;&#160;</a></span>cacheSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::cacheSize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Defines the Seamless Layer Manager's cache size in kilobytes. By default this is set to 32MB. Note that the amount of memory used is approximately double the amount specified here.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>cache size in kilobytes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a88465500bb8247da74a37b0ee1ff8334" name="a88465500bb8247da74a37b0ee1ff8334"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88465500bb8247da74a37b0ee1ff8334">&#9670;&#160;</a></span>checkpointCurrentArchive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::checkpointCurrentArchive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a></td>          <td class="paramname"><span class="paramname"><em>timestamp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga64291901d816d2f37ae9f11b07ad457b">TSLHistoryVersion</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>nextArchiveVersion</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method updates the timestamp of the current archive version and then increments this version number so that the next archive will be assigned the updated version number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">timestamp</td><td>the timestamp to attach to the archive. </td></tr>
    <tr><td class="paramname">nextArchiveVersion</td><td>the version number that will be assigned to the next archive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise - in this case, the value of 'nextArchiveVersion' must be ignored. </dd></dl>

</div>
</div>
<a id="ace3ab4f79cd57ceaf209a0badc53ec35" name="ace3ab4f79cd57ceaf209a0badc53ec35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3ab4f79cd57ceaf209a0badc53ec35">&#9670;&#160;</a></span>configuration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_seamless_layer_config.html">TSLSeamlessLayerConfig</a> * TSLSeamlessLayerManager::configuration </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the current configuration. </p>

</div>
</div>
<a id="ab745ce8ad1a3fedcf203c78e1f648ba0" name="ab745ce8ad1a3fedcf203c78e1f648ba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab745ce8ad1a3fedcf203c78e1f648ba0">&#9670;&#160;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::destroy </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>deletes the object from memory, call this function instead of using delete </p>

</div>
</div>
<a id="a1e28d555d102e3fc9643b01cbb533558" name="a1e28d555d102e3fc9643b01cbb533558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e28d555d102e3fc9643b01cbb533558">&#9670;&#160;</a></span>enablePublishing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLSeamlessLayerManager::enablePublishing </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>enabled</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>directory</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows the user to set whether or not publishing is enabled.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td>boolean value indicating enabled (true) or disabled (false). </td></tr>
    <tr><td class="paramname">directory</td><td>The (temporary) directory which will hold the layer contents prior to publishing. If the layer is published, the contents of this directory will be transferred to the actual layer directory. This must be specified if enabled is set to 'true'. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae37b4d757371a7dd64a159c1b7a412f4" name="ae37b4d757371a7dd64a159c1b7a412f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37b4d757371a7dd64a159c1b7a412f4">&#9670;&#160;</a></span>entityRefHandler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> * TSLSeamlessLayerManager::entityRefHandler </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the entity reference handler which is currently in use.</p>
<p>Note: This reference handler is still owned by the Seamless Layer Manager and should not be deleted by the user. </p>

</div>
</div>
<a id="a601bf4e2990f08387c7af2b6a6d67e04" name="a601bf4e2990f08387c7af2b6a6d67e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601bf4e2990f08387c7af2b6a6d67e04">&#9670;&#160;</a></span>entityRefHandler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::entityRefHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_s_l_m_entity_ref_handler.html">TSLSLMEntityRefHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>handler</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the entity ref handler for the manager. Returns true if handler set successfully.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handler</td><td>the handler to set </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af412a5d2162f44258de3fc6a81a01ba1" name="af412a5d2162f44258de3fc6a81a01ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af412a5d2162f44258de3fc6a81a01ba1">&#9670;&#160;</a></span>finalise()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_t_s_l_seamless_layer_tile_list.html">TSLSeamlessLayerTileList</a> * TSLSeamlessLayerManager::finalise </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Completes the import or update phase of the SeamlessDataManager to provide a baseline set of tiles with duplicate and deleted entities removed. Until finalise is called the SeamlessDataManager will maintain information on the import or update process. At this stage it is possible that duplicate entities may exist within the dataset and/or deleted entities may not have been removed.</p>
<p>The const <a class="el" href="class_t_s_l_seamless_layer_tile_list.html">TSLSeamlessLayerTileList</a> returned by this method should not be deleted by the user.</p>
<p>none</p>
<dl class="section return"><dt>Returns</dt><dd>a constant pointer to a TSLSeamlessLayerList if successful, null otherwise. </dd></dl>

</div>
</div>
<a id="afd0a076ec6a69442d5ec519745977898" name="afd0a076ec6a69442d5ec519745977898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0a076ec6a69442d5ec519745977898">&#9670;&#160;</a></span>importCompatibleData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::importCompatibleData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *</td>          <td class="paramname"><span class="paramname"><em>layer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_s_l_m_import_result.html">TSLSLMImportResult</a> *</td>          <td class="paramname"><span class="paramname"><em>results</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowRegression</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_s_l_m_entity_store_handler.html">TSLSLMEntityStoreHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>storeHandler</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>updateTiles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The behaviour of this method is similar to that of importData, however it has a few distinct differences.</p>
<p>This method imports all data from the given <a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> provided that all entities contained within the layer are present in the data store and that the source id of each entity matches the version of the corresponding entity in the data store.</p>
<p>Any entities which conflict will be recorded in the <a class="el" href="class_t_s_l_s_l_m_import_result.html">TSLSLMImportResult</a> set and will not be imported.</p>
<p>TOIDs can revert to earlier versions, by setting the allowRegression flag to true. If this is done it is the user's responsibility to ensure that the import data set is correct, and contains only out-of-date TOIDs that are required to facilitate the regression.</p>
<p>Returns the <a class="el" href="class_t_s_l_s_l_m_import_result.html">TSLSLMImportResult</a>. If this has a size of zero the import has succeeded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>the standard data layer to import data from </td></tr>
    <tr><td class="paramname">results</td><td>the <a class="el" href="class_t_s_l_s_l_m_import_result.html">TSLSLMImportResult</a> </td></tr>
    <tr><td class="paramname">allowRegression</td><td>flag to indicate if TOID version regression is allowed - defaults to false. </td></tr>
    <tr><td class="paramname">storeHandler</td><td>An optional entity store handler to allow storage of entities to other persistent stores. </td></tr>
    <tr><td class="paramname">updateTiles</td><td>This is only valid if storeHandler is not NULL. If true (default), then the map tiles will be updated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4e28f9859efe81a04997a256d51cf003" name="a4e28f9859efe81a04997a256d51cf003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e28f9859efe81a04997a256d51cf003">&#9670;&#160;</a></span>ingestData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::ingestData </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> *</td>          <td class="paramname"><span class="paramname"><em>layer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>allowRegression</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_s_l_m_entity_store_handler.html">TSLSLMEntityStoreHandler</a> *</td>          <td class="paramname"><span class="paramname"><em>storeHandler</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>updateTiles</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga365925a0698ae664858cbe7383419cd6">TSLSeamlessLayerEntityChangeCallback</a></td>          <td class="paramname"><span class="paramname"><em>entityChangeCallback</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>arg</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Import data from a <a class="el" href="class_t_s_l_standard_data_layer.html">TSLStandardDataLayer</a> generated from data using the import data functionality in <a class="el" href="class_t_s_l_utility_functions.html">TSLUtilityFunctions</a>. This will then convert it to use the TCF seamless tiles.</p>
<p>TOIDs can revert to earlier versions, by setting the allowRegression flag to true. If this is done it is the user's responsibility to ensure that the import data set is correct, and contains only out-of-date TOIDs that are required to facilitate the regression.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer</td><td>the layer with imported data </td></tr>
    <tr><td class="paramname">allowRegression</td><td>flag to indicate if TOID version regression is allowed - defaults to false. </td></tr>
    <tr><td class="paramname">storeHandler</td><td>An optional entity store handler to allow storage of entities to other persistent stores. </td></tr>
    <tr><td class="paramname">updateTiles</td><td>This is only valid if storeHandler is not NULL. If true (default), then the map tiles will be updated. </td></tr>
    <tr><td class="paramname">entityChangeCallback</td><td>This callback will be invoked for each entity process by the seamless layer manager during an ingest. See the documentation for <a class="el" href="group__apigroup__api.html#ga365925a0698ae664858cbe7383419cd6">TSLSeamlessLayerEntityChangeCallback</a> for more information. </td></tr>
    <tr><td class="paramname">arg</td><td>A user-defined argument. This will be passed to the callback.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a5725a9a39a56cce5b44cd13e37987104" name="a5725a9a39a56cce5b44cd13e37987104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5725a9a39a56cce5b44cd13e37987104">&#9670;&#160;</a></span>initialiseExistingLayerForIngest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::initialiseExistingLayerForIngest </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>baseDirectory</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>mapFilename</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prepares the SeamlessLayerManager for import or update of data into the existing seamless detail layer. It loads the necessary information from the base directory where the seamless detail layer (and associated information) is stored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">baseDirectory</td><td>The location of the base directory where the existing seamless detail layer resides.</td></tr>
    <tr><td class="paramname">layerName</td><td>The name of the existing seamless layer to prepare for ingest.</td></tr>
    <tr><td class="paramname">mapFilename</td><td>This argument is optional. If set, it specifies the name of the map file that contains the seamless layer to update. This argument should be set if the map file being updated is different to the one originally given to initialseNewDetailLayer when the layer was created, e.g. if the map has been renamed since being created. If the full path to the map to use is passed, only the filename will be used. It is expected that the map file resides within the directory provided in the baseDirectory argument.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. A failure will occur if the seamless detail layer and it associated information does not exist. </dd></dl>

</div>
</div>
<a id="ab54ec5ea5511a4116c460709adc5bc6d" name="ab54ec5ea5511a4116c460709adc5bc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab54ec5ea5511a4116c460709adc5bc6d">&#9670;&#160;</a></span>initialiseNewDetailLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::initialiseNewDetailLayer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_seamless_layer_config.html">TSLSeamlessLayerConfig</a> *</td>          <td class="paramname"><span class="paramname"><em>config</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>mapFilename</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialises a seamless detail layer in preparation for importing or updating data to the specified layer.</p>
<p>Note: This method should not be used if you wish to create a new seamless layer which has the same name as one present in the map, but with a different configuration file. This is because the manager will use the file present on disk, rather than the one being passed in.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">config</td><td>A pointer to <a class="el" href="class_t_s_l_seamless_layer_config.html">TSLSeamlessLayerConfig</a> containing configuration settings for the grid and filename/path locations . n.b. see Class <a class="el" href="class_t_s_l_seamless_layer_config.html">TSLSeamlessLayerConfig</a> for more details. Note that the user is responsible for deleting this object.</td></tr>
    <tr><td class="paramname">mapFilename</td><td>optional map file name. This map file will be updated at the on final production of the detail layer to include new feature mappings and the EntityDataHandler to describe new attributes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. A failure will occur if the detail layer already exists and its parameters do not match those provided by <a class="el" href="class_t_s_l_seamless_layer_config.html">TSLSeamlessLayerConfig</a>. </dd></dl>

</div>
</div>
<a id="a8340d027c3b1dae7c243738a951c0656" name="a8340d027c3b1dae7c243738a951c0656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8340d027c3b1dae7c243738a951c0656">&#9670;&#160;</a></span>initialiseNewReplication()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::initialiseNewReplication </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method, called after initialiseLayer, prepares the seamless layer manager for a new replication session. It deletes any existing RPL file for the given layer, and resets the manager's replication features. </p>

</div>
</div>
<a id="a495b23f6502f4d50cdf140399ddd9e5a" name="a495b23f6502f4d50cdf140399ddd9e5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495b23f6502f4d50cdf140399ddd9e5a">&#9670;&#160;</a></span>isLayerLocked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::isLayerLocked </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the layer is locked. </p>

</div>
</div>
<a id="aca2c408ac6a49e62026b7846ae0747cf" name="aca2c408ac6a49e62026b7846ae0747cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2c408ac6a49e62026b7846ae0747cf">&#9670;&#160;</a></span>lockLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::lockLayer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Locks the layer.</p>
<p>Returns true if successful, false otherwise. </p>

</div>
</div>
<a id="a8b41a5ddfed7b38ecfa4d571ec9fd9d5" name="a8b41a5ddfed7b38ecfa4d571ec9fd9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b41a5ddfed7b38ecfa4d571ec9fd9d5">&#9670;&#160;</a></span>operator new() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLSeamlessLayerManager::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>These are here to avoid being documented Allocation redirection for API. </p>

</div>
</div>
<a id="a08e3c43c82221efddff970df52405c9a" name="a08e3c43c82221efddff970df52405c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08e3c43c82221efddff970df52405c9a">&#9670;&#160;</a></span>operator new() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLSeamlessLayerManager::operator new </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>size</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>line</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When included in an MFC application in debug mode, the debug new expects this to be here. Override it and return the same as the normal one. The library must include it when compiled in release mode, since the user's application may be in debug mode. </p>

</div>
</div>
<a id="a7a4a06daab130ebe3613f2bde0beeebb" name="a7a4a06daab130ebe3613f2bde0beeebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a4a06daab130ebe3613f2bde0beeebb">&#9670;&#160;</a></span>publish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::publish </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If publishing is enabled, the seamless layer manager does not directly overwrite existing map data when changes are made, instead storing it in a temporary directory hierarchy. This method provides a means of publishing any updates made by overwriting the existing map data with the contents of the temporary directories.</p>
<p>Returns true if successful, false otherwise. </p>

</div>
</div>
<a id="a09b3153dd6ad90a4960f476267820dd5" name="a09b3153dd6ad90a4960f476267820dd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b3153dd6ad90a4960f476267820dd5">&#9670;&#160;</a></span>publishAndArchive()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::publishAndArchive </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>archiveDirectory</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga17558588bd9622c21a3442a2b0e0f85c">TSLHistoryTimestamp</a></td>          <td class="paramname"><span class="paramname"><em>timestamp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>maintainCurrentArchiveVersion</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>archiveEntityReferences</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If publishing is enabled, the seamless layer manager does not directly overwrite existing map data when changes are made, instead storing it in a temporary directory hierarchy. This method provides a means of publishing any updates made by overwriting the existing map data with the contents of the temporary directories.</p>
<p>Prior to being overwritten, the existing map data is archived by storing them at the specified location with the provided timestamp. This archiving technique allows a history of changes to be built up which can be useful if data needs to be 'rolled-back' at a later date.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">archiveDirectory</td><td>The directory which is to contain the archived layer files.</td></tr>
    <tr><td class="paramname">timestamp</td><td>A timestamp to associate with the archive.</td></tr>
    <tr><td class="paramname">maintainCurrentArchiveVersion</td><td>Flag to indicate whether the current archive version number stays the same after this method finishes. If this flag is true, then subsequent archiving will move updated data into the same archive location as the current location. Default value is false.</td></tr>
    <tr><td class="paramname">archiveEntityReferences</td><td>Flag to indicate if the map's entity reference (dbref) files that have been updated during an ingest should be archived alongside the updated map data. These files are only necessary if you wish to use the <a class="el" href="class_t_s_l_map_data_layer.html#a87b9ac87a18507f210b9a7c9ff17cd10">TSLMapDataLayer::findEntityID()</a> method when flashed back to a historical version of the map contained within the archive. Archiving these files can significantly increase both the time taken to perform a publish and the size of the resulting archive, so this flag should only be set to true if the historical files will be needed. The default value is false.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="ad485a8b1231e36c3c400430144f88423" name="ad485a8b1231e36c3c400430144f88423"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad485a8b1231e36c3c400430144f88423">&#9670;&#160;</a></span>publishingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::publishingEnabled </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns whether or not publishing has been enabled for the manager. </p>

</div>
</div>
<a id="a079e98f7d3be026c4dc74228cc35f1cf" name="a079e98f7d3be026c4dc74228cc35f1cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079e98f7d3be026c4dc74228cc35f1cf">&#9670;&#160;</a></span>removeLayerFromMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::removeLayerFromMap </td>
          <td>(</td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char const *</td>          <td class="paramname"><span class="paramname"><em>mapPath</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the given seamless layer from the given map.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layerName</td><td>The name of the seamless layer to remove from the map.</td></tr>
    <tr><td class="paramname">mapPath</td><td>The path to the map file which the layer should be removed from.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a232130635daf11e3a2e0b18628a23b34" name="a232130635daf11e3a2e0b18628a23b34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a232130635daf11e3a2e0b18628a23b34">&#9670;&#160;</a></span>replaceLayerInMap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::replaceLayerInMap </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>renditionFile</em></span><span class="paramdefsep"> = </span><span class="paramdefval">NULL</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>addIfMissing</em></span><span class="paramdefsep"> = </span><span class="paramdefval">true</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the current layer in the map by the one currently being managed by the manager. If the layer is not in the map, it will be added, if the 'addIfMissing' flag is true.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renditionFile</td><td>A path to a rendition file. This file will be merged with the current rendition information contained within the map and, where conflicts occur, take precedence over any entries which are already present.</td></tr>
    <tr><td class="paramname">addIfMissing</td><td>A boolean flag specifying whether a layer should be added if it is not already present.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a4f15c1286e383986dbab4abbad9fe034" name="a4f15c1286e383986dbab4abbad9fe034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f15c1286e383986dbab4abbad9fe034">&#9670;&#160;</a></span>replicate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::replicate </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>destinationDirectory</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method copies all files which have been changed during the session and their associated entity references to the specified location.</p>
<p>Using the replication method allows updates to be identifiable from data which has remained unchanged during a session.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destinationDirectory</td><td>the directory to which updates and changes should be copied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5f459100cb099c0afd676fe2fe678ed0" name="a5f459100cb099c0afd676fe2fe678ed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f459100cb099c0afd676fe2fe678ed0">&#9670;&#160;</a></span>requiredCacheSize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLSeamlessLayerManager::requiredCacheSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the minimum required cache size, in kilobytes. </p>

</div>
</div>
<a id="a71896998106cdab900ee2bf9d280cc7e" name="a71896998106cdab900ee2bf9d280cc7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71896998106cdab900ee2bf9d280cc7e">&#9670;&#160;</a></span>requiredCacheSize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLSeamlessLayerManager::requiredCacheSize </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>size</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the minimum required cache size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>required cache size in kilobytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b6a5eb29630a47b2014ae7381af47be" name="a9b6a5eb29630a47b2014ae7381af47be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6a5eb29630a47b2014ae7381af47be">&#9670;&#160;</a></span>rollback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::rollback </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>archiveDirectory</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method provides a means of rolling back a map after a publishing and archive call has been made.</p>
<p>The requirements are:</p><ul>
<li>Publishing and archiving must be enabled.</li>
<li>This call can only be made after the publishAndArchive function has been called. If not then there is no reason to use rollback.</li>
<li>The 'archiveEntityReferences' parameter for the publishAndArchive call must be set to true.</li>
</ul>
<p>This method will:</p><ul>
<li>All tile and reference files in the archive folder will be copied back into the map's seamless layer folder structure, replacing existing files.</li>
<li>All newly added files will be removed.</li>
<li>All version history will be reverted back to previous versions, including the map's main version file.</li>
<li>The archive folder will be deleted.</li>
</ul>
<p>This method does not:</p><ul>
<li>delete or remove the seamless layer if it was inserted during the seamless layer manager's session.</li>
<li>revert back the feature class list.</li>
<li>delete any empty layer folders. note - it is the responsibility of the calling code to deal with the above situations.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">archiveDirectory</td><td>The directory which contains the archived layer files.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
<a id="a5b67f915f68313dea79c3a150141a61f" name="a5b67f915f68313dea79c3a150141a61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b67f915f68313dea79c3a150141a61f">&#9670;&#160;</a></span>setMapLinkVersion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void TSLSeamlessLayerManager::setMapLinkVersion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a></td>          <td class="paramname"><span class="paramname"><em>version</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the MapLink output format to use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">version</td><td>The version of MapLink to provide output for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a11673e88bac9c9af19d3a960cfe84106" name="a11673e88bac9c9af19d3a960cfe84106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11673e88bac9c9af19d3a960cfe84106">&#9670;&#160;</a></span>setProgressListener()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLSeamlessLayerManager::setProgressListener </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_s_l_m_progress.html">TSLSLMProgress</a> *</td>          <td class="paramname"><span class="paramname"><em>listener</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attach a progress listener.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>The progress listener. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a395fd7dd21bf808e53eed6d25817111b" name="a395fd7dd21bf808e53eed6d25817111b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a395fd7dd21bf808e53eed6d25817111b">&#9670;&#160;</a></span>unlockLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::unlockLayer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unlocks the layer.</p>
<p>Returns true if successful, false otherwise. </p>

</div>
</div>
<a id="a9c162a2f3e7d644e205e8dc36b477c29" name="a9c162a2f3e7d644e205e8dc36b477c29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c162a2f3e7d644e205e8dc36b477c29">&#9670;&#160;</a></span>update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::update </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the processing phase of the SeamlessDataManager to provide a baseline set of tiles with duplicate and deleted entities removed. This should be called if the processing is performed in chunks at a time prior to finalisation.</p>
<p>Returns true if successful, false otherwise. </p>

</div>
</div>
<a id="a512d9dcc6bb9b6e0de8e44ca08c86aa1" name="a512d9dcc6bb9b6e0de8e44ca08c86aa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512d9dcc6bb9b6e0de8e44ca08c86aa1">&#9670;&#160;</a></span>updateLayerExtent() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::updateLayerExtent </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the layer's extent based on the data it holds.</p>
<p>Returns true if successful, false otherwise. </p>

</div>
</div>
<a id="ad6639dafe8b581d782894192d766b4a4" name="ad6639dafe8b581d782894192d766b4a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6639dafe8b581d782894192d766b4a4">&#9670;&#160;</a></span>updateLayerExtent() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLSeamlessLayerManager::updateLayerExtent </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Updates the layer's extent based on the given values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x,y</td><td>The top-right corner of the layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful, false otherwise. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_seamless_layer_manager.html">TSLSeamlessLayerManager</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.2 | Documentation created Wed Jul 23 2025 18:23:17 | Generated with <a href="http://www.doxygen.org/index.html">Doxygen 1.13.2</a> | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
