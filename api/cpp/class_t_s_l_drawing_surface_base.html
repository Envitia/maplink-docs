<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.13.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>MapLink Pro: TSLDrawingSurfaceBase Class Reference</title>
<link rel="icon" href="MapLink Pro 11 Logo Circle No Shadow FX New V1.1.png" type="image/x-icon" />
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="envitia.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="MapLink Pro 11 Logo New V1.1.png"/></td>
  <td id="projectalign">
   <div id="projectname">MapLink Pro<span id="projectnumber">&#160;11.2</span>
   </div>
   <div id="projectbrief">Envitia MapLink Pro: The Ultimate Mapping Application Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.13.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>MapLink&#160;Pro</span></a></li>
      <li><a href="topics.html"><span>MapLink&#160;Pro&#160;C++&#160;API</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('class_t_s_l_drawing_surface_base.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="class_t_s_l_drawing_surface_base-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TSLDrawingSurfaceBase Class Reference<div class="ingroups"><a class="el" href="group__apigroup__maplink__pro__developers__toolkit.html">MapLink Pro Developer Toolkit</a> &raquo; <a class="el" href="group__apigroup__api.html">Core API</a></div></div></div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for TSLDrawingSurfaceBase:</div>
<div class="dyncontent">
<div class="center"><img src="class_t_s_l_drawing_surface_base__inherit__graph.png" border="0" usemap="#a_t_s_l_drawing_surface_base_inherit__map" alt="Inheritance graph"/></div>
<map name="a_t_s_l_drawing_surface_base_inherit__map" id="a_t_s_l_drawing_surface_base_inherit__map">
<area shape="rect" title=" " alt="" coords="5,99,144,121"/>
<area shape="rect" href="class_t_s_l3_d_drawing_surface.html" title=" " alt="" coords="192,52,320,75"/>
<area shape="poly" title=" " alt="" coords="132,93,210,72,211,77,134,98"/>
<area shape="rect" href="class_t_s_l_drawing_surface.html" title=" " alt="" coords="199,145,313,168"/>
<area shape="poly" title=" " alt="" coords="134,122,211,143,210,148,132,127"/>
<area shape="rect" href="class_t_s_l3_d_win_g_l_surface.html" title=" " alt="" coords="375,5,494,28"/>
<area shape="poly" title=" " alt="" coords="313,46,389,26,391,31,314,51"/>
<area shape="rect" href="class_t_s_l3_d_x11_g_l_surface.html" title=" " alt="" coords="375,52,494,75"/>
<area shape="poly" title=" " alt="" coords="334,61,375,61,375,66,334,66"/>
<area shape="rect" href="class_t_s_l_accelerated_surface.html" title=" " alt="" coords="368,99,501,121"/>
<area shape="poly" title=" " alt="" coords="313,139,389,119,391,124,314,144"/>
<area shape="rect" href="class_t_s_l_motif_surface.html" title=" " alt="" coords="385,145,485,168"/>
<area shape="poly" title=" " alt="" coords="327,154,384,154,384,159,327,159"/>
<area shape="rect" href="class_t_s_l_n_t_surface.html" title=" " alt="" coords="390,192,479,215"/>
<area shape="poly" title=" " alt="" coords="314,169,391,189,389,194,313,174"/>
<area shape="rect" href="class_t_s_l_open_g_l_surface.html" title=" " alt="" coords="377,239,492,261"/>
<area shape="poly" title=" " alt="" coords="286,174,324,199,369,224,399,236,397,241,367,228,322,203,283,178"/>
<area shape="rect" href="class_t_s_l_d_x_accelerated_surface.html" title=" " alt="" coords="557,52,704,75"/>
<area shape="poly" title=" " alt="" coords="496,93,582,72,583,77,497,98"/>
<area shape="rect" href="class_t_s_l_w_g_l_accelerated_surface.html" title=" " alt="" coords="553,99,708,121"/>
<area shape="poly" title=" " alt="" coords="515,107,553,107,553,113,515,113"/>
<area shape="rect" href="class_t_s_l_x11_g_l_accelerated_surface.html" title=" " alt="" coords="549,145,712,168"/>
<area shape="poly" title=" " alt="" coords="497,122,583,143,582,148,496,127"/>
<area shape="rect" href="class_t_s_l_e_g_l_surface.html" title=" " alt="" coords="583,192,678,215"/>
<area shape="poly" title=" " alt="" coords="496,233,583,212,584,217,497,238"/>
<area shape="rect" href="class_t_s_l_g_l_x_surface.html" title=" " alt="" coords="583,239,678,261"/>
<area shape="poly" title=" " alt="" coords="506,247,583,247,583,253,506,253"/>
<area shape="rect" href="class_t_s_l_w_g_l_surface.html" title=" " alt="" coords="581,285,680,308"/>
<area shape="poly" title=" " alt="" coords="497,262,583,283,582,288,496,267"/>
<area shape="rect" href="class_t_s_l_native_e_g_l_surface.html" title=" " alt="" coords="760,192,885,215"/>
<area shape="poly" title=" " alt="" coords="692,201,760,201,760,206,692,206"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Passive base component for displaying data to a user supplied window.</p>
<p>The <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> component is the common functionality used for both 2D and 3D Drawing Surfaces. 3D Drawing Surfaces are supplied in a separate MapLink component. It is an abstract class and cannot be instantiated. Instead the platform specific derivative must be created.</p>
<p>As the <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> is passive, there are no inherent event handling routines.</p>
<p>This component provides the following capabilities</p>
<ul>
<li>Connection of the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> to a user window</li>
<li>Management of data layers</li>
<li>Manipulation of the rendering of features in the map layers</li>
<li>Control of the visibility of features in the map layers</li>
<li>Miscellaneous methods</li>
</ul>
<p>Drawing methods and view management are provided by the derived classes.</p>
<p>A <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> must be connected to a user-supplied window (or HDC/Pixmap) before it can display anything. It does not create a window of its own. This gives the user control over what is displayed in the window.</p>
<p>A <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> derived object will display data from any data layers that are connected to it. The ordering and visibility of the data layers used in the <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> are under the control of the user. The methods for connection and disconnection of the data layers to the <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> are 'addDataLayer' and 'removeDataLayer'. The ordering of the data layers are controlled by the methods 'bringInFrontOf', 'sendToBackOf', 'bringToFront' and 'sendToBack'. The properties of the data layer within the <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a>, e.g. detectability, selectability, visibility and automatic tiling for map layers, can be modified using 'setDataLayerProps' and examined by 'getDataLayerProps'.</p>
<p>The background colour of the <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> may be defined by the method 'setBackgroundColour'. To make the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> transparent, the method 'clearBackgroundColour' may be called. This allows the user application to draw under the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> without the image being erased when the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> is drawn.</p>
<p>The rendering of map features within the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> can be modified using the methods 'loadRendering', 'saveRendering', 'setFeatureRendering', 'getFeatureRendering' and 'clearFeatureRendering'. Rendering information held by the <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> overrides any rendering information held within a Data Layer for a particular feature.</p>
<p>The visibility of individual map features within the <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> can be modified using the methods 'loadDeclutter', 'saveDeclutter' , 'setDeclutterRange' , 'setDeclutterStatus' and examined using the method 'getDeclutterRange' and 'getDeclutterStatus'. Groups of related features can be decluttered using 'setDeclutterStatus'. A drawing surface internally has two sets of declutter settings, a global list that is applied to all data layers in the drawing surface, and a per-layer list that applies to a single data layer that inherits and extends the global list. When modifying declutter settings using the above methods the application can control whether the setting should be set on the global list (and thus apply to all layers in the drawing surface) or a specific data layer's list through the layer name argument of each method.</p>
<p>This class is an abstract class, specifying the generic behaviour of a <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a>.</p>
<h2><a class="anchor" id="autotoc_md64"></a>
Thread Safety</h2>
<p>MapLink can be used in multiple threads if a degree of care is taken by the user.</p>
<p>The principle rule is that Drawing surfaces and TSLMapDataLayers must be not be shared between threads.</p>
<p>Additionally loading of the Coordinate Systems and adding or removing coordinate systems is not thread safe.</p>
<p>Additional guidance can be obtained from support.</p>
<h2><a class="anchor" id="autotoc_md65"></a>
OS Specific Types</h2>
<p>The types used to return OS specific drawing are as follows:</p>
<p>TSLDeviceContext : Windows 'HDC'. TSLWindowHandle : Windows 'HWND'. TSLBitmapHandle : Windows 'HBITMAP', X11 a pointer to a structure declared in tslplatformtypes.h. TSLDrawableHandle : X11 'Drawable'. TSLVisualHandle : X11 'Visual *'. TSLColourmapHandle : X11 'Colormap'. TSLScreenHandle : X11 'Screen *'. TSLDisplayHandle : X11 'Display *'.</p>
<p>If you pass a specific OS type to a method or you are querying a method which returns an OS specific type as defined above you may need to cast the result or argument to the type expected. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adf2508e14060aa37e3f64d3d4daedb83" id="r_adf2508e14060aa37e3f64d3d4daedb83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf2508e14060aa37e3f64d3d4daedb83">addDataLayer</a> (<a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> *data_layer_interface, const char *data_id)</td></tr>
<tr class="separator:adf2508e14060aa37e3f64d3d4daedb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a756782b5ecf3f00c22d8a20c40096453" id="r_a756782b5ecf3f00c22d8a20c40096453"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a756782b5ecf3f00c22d8a20c40096453">addDynamicRenderer</a> (<a class="el" href="class_t_s_l_dynamic_renderer.html">TSLDynamicRenderer</a> *renderer, TSLFeatureID featureID=-1, const char *layerName=0)</td></tr>
<tr class="separator:a756782b5ecf3f00c22d8a20c40096453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab28c609ffd861cc7e0f1de9a4e3ffff9" id="r_ab28c609ffd861cc7e0f1de9a4e3ffff9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab28c609ffd861cc7e0f1de9a4e3ffff9">addFeatureRendering</a> (const char *featureName, TSLFeatureID featureID)</td></tr>
<tr class="separator:ab28c609ffd861cc7e0f1de9a4e3ffff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad695674703054f6dde4f8f472160ca82" id="r_ad695674703054f6dde4f8f472160ca82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad695674703054f6dde4f8f472160ca82">attach</a> (TSLDeviceContext handle)</td></tr>
<tr class="separator:ad695674703054f6dde4f8f472160ca82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac268beaaf3462b6d6a1845bebb3fb113" id="r_ac268beaaf3462b6d6a1845bebb3fb113"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac268beaaf3462b6d6a1845bebb3fb113">attach</a> (TSLWindowHandle handle)</td></tr>
<tr class="separator:ac268beaaf3462b6d6a1845bebb3fb113"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab367bb38ef5a8e3ce9df1b17fe665fbd" id="r_ab367bb38ef5a8e3ce9df1b17fe665fbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab367bb38ef5a8e3ce9df1b17fe665fbd">attach</a> (TSLDrawableHandle handle)</td></tr>
<tr class="separator:ab367bb38ef5a8e3ce9df1b17fe665fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fa764a7e039e56f2489a1f62d238701" id="r_a5fa764a7e039e56f2489a1f62d238701"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fa764a7e039e56f2489a1f62d238701">bringInFrontof</a> (const char *move_data_layer, const char *target_data_layer)</td></tr>
<tr class="separator:a5fa764a7e039e56f2489a1f62d238701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccd258d58e99d15c4bcae1b4c1170f7" id="r_aeccd258d58e99d15c4bcae1b4c1170f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeccd258d58e99d15c4bcae1b4c1170f7">bringToFront</a> (const char *move_data_layer)</td></tr>
<tr class="separator:aeccd258d58e99d15c4bcae1b4c1170f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171387fcf2304549fffe4982562ca4c2" id="r_a171387fcf2304549fffe4982562ca4c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a171387fcf2304549fffe4982562ca4c2">clearAllDeclutterData</a> (const char *layer_name=0)</td></tr>
<tr class="separator:a171387fcf2304549fffe4982562ca4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55bdcd971140c6640265b2acc4457eb5" id="r_a55bdcd971140c6640265b2acc4457eb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55bdcd971140c6640265b2acc4457eb5">clearAllDynamicRenderers</a> ()</td></tr>
<tr class="separator:a55bdcd971140c6640265b2acc4457eb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdabfe424ab268061573eafed87ffb04" id="r_afdabfe424ab268061573eafed87ffb04"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afdabfe424ab268061573eafed87ffb04">clearBackgroundColour</a> ()</td></tr>
<tr class="separator:afdabfe424ab268061573eafed87ffb04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59e94baf9c65b8079c543b7945365d07" id="r_a59e94baf9c65b8079c543b7945365d07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59e94baf9c65b8079c543b7945365d07">clearDeclutterData</a> (const char *feature_name, const char *layer_name=0)</td></tr>
<tr class="separator:a59e94baf9c65b8079c543b7945365d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7373de95bfb938c2226e8f294280a3a" id="r_af7373de95bfb938c2226e8f294280a3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af7373de95bfb938c2226e8f294280a3a">clearDynamicRenderer</a> (TSLFeatureID featureID=-1, const char *layerName=0)</td></tr>
<tr class="separator:af7373de95bfb938c2226e8f294280a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a6a56d2729aa0a1fafe37b6aa04f52" id="r_a25a6a56d2729aa0a1fafe37b6aa04f52"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25a6a56d2729aa0a1fafe37b6aa04f52">clearFeatureRendering</a> (const char *featureName, TSLFeatureID featureID)</td></tr>
<tr class="separator:a25a6a56d2729aa0a1fafe37b6aa04f52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b812d3c132366b9f20b92110c8dad6f" id="r_a7b812d3c132366b9f20b92110c8dad6f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7b812d3c132366b9f20b92110c8dad6f">clearFrame</a> ()</td></tr>
<tr class="separator:a7b812d3c132366b9f20b92110c8dad6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e62109d1d6673dc37cbb79f0d13cef" id="r_ab3e62109d1d6673dc37cbb79f0d13cef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab3e62109d1d6673dc37cbb79f0d13cef">copyDeclutterData</a> (const char *src_feature_name, const char *dest_feature_name, const char *src_layer_name=0, const char *dest_layer_name=0)</td></tr>
<tr class="separator:ab3e62109d1d6673dc37cbb79f0d13cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b35a14f96de605f73191cbb04b86cf" id="r_a27b35a14f96de605f73191cbb04b86cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a27b35a14f96de605f73191cbb04b86cf">detach</a> ()</td></tr>
<tr class="separator:a27b35a14f96de605f73191cbb04b86cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f3ab638243f6016c21bdffb6f28a44" id="r_aa6f3ab638243f6016c21bdffb6f28a44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6f3ab638243f6016c21bdffb6f28a44">detachAllDynamicRenderers</a> ()</td></tr>
<tr class="separator:aa6f3ab638243f6016c21bdffb6f28a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc62268d7293cc9fac136200e6aed62" id="r_a0fc62268d7293cc9fac136200e6aed62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0fc62268d7293cc9fac136200e6aed62">detachDynamicRenderer</a> (TSLFeatureID featureID=-1, const char *layerName=0)</td></tr>
<tr class="separator:a0fc62268d7293cc9fac136200e6aed62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0da02a3dca66e350f188cc66d49b95d5" id="r_a0da02a3dca66e350f188cc66d49b95d5"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0da02a3dca66e350f188cc66d49b95d5">featureClass</a> (TSLFeatureID feature_id)</td></tr>
<tr class="separator:a0da02a3dca66e350f188cc66d49b95d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f617343c50c8f907c05a895adc0f710" id="r_a5f617343c50c8f907c05a895adc0f710"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f617343c50c8f907c05a895adc0f710">forceLayer</a> (const char *data_id, const char *detail_layer_name)</td></tr>
<tr class="separator:a5f617343c50c8f907c05a895adc0f710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3f571b473fae1be0e3fda757f8a84a" id="r_aef3f571b473fae1be0e3fda757f8a84a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aef3f571b473fae1be0e3fda757f8a84a">getBackgroundColour</a> (TSLStyleID *value)</td></tr>
<tr class="separator:aef3f571b473fae1be0e3fda757f8a84a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff44ab7558d9044846c390b9c69b43c7" id="r_aff44ab7558d9044846c390b9c69b43c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff44ab7558d9044846c390b9c69b43c7">getColourValue</a> (int colour, unsigned char &amp;r, unsigned char &amp;g, unsigned char &amp;b)</td></tr>
<tr class="separator:aff44ab7558d9044846c390b9c69b43c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a008b6ccaa73f5e7dedf2c09cc7feeb64" id="r_a008b6ccaa73f5e7dedf2c09cc7feeb64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a008b6ccaa73f5e7dedf2c09cc7feeb64">getDataLayer</a> (const char *data_id)</td></tr>
<tr class="separator:a008b6ccaa73f5e7dedf2c09cc7feeb64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630ab91eba6e19889be3e4bb041cf023" id="r_a630ab91eba6e19889be3e4bb041cf023"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a630ab91eba6e19889be3e4bb041cf023">getDataLayerInfo</a> (int N, <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> **dataLayer, const char **layerName) const</td></tr>
<tr class="separator:a630ab91eba6e19889be3e4bb041cf023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319f8ac2a9cd7254e95120afe0c1ecfa" id="r_a319f8ac2a9cd7254e95120afe0c1ecfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a319f8ac2a9cd7254e95120afe0c1ecfa">getDataLayerProps</a> (const char *data_id, <a class="el" href="group__apigroup__api.html#ga1c467581ddf31341ac6acf6baa297a9a">TSLPropertyEnum</a> property_id, TSLPropertyValue *old_value)</td></tr>
<tr class="separator:a319f8ac2a9cd7254e95120afe0c1ecfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d9532d2f61896824476e912db4efff" id="r_ad2d9532d2f61896824476e912db4efff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad2d9532d2f61896824476e912db4efff">getDeclutterStatus</a> (const char *feature_name, <a class="el" href="group__apigroup__api.html#gadd64c2d584f0cab2498c784c9451d85e">TSLDeclutterStatusResultEnum</a> *value, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:ad2d9532d2f61896824476e912db4efff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61d832cd81e2c7a0ea2fa9744aec16a" id="r_ae61d832cd81e2c7a0ea2fa9744aec16a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae61d832cd81e2c7a0ea2fa9744aec16a">getDeclutterStatus</a> (TSLFeatureID feature_id, <a class="el" href="group__apigroup__api.html#gadd64c2d584f0cab2498c784c9451d85e">TSLDeclutterStatusResultEnum</a> *value, const char *dataLayerName, const char *detailLayerName=0)</td></tr>
<tr class="separator:ae61d832cd81e2c7a0ea2fa9744aec16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d31320e6500e887e85cc4a95e19c198" id="r_a0d31320e6500e887e85cc4a95e19c198"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_dynamic_renderer.html">TSLDynamicRenderer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d31320e6500e887e85cc4a95e19c198">getDynamicRenderer</a> (TSLFeatureID featureID=-1, const char *layerName=0)</td></tr>
<tr class="separator:a0d31320e6500e887e85cc4a95e19c198"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80b26948542c04c89ed561e953ba0e3a" id="r_a80b26948542c04c89ed561e953ba0e3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80b26948542c04c89ed561e953ba0e3a">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a> attribute, int *result) const</td></tr>
<tr class="separator:a80b26948542c04c89ed561e953ba0e3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4df913acb00ac825e165e5c71fdf73" id="r_a8c4df913acb00ac825e165e5c71fdf73"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8c4df913acb00ac825e165e5c71fdf73">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a> attribute, double *result) const</td></tr>
<tr class="separator:a8c4df913acb00ac825e165e5c71fdf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4248cc44247ca3696199db1b2913b5" id="r_a0b4248cc44247ca3696199db1b2913b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b4248cc44247ca3696199db1b2913b5">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a> attribute, bool *result) const</td></tr>
<tr class="separator:a0b4248cc44247ca3696199db1b2913b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13420230fd95cafe4f7829a49ffa2b07" id="r_a13420230fd95cafe4f7829a49ffa2b07"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a13420230fd95cafe4f7829a49ffa2b07">getFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *result) const</td></tr>
<tr class="separator:a13420230fd95cafe4f7829a49ffa2b07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef0f78c36be8c30078671de5f56e2a1" id="r_acef0f78c36be8c30078671de5f56e2a1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acef0f78c36be8c30078671de5f56e2a1">getNumDataLayers</a> () const</td></tr>
<tr class="separator:acef0f78c36be8c30078671de5f56e2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a03a127eeee2f9c9a8fed466a7e5edd" id="r_a0a03a127eeee2f9c9a8fed466a7e5edd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0a03a127eeee2f9c9a8fed466a7e5edd">getOption</a> (<a class="el" href="group__apigroup__api.html#ga28a256688c01415721a7700d84fa55bd">TSLOptionEnum</a> option)</td></tr>
<tr class="separator:a0a03a127eeee2f9c9a8fed466a7e5edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a0fb6b5f0ac7270b4f321822897192" id="r_a07a0fb6b5f0ac7270b4f321822897192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07a0fb6b5f0ac7270b4f321822897192">id</a> (int id_)</td></tr>
<tr class="separator:a07a0fb6b5f0ac7270b4f321822897192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41229ebf8a2a4e0e1639616d7a8efffd" id="r_a41229ebf8a2a4e0e1639616d7a8efffd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a41229ebf8a2a4e0e1639616d7a8efffd">id</a> () const</td></tr>
<tr class="separator:a41229ebf8a2a4e0e1639616d7a8efffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18fb9812a2e699c06d1aa787787f9ad6" id="r_a18fb9812a2e699c06d1aa787787f9ad6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a18fb9812a2e699c06d1aa787787f9ad6">idleProcess</a> ()</td></tr>
<tr class="separator:a18fb9812a2e699c06d1aa787787f9ad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f8e4094017e7699433efa30fdbbde9b" id="r_a5f8e4094017e7699433efa30fdbbde9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f8e4094017e7699433efa30fdbbde9b">loadDeclutter</a> (const char *filename)</td></tr>
<tr class="separator:a5f8e4094017e7699433efa30fdbbde9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337cadfa02f94128a8f90a82083292fa" id="r_a337cadfa02f94128a8f90a82083292fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a337cadfa02f94128a8f90a82083292fa">loadRendering</a> (const char *filename)</td></tr>
<tr class="separator:a337cadfa02f94128a8f90a82083292fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4585d14f142c6517ddbe21c72cca8f7" id="r_ac4585d14f142c6517ddbe21c72cca8f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_pick_result_set.html">TSLPickResultSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac4585d14f142c6517ddbe21c72cca8f7">pick</a> (TSLDeviceUnits x, TSLDeviceUnits y, TSLDeviceUnits aperture, int depth, <a class="el" href="class_t_s_l_pick_selector.html">TSLPickSelector</a> *selector=0)</td></tr>
<tr class="separator:ac4585d14f142c6517ddbe21c72cca8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ab561be1f46b9cc34cdd5d9fc42664" id="r_ad0ab561be1f46b9cc34cdd5d9fc42664"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_t_s_l_pick_result_set.html">TSLPickResultSet</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad0ab561be1f46b9cc34cdd5d9fc42664">pick</a> (const char *data_id, TSLDeviceUnits x, TSLDeviceUnits y, TSLDeviceUnits aperture, int depth=-1, <a class="el" href="class_t_s_l_pick_selector.html">TSLPickSelector</a> *selector=0)</td></tr>
<tr class="separator:ad0ab561be1f46b9cc34cdd5d9fc42664"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b56d4ff2cebea8e1606d4554d9c18c4" id="r_a4b56d4ff2cebea8e1606d4554d9c18c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b56d4ff2cebea8e1606d4554d9c18c4">queryActiveLayer</a> (const char *data_id, char *detail_layer_name, int detail_layer_name_size)</td></tr>
<tr class="separator:a4b56d4ff2cebea8e1606d4554d9c18c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a035ee62299073d81104620eb96ee8d58" id="r_a035ee62299073d81104620eb96ee8d58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a035ee62299073d81104620eb96ee8d58">removeDataLayer</a> (const char *data_id)</td></tr>
<tr class="separator:a035ee62299073d81104620eb96ee8d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dda3044708be3978cb05fb57bf23b4" id="r_a82dda3044708be3978cb05fb57bf23b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a82dda3044708be3978cb05fb57bf23b4">saveDeclutter</a> (const char *filename, <a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a> ver=<a class="el" href="group__apigroup__common.html#gga8141b1e165228e088c49024076e13758a0ecdea6c91f1d3104d6166d69b57c88d">TSL_CURRENT_MAPLINK_VERSION</a>)</td></tr>
<tr class="separator:a82dda3044708be3978cb05fb57bf23b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b70a8a01f666ecd5fa6ebe04feed246" id="r_a4b70a8a01f666ecd5fa6ebe04feed246"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4b70a8a01f666ecd5fa6ebe04feed246">saveRendering</a> (const char *filename, <a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a> ver=<a class="el" href="group__apigroup__common.html#gga8141b1e165228e088c49024076e13758a0ecdea6c91f1d3104d6166d69b57c88d">TSL_CURRENT_MAPLINK_VERSION</a>)</td></tr>
<tr class="separator:a4b70a8a01f666ecd5fa6ebe04feed246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12641ebccfa6b934b66b47dacf0d6e4f" id="r_a12641ebccfa6b934b66b47dacf0d6e4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12641ebccfa6b934b66b47dacf0d6e4f">sendToBack</a> (const char *move_data_layer)</td></tr>
<tr class="separator:a12641ebccfa6b934b66b47dacf0d6e4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4862277014463d564f9b3a64bb1f32e9" id="r_a4862277014463d564f9b3a64bb1f32e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4862277014463d564f9b3a64bb1f32e9">sendToBackOf</a> (const char *move_data_layer, const char *target_data_layer)</td></tr>
<tr class="separator:a4862277014463d564f9b3a64bb1f32e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e4919227d150a0aa99fc135ea032ee" id="r_a17e4919227d150a0aa99fc135ea032ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a17e4919227d150a0aa99fc135ea032ee">setBackgroundColour</a> (int value)</td></tr>
<tr class="separator:a17e4919227d150a0aa99fc135ea032ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b6f63130d3fbb377eec5c56d2d68cea" id="r_a0b6f63130d3fbb377eec5c56d2d68cea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b6f63130d3fbb377eec5c56d2d68cea">setCoordinateProvidingLayer</a> (const char *layer_name)</td></tr>
<tr class="separator:a0b6f63130d3fbb377eec5c56d2d68cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe537ed2746b65ecf6349f9efd967173" id="r_afe537ed2746b65ecf6349f9efd967173"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe537ed2746b65ecf6349f9efd967173">setDataLayerProps</a> (const char *data_id, <a class="el" href="group__apigroup__api.html#ga1c467581ddf31341ac6acf6baa297a9a">TSLPropertyEnum</a> property_id, TSLPropertyValue new_value)</td></tr>
<tr class="separator:afe537ed2746b65ecf6349f9efd967173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1652a09b42b30587627b88c83ac0ecec" id="r_a1652a09b42b30587627b88c83ac0ecec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1652a09b42b30587627b88c83ac0ecec">setDeclutterStatus</a> (const char *feature_name, <a class="el" href="group__apigroup__api.html#gababcf35d0e42f024d8d93535c70bf928">TSLDeclutterStatusEnum</a> value, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:a1652a09b42b30587627b88c83ac0ecec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b777dcbefd270725084ff917384de5" id="r_a59b777dcbefd270725084ff917384de5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59b777dcbefd270725084ff917384de5">setDeclutterStatus</a> (TSLFeatureID feature_id, <a class="el" href="group__apigroup__api.html#gababcf35d0e42f024d8d93535c70bf928">TSLDeclutterStatusEnum</a> value, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:a59b777dcbefd270725084ff917384de5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e1edf066975321c7cd825af58beb1d4" id="r_a7e1edf066975321c7cd825af58beb1d4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7e1edf066975321c7cd825af58beb1d4">setDeclutterStatusOnAllFeatures</a> (<a class="el" href="group__apigroup__api.html#gababcf35d0e42f024d8d93535c70bf928">TSLDeclutterStatusEnum</a> value, const char *dataLayerName=0, const char *detailLayerName=0)</td></tr>
<tr class="separator:a7e1edf066975321c7cd825af58beb1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad28bc4cacd259f533cd6b6d31baff5f" id="r_aad28bc4cacd259f533cd6b6d31baff5f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad28bc4cacd259f533cd6b6d31baff5f">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a> attribute, int value)</td></tr>
<tr class="separator:aad28bc4cacd259f533cd6b6d31baff5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a843e54b936b459e6dfecf49543665bfa" id="r_a843e54b936b459e6dfecf49543665bfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a843e54b936b459e6dfecf49543665bfa">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a> attribute, double value)</td></tr>
<tr class="separator:a843e54b936b459e6dfecf49543665bfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d01bf5edd3a7f32f012a5b9a852cad1" id="r_a6d01bf5edd3a7f32f012a5b9a852cad1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d01bf5edd3a7f32f012a5b9a852cad1">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a> attribute, bool value)</td></tr>
<tr class="separator:a6d01bf5edd3a7f32f012a5b9a852cad1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e00cc9c70d5fbef37124d4e309ab00c" id="r_a6e00cc9c70d5fbef37124d4e309ab00c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6e00cc9c70d5fbef37124d4e309ab00c">setFeatureRendering</a> (const char *featureName, TSLFeatureID featureID, <a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *value)</td></tr>
<tr class="separator:a6e00cc9c70d5fbef37124d4e309ab00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae14d30f7088fab43c1f816d823d1955b" id="r_ae14d30f7088fab43c1f816d823d1955b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae14d30f7088fab43c1f816d823d1955b">setFrame</a> (int style, int colour, int thickness)</td></tr>
<tr class="separator:ae14d30f7088fab43c1f816d823d1955b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11f53b83793beb451d1dd7be0f3303d8" id="r_a11f53b83793beb451d1dd7be0f3303d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a11f53b83793beb451d1dd7be0f3303d8">setOption</a> (<a class="el" href="group__apigroup__api.html#ga28a256688c01415721a7700d84fa55bd">TSLOptionEnum</a> option, bool value)</td></tr>
<tr class="separator:a11f53b83793beb451d1dd7be0f3303d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3c2bc3e7e95b72564a91c16f046cfd" id="r_adb3c2bc3e7e95b72564a91c16f046cfd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb3c2bc3e7e95b72564a91c16f046cfd">TMCperMU</a> ()</td></tr>
<tr class="separator:adb3c2bc3e7e95b72564a91c16f046cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dadd653096a1f0cb6fb49a2a08ebf6b" id="r_a5dadd653096a1f0cb6fb49a2a08ebf6b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__apigroup__api.html#ga76e1969f4b1b3d601f72cf5936520601">TSLDrawingSurfaceTypeEnum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5dadd653096a1f0cb6fb49a2a08ebf6b">type</a> () const</td></tr>
<tr class="separator:a5dadd653096a1f0cb6fb49a2a08ebf6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de924d9df6935f26a9e3bee9d59253a" id="r_a1de924d9df6935f26a9e3bee9d59253a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1de924d9df6935f26a9e3bee9d59253a">userWord</a> (void *ptr) const</td></tr>
<tr class="separator:a1de924d9df6935f26a9e3bee9d59253a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba63d2164415f471b835402054095de" id="r_a2ba63d2164415f471b835402054095de"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2ba63d2164415f471b835402054095de">userWord</a> () const</td></tr>
<tr class="separator:a2ba63d2164415f471b835402054095de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca53495ddd20981f1ff20b3f4972b17" id="r_a8ca53495ddd20981f1ff20b3f4972b17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8ca53495ddd20981f1ff20b3f4972b17">cloneDynamicRenderersFrom</a> (const <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> *otherSurface)</td></tr>
<tr class="separator:a8ca53495ddd20981f1ff20b3f4972b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a5591424a0629788811bca54086242" id="r_a58a5591424a0629788811bca54086242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58a5591424a0629788811bca54086242">addDuplicateLayers</a> (bool value)</td></tr>
<tr class="separator:a58a5591424a0629788811bca54086242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6867615c69a56a04cf0d742233ffd4b2" id="r_a6867615c69a56a04cf0d742233ffd4b2"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6867615c69a56a04cf0d742233ffd4b2">~TSLDrawingSurfaceBase</a> ()</td></tr>
<tr class="separator:a6867615c69a56a04cf0d742233ffd4b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aed9a67d3faea852e71e981ba5550b10e" id="r_aed9a67d3faea852e71e981ba5550b10e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aed9a67d3faea852e71e981ba5550b10e">addLoader</a> (<a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *loader)</td></tr>
<tr class="separator:aed9a67d3faea852e71e981ba5550b10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d868cc316b91af4b7ad52e07b0ebde0" id="r_a8d868cc316b91af4b7ad52e07b0ebde0"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8d868cc316b91af4b7ad52e07b0ebde0">addPathList</a> (<a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> *path_list)</td></tr>
<tr class="separator:a8d868cc316b91af4b7ad52e07b0ebde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d9c0144fcd50dd472f4a4aa01852e4" id="r_ab2d9c0144fcd50dd472f4a4aa01852e4"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab2d9c0144fcd50dd472f4a4aa01852e4">findFile</a> (const char *filename, <a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;foundPath)</td></tr>
<tr class="separator:ab2d9c0144fcd50dd472f4a4aa01852e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7feaa515d8d97a663bfe2e11d71d893" id="r_ad7feaa515d8d97a663bfe2e11d71d893"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad7feaa515d8d97a663bfe2e11d71d893">getLoader</a> ()</td></tr>
<tr class="separator:ad7feaa515d8d97a663bfe2e11d71d893"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:affbc1d90c399f996a0cf64dcbbcde711" id="r_affbc1d90c399f996a0cf64dcbbcde711"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#affbc1d90c399f996a0cf64dcbbcde711">TSLDrawingSurfaceBase</a> ()</td></tr>
<tr class="separator:affbc1d90c399f996a0cf64dcbbcde711"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a06d217cc978c3dd7d7838602a74b8041" id="r_a06d217cc978c3dd7d7838602a74b8041"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06d217cc978c3dd7d7838602a74b8041">m_classID</a></td></tr>
<tr class="separator:a06d217cc978c3dd7d7838602a74b8041"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6867615c69a56a04cf0d742233ffd4b2" name="a6867615c69a56a04cf0d742233ffd4b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6867615c69a56a04cf0d742233ffd4b2">&#9670;&#160;</a></span>~TSLDrawingSurfaceBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual TSLDrawingSurfaceBase::~TSLDrawingSurfaceBase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="affbc1d90c399f996a0cf64dcbbcde711" name="affbc1d90c399f996a0cf64dcbbcde711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affbc1d90c399f996a0cf64dcbbcde711">&#9670;&#160;</a></span>TSLDrawingSurfaceBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TSLDrawingSurfaceBase::TSLDrawingSurfaceBase </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adf2508e14060aa37e3f64d3d4daedb83" name="adf2508e14060aa37e3f64d3d4daedb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2508e14060aa37e3f64d3d4daedb83">&#9670;&#160;</a></span>addDataLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::addDataLayer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> *</td>          <td class="paramname"><span class="paramname"><em>data_layer_interface</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> to Drawing Surface.</p>
<p>Visual display of data in TMS is through a Drawing Surface. This method allows the user to add a Data Layer to the Drawing Surface. When a draw request is made to the Drawing Surface any (visible) Data Layer that is attached to it will be displayed in the window.</p>
<p>Calling addDataLayer may change the coordinate providing layer. The default coordinate providing layer is the last layer added that reports itself to be coordinate providing. You can also set a fixed coordinate providing layer by calling setCoordinateProvidingLayer.</p>
<p>Note: Data Layers may be added to more than one Drawing Surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_layer_interface</td><td>Actual data layer to be added to the Drawing Surface. The object must be constructed beforehand.</td></tr>
    <tr><td class="paramname">data_id</td><td>This is the user defined name of the data layer to be added to the Drawing Surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a58a5591424a0629788811bca54086242" name="a58a5591424a0629788811bca54086242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a5591424a0629788811bca54086242">&#9670;&#160;</a></span>addDuplicateLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurfaceBase::addDuplicateLayers </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If enabled, allow multiple data layers with the same name to be added to the drawing surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Pass true to allow the duplicate feature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a756782b5ecf3f00c22d8a20c40096453" name="a756782b5ecf3f00c22d8a20c40096453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a756782b5ecf3f00c22d8a20c40096453">&#9670;&#160;</a></span>addDynamicRenderer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::addDynamicRenderer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_dynamic_renderer.html">TSLDynamicRenderer</a> *</td>          <td class="paramname"><span class="paramname"><em>renderer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method adds a Dynamic Renderer to the drawing surface, or clears an existing one for a specific feature/layer combination.</p>
<p>There are 4 different ways of deciding if a Dynamic Renderer should be used to render a particular entity - in this order.</p>
<ol type="1">
<li>If featureID and layerName are specified, then entities in that data layer with that feature ID will trigger the Dynamic Renderer.</li>
<li>If featureID is -1, but a layerName is specified, then all entities in that data layer will trigger the Dynamic Renderer.</li>
<li>If featureID is specified, but layerName is NULL, then all entities of that feature ID will trigger the Dynamic Renderer.</li>
<li>If featureID is -1, and layerName is NULL, then all entities on the Drawing Surface will trigger the Dynamic Renderer.</li>
</ol>
<p>Any existing renderer for this featureID/layerName combination is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">renderer</td><td>Renderer to use. The Drawing Surface assumes ownership of it. If NULL, then this clears the feature/layer combination.</td></tr>
    <tr><td class="paramname">featureID</td><td>Feature ID of entities that trigger this renderer. -1 if featureID is not relevant in the decision. Default -1</td></tr>
    <tr><td class="paramname">layerName</td><td>Name of data layer that this renderer applies to. 0 if layer is not relevant in the decision. Default 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successfully added, false otherwise. </dd></dl>

</div>
</div>
<a id="ab28c609ffd861cc7e0f1de9a4e3ffff9" name="ab28c609ffd861cc7e0f1de9a4e3ffff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab28c609ffd861cc7e0f1de9a4e3ffff9">&#9670;&#160;</a></span>addFeatureRendering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::addFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adds feature rendering.</p>
<p>This method allows the user to add a new feature to the rendering list. If a rendering style for the feature name already exists, it will be cleared, otherwise a new style will be created.</p>
<p>When MapLink is rendering a feature, it first looks at whether the entity has an attribute set. If so, then it tries to apply that attribute set and render the entity. If not, then it uses the feature id of the entity to index into the rendering information loaded into the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. If there is no rendering information in the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>, then it defaults to the rendering information stored with the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>.</p>
<p>If an entity has no attribute set or feature id, then the parent is recursively queried for attribute set and feature code.</p>
<p>If neither an entity, nor any of its parents have attribute sets or feature id, then the entity will not be rendered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Feature class name to which the rendering style is applied.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success , false otherwise. </dd></dl>

</div>
</div>
<a id="aed9a67d3faea852e71e981ba5550b10e" name="aed9a67d3faea852e71e981ba5550b10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed9a67d3faea852e71e981ba5550b10e">&#9670;&#160;</a></span>addLoader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLDrawingSurfaceBase::addLoader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> *</td>          <td class="paramname"><span class="paramname"><em>loader</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The application can provide a file loader for drawing surfaces to use when loading data.</p>
<p>If addLoader has not been called when a loader is needed, the surface will create a FileLoaderBlocking.</p>
<p>If a loader is already instantiated, it will be replaced by the one provided.</p>
<p>Typically, addLoader would be called to add a <a class="el" href="class_t_s_l_file_loader_m_t.html">TSLFileLoaderMT</a> so that an application can load data in a background thread whilst continuing to respond to user input, or a <a class="el" href="class_t_s_l_file_loader_remote.html">TSLFileLoaderRemote</a> so that an application can load data from an internet server.</p>
<p>If addLoader is called, the surfaces take a reference to the loader but do not take ownership of it. The loader could be added to data layers as well as the surface. The application must ensure that the loader remains in existence while the surface has a reference to it, and the application must delete the loader when it is no longer needed.</p>
<p>But if the surface creates a <a class="el" href="class_t_s_l_file_loader_blocking.html">TSLFileLoaderBlocking</a> because no loader was added, the surface will own the loader and will delete it when necessary. In fact, all surfaces share a single static loader which is created when first needed and destroyed when no longer needed.</p>
<p>The loader is always used in synchronous mode.</p>
<p>The loader is shared between drawing surfaces. The adding of a loader is not thread safe. Either add the loader before starting any threads that use Drawing Surfaces or block the use of all Drawing Surfaces while adding a loader. This is only necessary if you are using Drawing Surfaces in separate threads.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">loader</td><td>the loader to add. Pass NULL to remove the loader from the Drawing Surfaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successful. </dd></dl>

</div>
</div>
<a id="a8d868cc316b91af4b7ad52e07b0ebde0" name="a8d868cc316b91af4b7ad52e07b0ebde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d868cc316b91af4b7ad52e07b0ebde0">&#9670;&#160;</a></span>addPathList()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLDrawingSurfaceBase::addPathList </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> *</td>          <td class="paramname"><span class="paramname"><em>path_list</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a <a class="el" href="class_t_s_l_path_list.html">TSLPathList</a> object to all surfaces. This will be used for finding files, for example in setupColours.</p>
<p>The pathlist is shared between drawing surfaces. The adding of a pathlist is not thread safe. Either add the pathlist before starting any threads that use Drawing Surfaces or block the use of all Drawing Surfaces while adding a pathlist. This is only necessary if you are using Drawing Surfaces in separate threads.</p>
<p>The pathlist object is only thread safe if it is not modified while in use.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path_list</td><td>the pathlist to add. Pass NULL to remove the pathlist from the drawing surfaces.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on a successful addition, false otherwise.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The class takes a copy of the pointer passed, so the pathlist must stay in existence so long as any surface exists. The class does not take ownership of the pathlist. </dd></dl>

</div>
</div>
<a id="ad695674703054f6dde4f8f472160ca82" name="ad695674703054f6dde4f8f472160ca82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad695674703054f6dde4f8f472160ca82">&#9670;&#160;</a></span>attach() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurfaceBase::attach </td>
          <td>(</td>
          <td class="paramtype">TSLDeviceContext</td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attaches a new Device Context (HDC) to the drawing surface.</p>
<p>The <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> will require update of window size after this call.</p>
<p>Note:</p>
<ol type="1">
<li>setDeviceCapabilities will need to be called if the device capabilities need to be adjusted.</li>
<li>This function is Microsoft specific.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>HDC to attach to the drawing surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab367bb38ef5a8e3ce9df1b17fe665fbd" name="ab367bb38ef5a8e3ce9df1b17fe665fbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab367bb38ef5a8e3ce9df1b17fe665fbd">&#9670;&#160;</a></span>attach() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurfaceBase::attach </td>
          <td>(</td>
          <td class="paramtype">TSLDrawableHandle</td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attaches a new Drawable to the drawing surface.</p>
<p>The <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> will require update of window size after this call.</p>
<p>Note:</p>
<ol type="1">
<li>setDeviceCapabilities will need to be called if the device capabilities need to be adjusted.</li>
<li>This function is X11 specific.</li>
<li>If the Display, Screen, Visual, Colormap are different the use the attach on the <a class="el" href="class_t_s_l_motif_surface.html">TSLMotifSurface</a> (X11 Drawing Surface).</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>Drawable to attach to the drawing surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac268beaaf3462b6d6a1845bebb3fb113" name="ac268beaaf3462b6d6a1845bebb3fb113"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac268beaaf3462b6d6a1845bebb3fb113">&#9670;&#160;</a></span>attach() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurfaceBase::attach </td>
          <td>(</td>
          <td class="paramtype">TSLWindowHandle</td>          <td class="paramname"><span class="paramname"><em>handle</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attaches a new Window handle (HWND) to the drawing surface.</p>
<p>The <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> will require update of window size after this call.</p>
<p>Note:</p>
<ol type="1">
<li>setDeviceCapabilities will need to be called if the device capabilities need to be adjusted.</li>
<li>This function is Microsoft specific.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>HWND to attach to the drawing surface. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5fa764a7e039e56f2489a1f62d238701" name="a5fa764a7e039e56f2489a1f62d238701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fa764a7e039e56f2489a1f62d238701">&#9670;&#160;</a></span>bringInFrontof()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::bringInFrontof </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>move_data_layer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>target_data_layer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move Data Layer in front of another Data Layer.</p>
<p>This method allows the display order of the attached <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> instances to be modified. The <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> identified by 'move_data_layer' is moved so that it is drawn immediately after the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> identified by 'target_ data_layer'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">move_data_layer</td><td>Name of a <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> instance attached to this <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. This is the 'data_id' parameter that was passed when the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> was added to the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</td></tr>
    <tr><td class="paramname">target_data_layer</td><td>Name of a <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> instance attached to this <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. This is the 'data_id' parameter that was passed when the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> was added to the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="aeccd258d58e99d15c4bcae1b4c1170f7" name="aeccd258d58e99d15c4bcae1b4c1170f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccd258d58e99d15c4bcae1b4c1170f7">&#9670;&#160;</a></span>bringToFront()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::bringToFront </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>move_data_layer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move Data Layer to top of Drawing Surface display list.</p>
<p>This method allows the display order of the attached <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> instances to be modified. The specified <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> instance will be drawn on top of all other <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> instances attached to this <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">move_data_layer</td><td>Name of a <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>. This is the 'data_id' parameter that was passed when the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> was added to the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a171387fcf2304549fffe4982562ca4c2" name="a171387fcf2304549fffe4982562ca4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a171387fcf2304549fffe4982562ca4c2">&#9670;&#160;</a></span>clearAllDeclutterData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::clearAllDeclutterData </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layer_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears all feature decluttering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer_name</td><td>Name of the layer to clear the decluttering on. If this is NULL, feature decluttering is cleared from all layers in the drawing surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a55bdcd971140c6640265b2acc4457eb5" name="a55bdcd971140c6640265b2acc4457eb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55bdcd971140c6640265b2acc4457eb5">&#9670;&#160;</a></span>clearAllDynamicRenderers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurfaceBase::clearAllDynamicRenderers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears (and destroys) all dynamic renderers that have been added to the drawing surface. This includes any dynamic renderers that are associated with a specific data layer in the surface.</p>
<p>If the same data layer is shared between multiple drawing surfaces in separate threads and has a dynamic render associated with it, care should be taken when calling this method to ensure that the common data layer is not being drawn or otherwise used by the other threads. </p>

</div>
</div>
<a id="afdabfe424ab268061573eafed87ffb04" name="afdabfe424ab268061573eafed87ffb04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdabfe424ab268061573eafed87ffb04">&#9670;&#160;</a></span>clearBackgroundColour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::clearBackgroundColour </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clears the background colour of the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</p>
<p>If the background colour is cleared and a draw request is made which specifies the clear flag, then under Windows, the Drawing Surface will clear the area using a white brush; under X the Drawing Surface will clear the area of (i) a window using the 'background_pixel' / 'background_pixmap' attributes or (ii) a pixmap using WhitePixel of the display.</p>
<p>Returns true on success, false otherwise. </p>

</div>
</div>
<a id="a59e94baf9c65b8079c543b7945365d07" name="a59e94baf9c65b8079c543b7945365d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59e94baf9c65b8079c543b7945365d07">&#9670;&#160;</a></span>clearDeclutterData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::clearDeclutterData </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>feature_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layer_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear feature decluttering.</p>
<p>This method removes the declutter data for the named feature. If there is no declutter data for a given feature the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> will not check for visibility when that feature is encountered, therefore this feature is always visible.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature_name</td><td>Name of the feature for which to clear the declutter settings</td></tr>
    <tr><td class="paramname">layer_name</td><td>Name of the layer to clear the decluttering on. If this is NULL, the declutter settings for the feature will be cleared from all layers in the drawing surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="af7373de95bfb938c2226e8f294280a3a" name="af7373de95bfb938c2226e8f294280a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7373de95bfb938c2226e8f294280a3a">&#9670;&#160;</a></span>clearDynamicRenderer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::clearDynamicRenderer </td>
          <td>(</td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method clears (and destroys) a Dynamic Renderer from the drawing surface.</p>
<p>There are 4 different ways of deciding if a Dynamic Renderer should be used to render a particular entity - in this order.</p>
<ol type="1">
<li>If featureID and layerName are specified, then entities in that data layer with that feature ID will trigger the Dynamic Renderer.</li>
<li>If featureID is -1, but a layerName is specified, then all entities in that data layer will trigger the Dynamic Renderer.</li>
<li>If featureID is specified, but layerName is NULL, then all entities of that feature ID will trigger the Dynamic Renderer.</li>
<li>If featureID is -1, and layerName is NULL, then all entities on the Drawing Surface will trigger the Dynamic Renderer.</li>
</ol>
<p>Any existing renderer for this featureID/layerName combination is destroyed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureID</td><td>Feature ID of entities that trigger this renderer. -1 if featureID is not relevant in the decision. Default -1</td></tr>
    <tr><td class="paramname">layerName</td><td>Name of data layer that this renderer applies to. 0 if layer is not relevant in the decision. Default 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if successfully cleared, false otherwise. </dd></dl>

</div>
</div>
<a id="a25a6a56d2729aa0a1fafe37b6aa04f52" name="a25a6a56d2729aa0a1fafe37b6aa04f52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a6a56d2729aa0a1fafe37b6aa04f52">&#9670;&#160;</a></span>clearFeatureRendering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::clearFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear feature rendering.</p>
<p>This method removes the rendering style information that has been previously set for a given feature, by one of the 'setRendering' methods.</p>
<p>When MapLink is rendering a feature, it first looks at whether the entity has an attribute set. If so, then it tries to apply that attribute set and render the entity. If not, then it uses the feature id of the entity to index into the rendering information loaded into the drawing surface. If there is no rendering information in the drawing surface, then it defaults to the rendering information stored with the map.</p>
<p>If an entity has no attribute set or feature id, then the parent is recursively queried for attribute set and feature code.</p>
<p>If neither an entity, nor any of its parents have attribute sets or feature id, then the entity will not be rendered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Feature class name from which the rendering style information is removed. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a7b812d3c132366b9f20b92110c8dad6f" name="a7b812d3c132366b9f20b92110c8dad6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b812d3c132366b9f20b92110c8dad6f">&#9670;&#160;</a></span>clearFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::clearFrame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Inhibit frame from being drawn around <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</p>
<p>Returns true on success, false otherwise. </p>

</div>
</div>
<a id="a8ca53495ddd20981f1ff20b3f4972b17" name="a8ca53495ddd20981f1ff20b3f4972b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca53495ddd20981f1ff20b3f4972b17">&#9670;&#160;</a></span>cloneDynamicRenderersFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::cloneDynamicRenderersFrom </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a> *</td>          <td class="paramname"><span class="paramname"><em>otherSurface</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3e62109d1d6673dc37cbb79f0d13cef" name="ab3e62109d1d6673dc37cbb79f0d13cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e62109d1d6673dc37cbb79f0d13cef">&#9670;&#160;</a></span>copyDeclutterData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::copyDeclutterData </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src_feature_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dest_feature_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>src_layer_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dest_layer_name</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy feature decluttering.</p>
<p>This method copies the declutter information for one named feature to another named feature.</p>
<p>If no declutter data for the source feature exists then the declutter information for the destination feature will be cleared as if clearDeclutterData was called for that feature.</p>
<p>Any existing declutter data for the destination feature will be overwritten.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src_feature_name</td><td>Name of the source feature.</td></tr>
    <tr><td class="paramname">dest_feature_name</td><td>Name of the destination feature.</td></tr>
    <tr><td class="paramname">src_layer_name</td><td>Name of the source layer from which to read the declutter data for the source feature. If this is NULL, the declutter data for the source feature is read from the global declutter settings.</td></tr>
    <tr><td class="paramname">dest_layer_name</td><td>Name of the destination layer for which to set the declutter data for the destination feature. If this is NULL, the declutter data for the destination feature is set on all data layers in the drawing surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a27b35a14f96de605f73191cbb04b86cf" name="a27b35a14f96de605f73191cbb04b86cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b35a14f96de605f73191cbb04b86cf">&#9670;&#160;</a></span>detach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurfaceBase::detach </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Detach HDC/Pixmap/window from <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</p>
<p>The user is responsible for the management of the detached HDC/Pixmap/window.</p>
<p>NB. The <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> is made invalid until a valid HDC/Pixmap/window is re-attached. </p>

</div>
</div>
<a id="aa6f3ab638243f6016c21bdffb6f28a44" name="aa6f3ab638243f6016c21bdffb6f28a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f3ab638243f6016c21bdffb6f28a44">&#9670;&#160;</a></span>detachAllDynamicRenderers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurfaceBase::detachAllDynamicRenderers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method removes all dynamic renderers that have been added to the drawing surface, but does not destroy them. This includes any dynamic renderers that are associated with a specific data layer in the surface. The application is responsible for ensuring any dynamic renderers that were added to the drawing surface are destroyed.</p>
<p>If the same data layer is shared between multiple drawing surfaces in separate threads and has a dynamic render associated with it, care should be taken when calling this method to ensure that the common data layer is not being drawn or otherwise used by the other threads. </p>

</div>
</div>
<a id="a0fc62268d7293cc9fac136200e6aed62" name="a0fc62268d7293cc9fac136200e6aed62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc62268d7293cc9fac136200e6aed62">&#9670;&#160;</a></span>detachDynamicRenderer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::detachDynamicRenderer </td>
          <td>(</td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method removes a Dynamic Renderer from the drawing surface but does not destroy it. The application is responsible for ensuring that the dynamic renderer is deleted.</p>
<p>There are 4 different ways of deciding if a Dynamic Renderer should be used to render a particular entity - in this order.</p>
<ol type="1">
<li>If featureID and layerName are specified, then the dynamic renderer associated with entities in that data layer with that feature ID will be detached.</li>
<li>If featureID is -1, but a layerName is specified, then the Dynamic Renderer associated with that data layer will be detached.</li>
<li>If featureID is specified, but layerName is NULL, then the Dynamic Renderer associated with all entities of that feature ID will be detached.</li>
<li>If featureID is -1, and layerName is NULL, then the drawing surface's global Dynamic Renderer will be detached.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureID</td><td>Feature ID of entities that trigger this renderer. -1 if featureID is not relevant in the decision. Default -1</td></tr>
    <tr><td class="paramname">layerName</td><td>Name of data layer that this renderer applies to. 0 if layer is not relevant in the decision. Default 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a Dynamic Renderer was detached from the drawing surface, false otherwise. </dd></dl>

</div>
</div>
<a id="a0da02a3dca66e350f188cc66d49b95d5" name="a0da02a3dca66e350f188cc66d49b95d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0da02a3dca66e350f188cc66d49b95d5">&#9670;&#160;</a></span>featureClass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * TSLDrawingSurfaceBase::featureClass </td>
          <td>(</td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>feature_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert numeric feature id to feature class name.</p>
<p>The last map data layer added to the drawing surface is searched to provide the mapping between id and class name.</p>
<p>Returns feature class name associated with the given feature id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature_id</td><td>Feature id being queried. The feature id may be queried from a <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the feature name as a string or NULL if the feature could not be found. </dd></dl>

</div>
</div>
<a id="ab2d9c0144fcd50dd472f4a4aa01852e4" name="ab2d9c0144fcd50dd472f4a4aa01852e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d9c0144fcd50dd472f4a4aa01852e4">&#9670;&#160;</a></span>findFile()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool TSLDrawingSurfaceBase::findFile </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_simple_string.html">TSLSimpleString</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>foundPath</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Uses the drawing surface's external and internal pathlists (i.e. that added by calling addPathList, and that created by calling loadStandardConfig, respectively) to search for a file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to search for.</td></tr>
    <tr><td class="paramname">foundPath</td><td>This will be populated with the location that the file is found at.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the full path is found, false otherwise. </dd></dl>

</div>
</div>
<a id="a5f617343c50c8f907c05a895adc0f710" name="a5f617343c50c8f907c05a895adc0f710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f617343c50c8f907c05a895adc0f710">&#9670;&#160;</a></span>forceLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::forceLayer </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>detail_layer_name</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Force map layer to display specific detail layer.</p>
<p>This method forces the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> to use a specific layer for display purposes, rather than the layer automatically chosen by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_id</td><td>Name of the <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> when added to the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</td></tr>
    <tr><td class="paramname">detail_layer_name</td><td>Detail layer name, as specified in the MapLink Processing Tool.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="aef3f571b473fae1be0e3fda757f8a84a" name="aef3f571b473fae1be0e3fda757f8a84a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3f571b473fae1be0e3fda757f8a84a">&#9670;&#160;</a></span>getBackgroundColour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::getBackgroundColour </td>
          <td>(</td>
          <td class="paramtype">TSLStyleID *</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the colour index for background colour.</p>
<p>This method returns the colour index of the background colour that <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> uses to clear the background area with before the MapLink map data is drawn.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Storage for Index into the current colour palette used by the application. If the index is '-1' then there is not current background colour.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="aff44ab7558d9044846c390b9c69b43c7" name="aff44ab7558d9044846c390b9c69b43c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff44ab7558d9044846c390b9c69b43c7">&#9670;&#160;</a></span>getColourValue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::getColourValue </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>colour</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char &amp;</td>          <td class="paramname"><span class="paramname"><em>g</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the RGB value that corresponds to the given colour index according to the current drawing surface's palette.</p>
<p>If the given colour is an RGB colour and not a colour index, this function is equivalent to using the TSLDecomposeRGB macro. </p>

</div>
</div>
<a id="a008b6ccaa73f5e7dedf2c09cc7feeb64" name="a008b6ccaa73f5e7dedf2c09cc7feeb64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a008b6ccaa73f5e7dedf2c09cc7feeb64">&#9670;&#160;</a></span>getDataLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> * TSLDrawingSurfaceBase::getDataLayer </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> from Drawing Surface.</p>
<p>This method allows the user to query a Data Layer from the Drawing Surface.</p>
<p>Note: Data Layers may be added to more than one Drawing Surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_id</td><td>This is the user defined name of the Data Layer to be queried from the Drawing Surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> of the specified name, NULL on error. </dd></dl>

</div>
</div>
<a id="a630ab91eba6e19889be3e4bb041cf023" name="a630ab91eba6e19889be3e4bb041cf023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630ab91eba6e19889be3e4bb041cf023">&#9670;&#160;</a></span>getDataLayerInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::getDataLayerInfo </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>N</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> **</td>          <td class="paramname"><span class="paramname"><em>dataLayer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query information about a Data Layer.</p>
<p>This method allows the user to get the name &amp; pointer to the Nth <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">N</td><td>the index to the Data Layer.</td></tr>
    <tr><td class="paramname">dataLayer</td><td>a pointer to the Nth Data Layer.</td></tr>
    <tr><td class="paramname">layerName</td><td>the name of the Nth Data Layer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a319f8ac2a9cd7254e95120afe0c1ecfa" name="a319f8ac2a9cd7254e95120afe0c1ecfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319f8ac2a9cd7254e95120afe0c1ecfa">&#9670;&#160;</a></span>getDataLayerProps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::getDataLayerProps </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga1c467581ddf31341ac6acf6baa297a9a">TSLPropertyEnum</a></td>          <td class="paramname"><span class="paramname"><em>property_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLPropertyValue *</td>          <td class="paramname"><span class="paramname"><em>old_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query properties and flags for Data Layer.</p>
<p>This method allows the user to get the current property value for the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>.</p>
<p>Default values for the properties are documented in <a class="el" href="group__apigroup__api.html#ga1c467581ddf31341ac6acf6baa297a9a">TSLPropertyEnum</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_id</td><td>User defined name of a <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>. This is the 'data_id' parameter that was passed when the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> was added to the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</td></tr>
    <tr><td class="paramname">property_id</td><td>Property to get.</td></tr>
    <tr><td class="paramname">old_value</td><td>Storage for value of this property.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="ad2d9532d2f61896824476e912db4efff" name="ad2d9532d2f61896824476e912db4efff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d9532d2f61896824476e912db4efff">&#9670;&#160;</a></span>getDeclutterStatus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::getDeclutterStatus </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>feature_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#gadd64c2d584f0cab2498c784c9451d85e">TSLDeclutterStatusResultEnum</a> *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dataLayerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>detailLayerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries feature decluttering settings for a given feature.</p>
<p>This method gets the visibility status of a feature within the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. The visibility for a feature is either always ON, always OFF, or automatically set by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> based on the current resolution.</p>
<p>Passing a partial feature class name gets the visibility setting for the set of all subclasses. For example, getting "VMAP0.Contour Line (Land)" will return a value of ON if all contour lines are on, OFF if all contour lines are off, AUTOMATIC if all contour lines are automatically decluttered or PARTIAL if the contour lines have a mixture of statuses.</p>
<p>Applications should generally always pass a layer name to this method, as the declutter status of a given feature may be different for each layer that contains that feature.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature_name</td><td>Name of the feature type to get the status from.</td></tr>
    <tr><td class="paramname">value</td><td>Storage for current status.</td></tr>
    <tr><td class="paramname">dataLayerName</td><td>The data layer to get the decluttering for. If this is NULL the declutter status is read from the global declutter list, which may differ from the declutter status of the layers in the drawing surface.</td></tr>
    <tr><td class="paramname">detailLayerName</td><td>The detail layer to get the decluttering for - default to 0 to get the decluttering for all detail layers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="ae61d832cd81e2c7a0ea2fa9744aec16a" name="ae61d832cd81e2c7a0ea2fa9744aec16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61d832cd81e2c7a0ea2fa9744aec16a">&#9670;&#160;</a></span>getDeclutterStatus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::getDeclutterStatus </td>
          <td>(</td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>feature_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#gadd64c2d584f0cab2498c784c9451d85e">TSLDeclutterStatusResultEnum</a> *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dataLayerName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>detailLayerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries feature decluttering settings for a given feature by its identifier.</p>
<p>This method gets the visibility status of a feature within the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. The visibility for a feature is either always ON, always OFF, or automatically set by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> based on the current resolution.</p>
<p>When getting the status of a singular feature on a data layer and the feature ID is known then this method is more efficient than the alternative getDeclutterStatus that takes the feature name rather than the feature ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature_id</td><td>ID of the feature type to get the status from.</td></tr>
    <tr><td class="paramname">value</td><td>Storage for current status.</td></tr>
    <tr><td class="paramname">dataLayerName</td><td>The data layer to get the decluttering for. This cannot be NULL.</td></tr>
    <tr><td class="paramname">detailLayerName</td><td>the detail layer to get the decluttering for - default to 0 to get the decluttering for all detail layers</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a0d31320e6500e887e85cc4a95e19c198" name="a0d31320e6500e887e85cc4a95e19c198"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d31320e6500e887e85cc4a95e19c198">&#9670;&#160;</a></span>getDynamicRenderer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_dynamic_renderer.html">TSLDynamicRenderer</a> * TSLDrawingSurfaceBase::getDynamicRenderer </td>
          <td>(</td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method gets a Dynamic Renderer from the drawing surface</p>
<p>There are 4 different ways of deciding if a Dynamic Renderer should be used to render a particular entity - in this order.</p>
<ol type="1">
<li>If featureID and layerName are specified, then entities in that data layer with that feature ID will trigger the Dynamic Renderer.</li>
<li>If featureID is -1, but a layerName is specified, then all entities in that data layer will trigger the Dynamic Renderer.</li>
<li>If featureID is specified, but layerName is NULL, then all entities of that feature ID will trigger the Dynamic Renderer.</li>
<li>If featureID is -1, and layerName is NULL, then all entities on the Drawing Surface will trigger the Dynamic Renderer.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureID</td><td>Feature ID of entities that trigger this renderer. -1 if featureID is not relevant in the decision. Default -1</td></tr>
    <tr><td class="paramname">layerName</td><td>Name of data layer that this renderer applies to. 0 if layer is not relevant in the decision. Default 0</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>renderer for the specified parameters, 0 if no such renderer is associated with this drawing surface. The drawing surface still maintains ownership of the renderer. </dd></dl>

</div>
</div>
<a id="a0b4248cc44247ca3696199db1b2913b5" name="a0b4248cc44247ca3696199db1b2913b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4248cc44247ca3696199db1b2913b5">&#9670;&#160;</a></span>getFeatureRendering() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::getFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a></td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets rendering for a specified feature class.</p>
<p>For further information about what attributes are available, see the setRendering methods on <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</p>
<p>If a name is specified, then all data layers attached to the drawing surface are searched to provide a mapping to ID. They are searched in rendering order from back to front.</p>
<p>Where possible, it is more efficient for an application to use the featureID directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">attribute</td><td>Type of rendering attribute to get</td></tr>
    <tr><td class="paramname">result</td><td>Storage for returned rendering attribute value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attribute successfully read and stored in result, false otherwise. </dd></dl>

</div>
</div>
<a id="a8c4df913acb00ac825e165e5c71fdf73" name="a8c4df913acb00ac825e165e5c71fdf73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4df913acb00ac825e165e5c71fdf73">&#9670;&#160;</a></span>getFeatureRendering() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::getFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a></td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets rendering for a specified feature class.</p>
<p>For further information about what attributes are available, see the setRendering methods on <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</p>
<p>If a name is specified, then all data layers attached to the drawing surface are searched to provide a mapping to ID. They are searched in rendering order from back to front.</p>
<p>Where possible, it is more efficient for an application to use the featureID directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">attribute</td><td>Type of rendering attribute to get</td></tr>
    <tr><td class="paramname">result</td><td>Storage for returned rendering attribute value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attribute successfully read and stored in result, false otherwise. </dd></dl>

</div>
</div>
<a id="a80b26948542c04c89ed561e953ba0e3a" name="a80b26948542c04c89ed561e953ba0e3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80b26948542c04c89ed561e953ba0e3a">&#9670;&#160;</a></span>getFeatureRendering() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::getFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a></td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets rendering for a specified feature class.</p>
<p>For further information about what attributes are available, see the setRendering methods on <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</p>
<p>If a name is specified, then all data layers attached to the drawing surface are searched to provide a mapping to ID. They are searched in rendering order from back to front.</p>
<p>Where possible, it is more efficient for an application to use the featureID directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">attribute</td><td>Type of rendering attribute to get</td></tr>
    <tr><td class="paramname">result</td><td>Storage for returned rendering attribute value</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attribute successfully read and stored in result, false otherwise. </dd></dl>

</div>
</div>
<a id="a13420230fd95cafe4f7829a49ffa2b07" name="a13420230fd95cafe4f7829a49ffa2b07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13420230fd95cafe4f7829a49ffa2b07">&#9670;&#160;</a></span>getFeatureRendering() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::getFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *</td>          <td class="paramname"><span class="paramname"><em>result</em></span>&#160;) const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets rendering for a specified feature class.</p>
<p>If a name is specified, then all data layers attached to the drawing surface are searched to provide a mapping to ID. They are searched in rendering order from back to front.</p>
<p>Where possible, it is more efficient for an application to use the featureID directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">result</td><td>Storage for returned rendering attribute values</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attributes successfully read and stored in result, false otherwise. </dd></dl>

</div>
</div>
<a id="ad7feaa515d8d97a663bfe2e11d71d893" name="ad7feaa515d8d97a663bfe2e11d71d893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7feaa515d8d97a663bfe2e11d71d893">&#9670;&#160;</a></span>getLoader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="class_t_s_l_file_loader.html">TSLFileLoader</a> * TSLDrawingSurfaceBase::getLoader </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns either the loader added by addLoader or the default static loader. If no static loader exists it is created. </p>

</div>
</div>
<a id="acef0f78c36be8c30078671de5f56e2a1" name="acef0f78c36be8c30078671de5f56e2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acef0f78c36be8c30078671de5f56e2a1">&#9670;&#160;</a></span>getNumDataLayers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLDrawingSurfaceBase::getNumDataLayers </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of Data Layers attached to this Drawing Surface. </p>

</div>
</div>
<a id="a0a03a127eeee2f9c9a8fed466a7e5edd" name="a0a03a127eeee2f9c9a8fed466a7e5edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a03a127eeee2f9c9a8fed466a7e5edd">&#9670;&#160;</a></span>getOption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::getOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga28a256688c01415721a7700d84fa55bd">TSLOptionEnum</a></td>          <td class="paramname"><span class="paramname"><em>option</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query option flag.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>Enumeration value specifying option to query</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the specified options flag for the behaviour of the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. </dd></dl>

</div>
</div>
<a id="a41229ebf8a2a4e0e1639616d7a8efffd" name="a41229ebf8a2a4e0e1639616d7a8efffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41229ebf8a2a4e0e1639616d7a8efffd">&#9670;&#160;</a></span>id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TSLDrawingSurfaceBase::id </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the user drawing surface ID. If no ID has been set, a number less than 0 that uniquely identifies the drawing surface will be returned instead. </p>

</div>
</div>
<a id="a07a0fb6b5f0ac7270b4f321822897192" name="a07a0fb6b5f0ac7270b4f321822897192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a0fb6b5f0ac7270b4f321822897192">&#9670;&#160;</a></span>id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurfaceBase::id </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>id_</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the user drawing surface ID. Negative values are reserved.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">id_</td><td>the user drawing surface ID to be set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a18fb9812a2e699c06d1aa787787f9ad6" name="a18fb9812a2e699c06d1aa787787f9ad6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18fb9812a2e699c06d1aa787787f9ad6">&#9670;&#160;</a></span>idleProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::idleProcess </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform idle processing.</p>
<p>This method should be called by the client application when it is idle to allow MapLink to carry out low priority tasks.</p>
<p>Returns true if MapLink needs more idle time, false if all idle processing is complete. </p>

</div>
</div>
<a id="a5f8e4094017e7699433efa30fdbbde9b" name="a5f8e4094017e7699433efa30fdbbde9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8e4094017e7699433efa30fdbbde9b">&#9670;&#160;</a></span>loadDeclutter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::loadDeclutter </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load feature decluttering file.</p>
<p>This method allows the user to load a set of declutter data from a given file. Each <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> may, optionally, declutter features differently from another <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</p>
<p>If addPathList or loadStandardConfig has been called then the pathlist is used to search for the file in suitable directories (using keying), if not then the system Path and the environment variable MAPLINK_PATH are used to search for the file, or alternatively the filename may be fully qualified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Declutter file name.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was found and loaded successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="a337cadfa02f94128a8f90a82083292fa" name="a337cadfa02f94128a8f90a82083292fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337cadfa02f94128a8f90a82083292fa">&#9670;&#160;</a></span>loadRendering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::loadRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load feature rendering file.</p>
<p>This method allows the user to load a set of rendering data from a given file. Each <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> may, optionally, render data types in different ways from another <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</p>
<p>If addPathList or loadStandardConfig has been called then the pathlist is used to search for the file in suitable directories (using keying), if not then the system Path and the environment variable MAPLINK_PATH are used to search for the file, or alternatively the filename may be fully qualified.</p>
<p>When MapLink is rendering a feature, it first looks at whether the entity has an attribute set. If so, then it tries to apply that attribute set and render the entity. If not, then it uses the feature id of the entity to index into the rendering information loaded into the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. If there is no rendering information in the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>, then it defaults to the rendering information stored with the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>.</p>
<p>If an entity has neither attribute set nor feature id, then the parent is recursively queried for attribute set and feature code.</p>
<p>If neither an entity, nor any of its parents have attribute sets or feature id, then the entity will not be rendered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the rendering data file.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if file successfully loaded, false otherwise. </dd></dl>

</div>
</div>
<a id="ad0ab561be1f46b9cc34cdd5d9fc42664" name="ad0ab561be1f46b9cc34cdd5d9fc42664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ab561be1f46b9cc34cdd5d9fc42664">&#9670;&#160;</a></span>pick() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_pick_result_set.html">TSLPickResultSet</a> * TSLDrawingSurfaceBase::pick </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>aperture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span><span class="paramdefsep"> = </span><span class="paramdefval">-1</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_pick_selector.html">TSLPickSelector</a> *</td>          <td class="paramname"><span class="paramname"><em>selector</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pick objects from a data layer from specified pixel location.</p>
<p>The detail layers used are the layer for the current drawing surface extent.</p>
<p>This method the specified layer to return a set of <a class="el" href="class_t_s_l_pick_result.html">TSLPickResult</a> objects which allows the user to determine what objects are contained within the specified pick area.</p>
<p>The <a class="el" href="class_t_s_l_pick_result_set.html">TSLPickResultSet</a> for a <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> is only valid for immediate use since the data tiles to which they refer may be removed from memory if the cache is flushed.</p>
<p>In the default case, all tiles whose extent intersects the specified extent will be returned. These will include all entities within those tiles, even though some individual entities may not be within the extent.</p>
<p>Alternatively, if a depth is specified, then the query recurses into the tiles and returns only those individual entities that whose extents intersect the region. An optional feature name may also be specified.</p>
<p>NOTE:</p><ul>
<li>When querying an Optimised map the query may return objects that can not be further analysed.</li>
<li>3D picking does not maintain the geometry hierarchy due to the way picking has been implemented.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_id</td><td>ID of the datalayer to pick from.</td></tr>
    <tr><td class="paramname">(x,y)</td><td>The location in pixels of the area to pick.</td></tr>
    <tr><td class="paramname">aperture</td><td>The size in pixels of the area to pick.</td></tr>
    <tr><td class="paramname">depth</td><td>Specifies how deep to look before returning a pointer to an object. If the depth is -1 (the default), individual entities are returned. If the depth is 0 it searches at the highest level in the tile (that is it may return a Group rather than an entity within the Group).</td></tr>
    <tr><td class="paramname">selector</td><td>Optional class derived from <a class="el" href="class_t_s_l_pick_selector.html">TSLPickSelector</a> that can be used to further filter the results based on user criteria.</td></tr>
  </table>
  </dd>
</dl>
<p>The return value is a <a class="el" href="class_t_s_l_pick_result_set.html">TSLPickResultSet</a> that contains the picked results. This object must be destroyed when finished with. </p>

</div>
</div>
<a id="ac4585d14f142c6517ddbe21c72cca8f7" name="ac4585d14f142c6517ddbe21c72cca8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4585d14f142c6517ddbe21c72cca8f7">&#9670;&#160;</a></span>pick() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_t_s_l_pick_result_set.html">TSLPickResultSet</a> * TSLDrawingSurfaceBase::pick </td>
          <td>(</td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>y</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLDeviceUnits</td>          <td class="paramname"><span class="paramname"><em>aperture</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>depth</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_pick_selector.html">TSLPickSelector</a> *</td>          <td class="paramname"><span class="paramname"><em>selector</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pick objects from datalayers from specified pixel location.</p>
<p>The detail layers used are the layer for the current drawing surface extent.</p>
<p>This method requests all layers to return a set of <a class="el" href="class_t_s_l_pick_result.html">TSLPickResult</a> objects which allows the user to determine what objects are contained within the specified pick area.</p>
<p>The <a class="el" href="class_t_s_l_pick_result_set.html">TSLPickResultSet</a> for a <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> is only valid for immediate use since the data tiles to which they refer may be removed from memory if the cache is flushed.</p>
<p>In the default case, all tiles whose extent intersects the specified extent will be returned. These will include all entities within those tiles, even though some individual entities may not be within the extent.</p>
<p>Alternatively, if a depth is specified, then the query recurses into the tiles and returns only those individual entities that whose extents intersect the region. An optional feature name may also be specified.</p>
<p>NOTE:</p><ul>
<li>When querying an Optimised map the query may return objects that can not be further analysed.</li>
<li>3D picking does not maintain the geometry hierarchy due to the way picking has been implemented.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">(x,y)</td><td>The location in pixels of the area to pick.</td></tr>
    <tr><td class="paramname">aperture</td><td>The size in pixels of the area to pick.</td></tr>
    <tr><td class="paramname">depth</td><td>Specifies how deep to look before returning a pointer to an object. If the depth is -1 (the default), individual entities are returned. If the depth is 0 it searches at the highest level in the tile (that is it may return a Group rather than an entity within the Group).</td></tr>
    <tr><td class="paramname">selector</td><td>Optional class derived from <a class="el" href="class_t_s_l_pick_selector.html">TSLPickSelector</a> that can be used to further filter the results based on user criteria.</td></tr>
  </table>
  </dd>
</dl>
<p>The return value is a <a class="el" href="class_t_s_l_pick_result_set.html">TSLPickResultSet</a> that contains the picked results. This object must be destroyed when finished with. </p>

</div>
</div>
<a id="a4b56d4ff2cebea8e1606d4554d9c18c4" name="a4b56d4ff2cebea8e1606d4554d9c18c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b56d4ff2cebea8e1606d4554d9c18c4">&#9670;&#160;</a></span>queryActiveLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::queryActiveLayer </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>detail_layer_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>detail_layer_name_size</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query active detail layer from map data layer.</p>
<p>This method gets the name of the current detail layer used by the specified <a class="el" href="class_t_s_l_map_data_layer.html">TSLMapDataLayer</a> on the drawing surface. The name is copied into the supplied buffer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_id</td><td>This is the user defined name of the data layer when it was added to the Drawing Surface, ie. passed to 'addDataLayer'.</td></tr>
    <tr><td class="paramname">detail_layer_name</td><td>Layer name output buffer.</td></tr>
    <tr><td class="paramname">detail_layer_name_size</td><td>Size of the buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a035ee62299073d81104620eb96ee8d58" name="a035ee62299073d81104620eb96ee8d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a035ee62299073d81104620eb96ee8d58">&#9670;&#160;</a></span>removeDataLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::removeDataLayer </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes the named Data Layer from the Drawing Surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_id</td><td>User defined name of the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> object instance to be removed from the Drawing Surface.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the data layer has been removed successfully, false otherwise. </dd></dl>

</div>
</div>
<a id="a82dda3044708be3978cb05fb57bf23b4" name="a82dda3044708be3978cb05fb57bf23b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dda3044708be3978cb05fb57bf23b4">&#9670;&#160;</a></span>saveDeclutter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::saveDeclutter </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a></td>          <td class="paramname"><span class="paramname"><em>ver</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__apigroup__common.html#gga8141b1e165228e088c49024076e13758a0ecdea6c91f1d3104d6166d69b57c88d">TSL_CURRENT_MAPLINK_VERSION</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save feature decluttering file.</p>
<p>This method allows any declutter data that the user has set for a <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> to be saved to the specified file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Declutter file name.</td></tr>
    <tr><td class="paramname">ver</td><td>the MapLink version to save as</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the file was successfully saved, false otherwise. </dd></dl>

</div>
</div>
<a id="a4b70a8a01f666ecd5fa6ebe04feed246" name="a4b70a8a01f666ecd5fa6ebe04feed246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b70a8a01f666ecd5fa6ebe04feed246">&#9670;&#160;</a></span>saveRendering()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::saveRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>filename</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__common.html#ga8141b1e165228e088c49024076e13758">TSLMapLinkVersion</a></td>          <td class="paramname"><span class="paramname"><em>ver</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="group__apigroup__common.html#gga8141b1e165228e088c49024076e13758a0ecdea6c91f1d3104d6166d69b57c88d">TSL_CURRENT_MAPLINK_VERSION</a></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save rendering file.</p>
<p>This method allows any rendering information that the user has set up for a <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> to be saved to the specified file.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>Name of the rendering data file.</td></tr>
    <tr><td class="paramname">ver</td><td>the MapLink version to save as</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success , false otherwise. </dd></dl>

</div>
</div>
<a id="a12641ebccfa6b934b66b47dacf0d6e4f" name="a12641ebccfa6b934b66b47dacf0d6e4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12641ebccfa6b934b66b47dacf0d6e4f">&#9670;&#160;</a></span>sendToBack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::sendToBack </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>move_data_layer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move Data Layer to bottom of Drawing Surface display list.</p>
<p>This method allows the specified <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> to be placed behind all other attached <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> instances attached to this <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">move_data_layer</td><td>Name of a <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> instance. This is the 'data_id' parameter that was passed when the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> was added to the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a4862277014463d564f9b3a64bb1f32e9" name="a4862277014463d564f9b3a64bb1f32e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4862277014463d564f9b3a64bb1f32e9">&#9670;&#160;</a></span>sendToBackOf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::sendToBackOf </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>move_data_layer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>target_data_layer</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move Data Layer behind another Data Layer.</p>
<p>This method allows the display order of the attached TSLDatalayer instances to be modified. The <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> object 'move_data_layer' is moved immediately behind the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> object 'target_data_layer'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">move_data_layer</td><td>Name of a <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> instance. This is the 'data_id' parameter that was passed when the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> was added to the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</td></tr>
    <tr><td class="paramname">target_data_layer</td><td>Name of a <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> instance. This is the 'data_id' parameter that was passed when the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> was added to the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a17e4919227d150a0aa99fc135ea032ee" name="a17e4919227d150a0aa99fc135ea032ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e4919227d150a0aa99fc135ea032ee">&#9670;&#160;</a></span>setBackgroundColour()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::setBackgroundColour </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set colour index for background colour.</p>
<p>This method sets the colour to be used by the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> when drawing a background area before the MapLink map data is drawn.</p>
<p>The default for the background colour is either the map background colour (should there be one) or else see the documentation for clearBackgroundColour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Index into the current colour palette used by the application.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a0b6f63130d3fbb377eec5c56d2d68cea" name="a0b6f63130d3fbb377eec5c56d2d68cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b6f63130d3fbb377eec5c56d2d68cea">&#9670;&#160;</a></span>setCoordinateProvidingLayer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::setCoordinateProvidingLayer </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>layer_name</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the current coordinate providing layer to the one specified.</p>
<p>Once this method has been called with a valid layer name the coordinate providing layer will be fixed until the method is called again or the layer is removed from the drawing-surface.</p>
<p>Passing NULL as the parameter removes the current coordinate providing layer, and the surface uses the default behaviour for selection of a coordinate providing layer.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">layer_name</td><td>Name of an attached data layer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the layer is a valid coordinate providing layer that is attached to the drawing-surface. </dd></dl>

</div>
</div>
<a id="afe537ed2746b65ecf6349f9efd967173" name="afe537ed2746b65ecf6349f9efd967173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe537ed2746b65ecf6349f9efd967173">&#9670;&#160;</a></span>setDataLayerProps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::setDataLayerProps </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>data_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga1c467581ddf31341ac6acf6baa297a9a">TSLPropertyEnum</a></td>          <td class="paramname"><span class="paramname"><em>property_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLPropertyValue</td>          <td class="paramname"><span class="paramname"><em>new_value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set properties and flags for Data Layer.</p>
<p>This method allows the user to set the properties for the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a>. The properties are specific to this Drawing Surface and will not affect any other Drawing Surface that the named Data Layer is displayed in.</p>
<p>Default values for the properties are documented in <a class="el" href="group__apigroup__api.html#ga1c467581ddf31341ac6acf6baa297a9a">TSLPropertyEnum</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data_id</td><td>User defined name of a <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> in this <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. This is the 'data_id' parameter that was passed when the <a class="el" href="class_t_s_l_data_layer.html">TSLDataLayer</a> was added to the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>.</td></tr>
    <tr><td class="paramname">property_id</td><td>Property to be set.</td></tr>
    <tr><td class="paramname">new_value</td><td>New value for this property.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a1652a09b42b30587627b88c83ac0ecec" name="a1652a09b42b30587627b88c83ac0ecec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1652a09b42b30587627b88c83ac0ecec">&#9670;&#160;</a></span>setDeclutterStatus() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::setDeclutterStatus </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>feature_name</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#gababcf35d0e42f024d8d93535c70bf928">TSLDeclutterStatusEnum</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dataLayerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>detailLayerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set feature decluttering action for a named feature.</p>
<p>This method sets the visibility of a feature within the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. If the visibility is set to automatic the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> will determine when a feature should be made visible or invisible based upon on a resolution factor set in the setDeclutterRange method.</p>
<p>Passing a partial feature class name allows decluttering of the set of all subclasses. For example, decluttering "VMAP0.Contour Line (Land)" will declutter all VMAP0 contour lines.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature_name</td><td>Name of the feature class.</td></tr>
    <tr><td class="paramname">value</td><td>Status value.</td></tr>
    <tr><td class="paramname">dataLayerName</td><td>Name of the layer to set the decluttering on. If this is NULL then the name feature(s) are decluttered on all layers in the drawing surface.</td></tr>
    <tr><td class="paramname">detailLayerName</td><td>name of the detail layer to set the decluttering on - default is 0 to set decluttering for all detail layers in which the feature appears</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a59b777dcbefd270725084ff917384de5" name="a59b777dcbefd270725084ff917384de5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b777dcbefd270725084ff917384de5">&#9670;&#160;</a></span>setDeclutterStatus() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::setDeclutterStatus </td>
          <td>(</td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>feature_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#gababcf35d0e42f024d8d93535c70bf928">TSLDeclutterStatusEnum</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dataLayerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>detailLayerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set feature decluttering action for a feature by its identifier.</p>
<p>This method sets the visibility of a feature within the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. If the visibility is set to automatic the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> will determine when a feature should be made visible or invisible based upon on a resolution factor set in the setDeclutterRange method.</p>
<p>If setting the declutter status of a singular feature and the feature ID is known then this method is more efficient than the alternative setDeclutterStatus that takes the feature name instead of the feature ID.</p>
<p>Applications should generally always pass a layer name to this function. Features in different data layers may have the same feature ID associated with different features as feature IDs are only unique to a data layer. Therefore decluttering features by ID across layers may result in a different feature being decluttered in each layer as the ID maps to a different feature name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">feature_id</td><td>ID of the feature class.</td></tr>
    <tr><td class="paramname">value</td><td>Status value.</td></tr>
    <tr><td class="paramname">dataLayerName</td><td>Name of the layer to set the decluttering on. If this is NULL, the given feature ID will be decluttered on all layers in the drawing surface.</td></tr>
    <tr><td class="paramname">detailLayerName</td><td>name of the detail layer to set the decluttering on - default is 0 to set decluttering for all detail layers in which the feature appears</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a7e1edf066975321c7cd825af58beb1d4" name="a7e1edf066975321c7cd825af58beb1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e1edf066975321c7cd825af58beb1d4">&#9670;&#160;</a></span>setDeclutterStatusOnAllFeatures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::setDeclutterStatusOnAllFeatures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#gababcf35d0e42f024d8d93535c70bf928">TSLDeclutterStatusEnum</a></td>          <td class="paramname"><span class="paramname"><em>value</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>dataLayerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>detailLayerName</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set feature decluttering action on all features that meet the criteria passed.</p>
<p>This method sets the visibility of a set of features within the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a>. If the visibility is set to automatic the <a class="el" href="class_t_s_l_drawing_surface.html">TSLDrawingSurface</a> will determine when a feature should be made visible or invisible based upon on a resolution factor set in the setDeclutterRange method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Status value.</td></tr>
    <tr><td class="paramname">dataLayerName</td><td>Name of the layer to set the decluttering on. Default is 0 i.e. set for all layers.</td></tr>
    <tr><td class="paramname">detailLayerName</td><td>Name of the detail layer to set the decluttering on - default is 0 to set decluttering for all detail layers in which the feature appears</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a6d01bf5edd3a7f32f012a5b9a852cad1" name="a6d01bf5edd3a7f32f012a5b9a852cad1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d01bf5edd3a7f32f012a5b9a852cad1">&#9670;&#160;</a></span>setFeatureRendering() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::setFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#ga88dc5fb1d025ccce6346f1532d0be827">TSLRenderingAttributeBool</a></td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets rendering for a specified feature class.</p>
<p>For further information about what attributes are available, see the setRendering methods on <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</p>
<p>If a name is specified, then all data layers attached to the drawing surface are searched to provide a mapping to ID. They are searched in rendering order from back to front.</p>
<p>Where possible, it is more efficient for an application to use the featureID directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">attribute</td><td>Type of rendering attribute to set</td></tr>
    <tr><td class="paramname">value</td><td>New value for rendering attribute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attribute successfully set, false otherwise. </dd></dl>

</div>
</div>
<a id="a843e54b936b459e6dfecf49543665bfa" name="a843e54b936b459e6dfecf49543665bfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a843e54b936b459e6dfecf49543665bfa">&#9670;&#160;</a></span>setFeatureRendering() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::setFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#gadc41e8eb8a2981626bb3a8384e095abd">TSLRenderingAttributeDouble</a></td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets rendering for a specified feature class.</p>
<p>For further information about what attributes are available, see the setRendering methods on <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</p>
<p>If a name is specified, then all data layers attached to the drawing surface are searched to provide a mapping to ID. They are searched in rendering order from back to front.</p>
<p>Where possible, it is more efficient for an application to use the featureID directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">attribute</td><td>Type of rendering attribute to set</td></tr>
    <tr><td class="paramname">value</td><td>New value for rendering attribute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attribute successfully set, false otherwise. </dd></dl>

</div>
</div>
<a id="aad28bc4cacd259f533cd6b6d31baff5f" name="aad28bc4cacd259f533cd6b6d31baff5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad28bc4cacd259f533cd6b6d31baff5f">&#9670;&#160;</a></span>setFeatureRendering() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::setFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__apigroup__geometry__api.html#ga94b5e06654887d230d5964834f82623a">TSLRenderingAttributeInt</a></td>          <td class="paramname"><span class="paramname"><em>attribute</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets rendering for a specified feature class.</p>
<p>For further information about what attributes are available, see the setRendering methods on <a class="el" href="class_t_s_l_entity.html">TSLEntity</a>.</p>
<p>If a name is specified, then all data layers attached to the drawing surface are searched to provide a mapping to ID. They are searched in rendering order from back to front.</p>
<p>Where possible, it is more efficient for an application to use the featureID directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">attribute</td><td>Type of rendering attribute to set</td></tr>
    <tr><td class="paramname">value</td><td>New value for rendering attribute</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attribute successfully set, false otherwise. </dd></dl>

</div>
</div>
<a id="a6e00cc9c70d5fbef37124d4e309ab00c" name="a6e00cc9c70d5fbef37124d4e309ab00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e00cc9c70d5fbef37124d4e309ab00c">&#9670;&#160;</a></span>setFeatureRendering() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::setFeatureRendering </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>featureName</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TSLFeatureID</td>          <td class="paramname"><span class="paramname"><em>featureID</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_t_s_l_rendering_attributes.html">TSLRenderingAttributes</a> *</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets rendering for a specified feature class.</p>
<p>If a name is specified, then all data layers attached to the drawing surface are searched to provide a mapping to ID. They are searched in rendering order from back to front.</p>
<p>Where possible, it is more efficient for an application to use the featureID directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">featureName</td><td>Name of feature class. NULL means use featureID.</td></tr>
    <tr><td class="paramname">featureID</td><td>Numeric ID of feature class as stored in <a class="el" href="class_t_s_l_entity_base.html#aeed7095e7c897ffd98fb4ea25ff14844">TSLEntity::featureID</a></td></tr>
    <tr><td class="paramname">value</td><td>New value for rendering attributes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if rendering attributes successfully set, false otherwise. </dd></dl>

</div>
</div>
<a id="ae14d30f7088fab43c1f816d823d1955b" name="ae14d30f7088fab43c1f816d823d1955b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae14d30f7088fab43c1f816d823d1955b">&#9670;&#160;</a></span>setFrame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TSLDrawingSurfaceBase::setFrame </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>style</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>colour</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>thickness</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Setup a frame to be drawn around drawing surface.</p>
<p>This frame is drawn once all rendering is complete.</p>
<p>This functionality is not supported in the OpenGL drawing surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">style</td><td>Style for the frame</td></tr>
    <tr><td class="paramname">colour</td><td>Colour of the frame</td></tr>
    <tr><td class="paramname">thickness</td><td>Thickness of the frame</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true on success, false otherwise. </dd></dl>

</div>
</div>
<a id="a11f53b83793beb451d1dd7be0f3303d8" name="a11f53b83793beb451d1dd7be0f3303d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11f53b83793beb451d1dd7be0f3303d8">&#9670;&#160;</a></span>setOption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void TSLDrawingSurfaceBase::setOption </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__apigroup__api.html#ga28a256688c01415721a7700d84fa55bd">TSLOptionEnum</a></td>          <td class="paramname"><span class="paramname"><em>option</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>value</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel virtual">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set option bitfield.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">option</td><td>Enumeration value specifying option to set</td></tr>
    <tr><td class="paramname">value</td><td>New value for option flag. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="class_t_s_l3_d_drawing_surface.html#afc91976e3b3587990cfc359e2bee17ea">TSL3DDrawingSurface</a>, and <a class="el" href="class_t_s_l_accelerated_surface.html#a03857f4831c1ee70cab4029fa09075e5">TSLAcceleratedSurface</a>.</p>

</div>
</div>
<a id="adb3c2bc3e7e95b72564a91c16f046cfd" name="adb3c2bc3e7e95b72564a91c16f046cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb3c2bc3e7e95b72564a91c16f046cfd">&#9670;&#160;</a></span>TMCperMU()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double TSLDrawingSurfaceBase::TMCperMU </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query number of TMC units per map unit.</p>
<p>This value is the number of internal TMC co-ordinates per map unit. These is based upon the last map data layer added to the drawing surface.</p>
<p>Returns the TMC units per map unit, 0.0 on error. </p>

</div>
</div>
<a id="a5dadd653096a1f0cb6fb49a2a08ebf6b" name="a5dadd653096a1f0cb6fb49a2a08ebf6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dadd653096a1f0cb6fb49a2a08ebf6b">&#9670;&#160;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__apigroup__api.html#ga76e1969f4b1b3d601f72cf5936520601">TSLDrawingSurfaceTypeEnum</a> TSLDrawingSurfaceBase::type </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method returns the type of the drawing surface. </p>

</div>
</div>
<a id="a2ba63d2164415f471b835402054095de" name="a2ba63d2164415f471b835402054095de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba63d2164415f471b835402054095de">&#9670;&#160;</a></span>userWord() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * TSLDrawingSurfaceBase::userWord </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the user data stored on the drawing surface. </p>

</div>
</div>
<a id="a1de924d9df6935f26a9e3bee9d59253a" name="a1de924d9df6935f26a9e3bee9d59253a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de924d9df6935f26a9e3bee9d59253a">&#9670;&#160;</a></span>userWord() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TSLDrawingSurfaceBase::userWord </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>ptr</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores a pointer to user data on the drawing surface.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ptr</td><td>The pointer to the user data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a06d217cc978c3dd7d7838602a74b8041" name="a06d217cc978c3dd7d7838602a74b8041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06d217cc978c3dd7d7838602a74b8041">&#9670;&#160;</a></span>m_classID</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* TSLDrawingSurfaceBase::m_classID</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel protected">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.13.2-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="class_t_s_l_drawing_surface_base.html">TSLDrawingSurfaceBase</a></li>
    <li class="footer"><a href="https://envitia.github.io/maplink-docs/">MapLink Pro</a> 11.2 | Documentation created Wed Jul 23 2025 18:22:39 | Generated with <a href="http://www.doxygen.org/index.html">Doxygen 1.13.2</a> | <a href="mailto:support@envitia.com">Contact Us</a> | &copy; 2025 <a href="http://www.envitia.com">Envitia Ltd.</a></li>
  </ul>
</div>
</body>
</html>
